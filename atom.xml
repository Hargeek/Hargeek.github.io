<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>https://www.ssgeek.com</id>
    <title>山山仙人博客</title>
    <updated>2024-01-07T06:40:38.764Z</updated>
    <generator>https://github.com/jpmonette/feed</generator>
    <link rel="alternate" href="https://www.ssgeek.com"/>
    <link rel="self" href="https://www.ssgeek.com/atom.xml"/>
    <logo>https://www.ssgeek.com/images/avatar.png</logo>
    <icon>https://www.ssgeek.com/favicon.ico</icon>
    <rights>All rights reserved 2024, 山山仙人博客</rights>
    <entry>
        <title type="html"><![CDATA[Gradle打包工具入门]]></title>
        <id>https://www.ssgeek.com/post/gradle-da-bao-gong-ju-ru-men</id>
        <link href="https://www.ssgeek.com/post/gradle-da-bao-gong-ju-ru-men">
        </link>
        <updated>2022-03-24T16:43:05.000Z</updated>
        <content type="html"><![CDATA[<p><ul class="markdownIt-TOC">
<li>
<ul>
<li><a href="#1-gradle%E4%BB%8B%E7%BB%8D">1、Gradle介绍</a></li>
<li><a href="#2-gradle%E9%85%8D%E7%BD%AE%E5%88%86%E6%9E%90">2、Gradle配置分析</a>
<ul>
<li><a href="#21-%E6%A0%B9%E7%9B%AE%E5%BD%95%E9%85%8D%E7%BD%AE">2.1 根目录配置</a></li>
<li><a href="#22-%E5%BA%94%E7%94%A8%E7%9B%AE%E5%BD%95%E9%85%8D%E7%BD%AE">2.2 应用目录配置</a></li>
</ul>
</li>
<li><a href="#3-gradle%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95">3、Gradle基础语法</a>
<ul>
<li><a href="#31-%E5%B8%B8%E8%A7%84%E8%AF%AD%E6%B3%95">3.1 常规语法</a></li>
<li><a href="#32-%E9%97%AD%E5%8C%85%E5%92%8Cit%E5%85%B3%E9%94%AE%E5%AD%97">3.2 闭包和it关键字</a></li>
</ul>
</li>
<li><a href="#4-%E7%8E%AF%E5%A2%83%E5%8C%BA%E5%88%86">4、环境区分</a></li>
<li><a href="#5-%E5%A4%9A%E6%B8%A0%E9%81%93%E6%89%93%E5%8C%85">5、多渠道打包</a>
<ul>
<li><a href="#51-%E6%A0%B8%E5%BF%83%E9%80%BB%E8%BE%91">5.1 核心逻辑</a></li>
<li><a href="#52-%E4%B8%80%E9%94%AE%E5%8C%96%E9%85%8D%E7%BD%AE%E5%A4%9A%E6%B8%A0%E9%81%93%E6%89%93%E5%8C%85">5.2 一键化配置多渠道打包</a></li>
</ul>
</li>
<li><a href="#6-gradle%E6%89%93%E5%8C%85%E5%8A%A0%E9%80%9F">6、gradle打包加速</a></li>
</ul>
</li>
</ul>
</p>
<figure data-type="image" tabindex="1"><img src="https://image.ssgeek.com/20220325-01.png" alt=""></figure>
<h2 id="1-gradle介绍">1、Gradle介绍</h2>
<p><code>Gradle</code>是一种自动化构建语言，是一种<code>DSL</code>。目前是<code>Android</code>的默认构建工具，是一个编程框架</p>
<p><code>Gradle</code>是一个基于<code>Apache Ant</code>和<code>Apache Maven</code>概念的项目自动化构建开源工具。它使用一种基于<code>Groovy</code>的特定领域语言(DSL)来声明项目设置，也增加了基于<code>Kotlin</code>语言的<code>kotlin-based DSL</code>，抛弃了基于<code>XML</code>的各种繁琐配置</p>
<p>特点：</p>
<ul>
<li>支持局部构建和增量构建</li>
<li>对多工程的构建支持很出色，工程依赖是<code>gradle</code>的第一公民</li>
<li>是第一个构建集成工具，与<code>ant</code>、<code>maven</code>、<code>ivy</code>有良好的相容相关性</li>
<li><code>gradle</code>的整体设计是以作为一种语言为导向的，而非成为一个严格死板的框架</li>
<li>支持多方式依赖管理：包括从<code>maven</code>远程仓库、<code>nexus</code>私服、<code>ivy</code>仓库以及本地文件系统的<code>jars</code>或者<code>dirs</code></li>
<li>轻松迁移：<code>gradle</code>适用于任何结构的工程，你可以在同一个开发平台平行构建原工程和<code>gradle</code>工程。通常要求写相关测试，以保证开发的插件的相似性，这种迁移可以减少破坏性，尽可能的可靠。这也是重构的最佳实践</li>
</ul>
<h2 id="2-gradle配置分析">2、Gradle配置分析</h2>
<h3 id="21-根目录配置">2.1 根目录配置</h3>
<ul>
<li>settings.gradle</li>
</ul>
<p>在代码编译时最先找到这个文件</p>
<pre><code class="language-gradle">apply from: 'allconfig.gradle'
include: 'app'  // 包含的工程模块
if(buildType==1){
    include ':mylibrary2'
}else if(buildType==2){
    include ':mylibrary'
}
//在这里写一个脚本，让编译速度更快
rootProject.name = 'gradledemo'  // 工程名
</code></pre>
<ul>
<li>build.gradle</li>
</ul>
<pre><code class="language-gradle">// 根目录的构建脚本
buildscript {
    // 指定了仓库
    repositories {
        maven {  // 加速地址要放在最上面，从上往下找
            url 'http://maven.aliyun.com/nexus/content/groups/public/'
        }
        google()
        jcenter()
    }
    dependencies {  // 配置插件
        // gradle 插件版本
        classpath &quot;com.android.tools.build:gradle:4.0.1&quot;
    }
}

allprojects {
    // 项目本身需要的依赖，配置所有的Module公共依赖
    repositories {
        maven {
            url 'http://maven.aliyun.com/nexus/content/groups/public/'
        }
        google()
        jcenter()
    }
}

// 任务
task Clean(type: Delete) {
    delete rootProject.buildDir // 清理每次编译生成的文件
}
</code></pre>
<h3 id="22-应用目录配置">2.2 应用目录配置</h3>
<ul>
<li>build.gradle</li>
</ul>
<pre><code class="language-gradle">// 配置当前Module的属性
// 如果声明的是com.android.library  表示是一个依赖库
// 如果声明的是com.android.plugin   表示是一个插件
// 如果声明的是com.android.application   表示是一个app
apply plugin: 'com.android.application'
// 类似引入包一样，引入外部的gradle配置文件
apply from: 'config.gradle'

android {
    compileSdkVersion 30
    buildToolsVersion &quot;30.0.2&quot;

    defaultConfig {
        applicationId &quot;com.mn.gradledemo&quot;
        minSdkVersion 16
        targetSdkVersion 30
        versionCode 1
        versionName &quot;1.0&quot;
        testInstrumentationRunner &quot;androidx.test.runner.AndridJunitRunner&quot;
    }

    dependencies {
        implementation fileTree(dir: &quot;libs&quot;, include: [&quot;*.jar&quot;])
        implementation 'androidx.appcompat:appcompat:1.2.0'
        implementation 'androidx.constraintlayout:constraintlayout:2.0.4'
        testImplementation 'junit:junit:4.12'
        androidtestInstrumentation 'androidx.test.ext:junit:1.1.2'
        androidtestInstrumentation 'androidx.test.espresso:espresso-core:3.3.0'
    }
}

// 只要声明了一个任务，不用调用就会执行
task stringText{
    // 使用def声明关键字
    def str1 = &quot;shuanyinhao&quot;;
    def str2 = 'danyinhan';
    println(&quot;${str1}---${str2}&quot;)
}
</code></pre>
<ul>
<li>config.gradle</li>
</ul>
<pre><code class="language-gradle">// ext就表示额外的属性声明
ext{
    server = &quot;prod&quot;
    dataSource = &quot;0&quot;
}
</code></pre>
<h2 id="3-gradle基础语法">3、Gradle基础语法</h2>
<h3 id="31-常规语法">3.1 常规语法</h3>
<pre><code class="language-gradle">// list
task list{
    def list=[1,2,3,4,5,6]
    def weekList = ['one','two','three']
    println(list[0])
    println(weekList[0])
    for(int i in 1..10){
        println i
    }
    // 这里的it就表示每一个元素, it是一个关键字，表示它自己
    weekList.each {
        println it
    }
}

// map
task map{
    def map:['name':'jack','age':19]
    println map['name']
    map.each {
        println &quot;key:${it.key},value:${it.value}&quot;
    }
    println(methodA(2,3)) // 5
}

// 在gradle语法当中，定义一个方法
// 如果在没有return的情况下，函数默认会返回最后一行非空的值
def methodA(int a,int b){
    a+b
}

// 怎样定义一个对象
task javaBeanTask{
    Student student = new Student()
    student.name = &quot;Lily&quot;
    student.age = 19
    println student.name + &quot;---${student.age}&quot;
    println student.getName() + &quot;---${student.getAge()}&quot;
}

class Student{
    String name
    int age

    String getName(){
        return name
    }

    void setName(String name){
        this.name = name
    }

    int getAge(){
        return age
    }

    void setAge(int age){
        this.age = age
    }
}
</code></pre>
<h3 id="32-闭包和it关键字">3.2 闭包和it关键字</h3>
<p><code>Groovy</code>中的闭包是一个开放，匿名的代码块，可以接受参数，返回值并赋值给变量</p>
<p>闭包，是一个代码块，或可以理解成一个匿名函数，在外部方法调用时，可以将其作为方法的实参传递给方法的形参，并在方法内部回调此匿名函数，且回调此匿名函数时可以传递实参给到匿名函数的内部去接收，并执行此匿名函数</p>
<p>同时，此代码块或匿名函数也可以赋值给一个变量，使其具有自执行的能力，且最后一行的执行语句作为匿名函数的返回</p>
<pre><code class="language-gradle">// 闭包，自定义闭包
def mEach(closure){
    for(int i in 1..5){
        closure(i)
    }
}

def mEachWithParams(closure){
    def map = ['name':'groovy','age':10]
    map.each{
        closure(it.key,it.value)
    }
}

// 调用闭包
task closureTask{
    // 回调一个参数的时候，it就是指这个参数，就能用it，多个就不行了
    mEach({
        println it
        // a-&gt;println a
    })
    mEachWithParams{
        m,n—&gt;println &quot;${m} is ${n}&quot;
    }
}
</code></pre>
<h2 id="4-环境区分">4、环境区分</h2>
<p>主要目的是不需要修改代码就能区分测试环境和生产环境</p>
<p>例如有这样的代码目录（不同环境的配置文件）</p>
<pre><code class="language-shell">app/src/main/filters/debug/config.properties
app/src/main/filters/release/config.properties
</code></pre>
<p>通过读取文件流实现按不同环境区分</p>
<ul>
<li>build.gradle</li>
</ul>
<pre><code class="language-gradle">// 配置当前Module的属性
// 如果声明的是com.android.library  表示是一个依赖库
// 如果声明的是com.android.plugin   表示是一个插件
// 如果声明的是com.android.application   表示是一个app
apply plugin: 'com.android.application'
// 类似引入包一样，引入外部的gradle配置文件
apply from: 'config.gradle'

android {
...

    // 构建类型
    buildTypes{
        // 测试环境
        debug{
            // 参数: 声明的类型、名字、属性值
            buildConfigField 'String','SERVER2',getServer2('debug')
        }
        release{
            buildConfigField 'String','SERVER2',getServer2('release')
        }
    }
}

// 读取文件流,str代表debug还是release
def getServer2(String str){
    def SERVER2
    Properties properties = new Properties();
    // 相对路径
    def proFile = file(&quot;src/main/filters/&quot;+str+&quot;/config.properties&quot;)
    if(proFile.canRead()){
        properties.load(new FileInputStream(proFile))
        if(properties!=null){
            SERVER2 = properties['SERVER2']
        }
    }
    return SERVER2
}
</code></pre>
<h2 id="5-多渠道打包">5、多渠道打包</h2>
<p>多渠道打包常用于安卓<code>app</code>，例如统计不同渠道的数据（投放到多个应用市场）</p>
<h3 id="51-核心逻辑">5.1 核心逻辑</h3>
<p>主要核心实现如下</p>
<pre><code class="language-gradle">apply plugin: 'com.android.application'
apply from: 'config.gradle'

android {
    compileSdkVersion 30
    buildToolsVersion &quot;30.0.2&quot;

    defaultConfig {
        applicationId &quot;com.mn.gradledemo&quot;
        minSdkVersion 16
        targetSdkVersion 30
        versionCode 1
        versionName &quot;1.0&quot;
        testInstrumentationRunner &quot;androidx.test.runner.AndridJunitRunner&quot;
        // 多渠道打包
        flavorDimensions &quot;versionCode&quot;
    }
...

    // 构建类型
    buildTypes{
        // 测试环境
        debug{
            // 参数: 声明的类型、名字、属性值
            buildConfigField 'String','SERVER2',getServer2('debug')
            android.applicationVariants.all{
                variant -&gt;
                    variant.outputs.all{
                        def fileName = &quot;${getCurrentTime()}_V{defaultConfig.versionName}_debug.apk&quot;
                        outputFileName = fileName
                    }
            }
        }
        release{
            buildConfigField 'String','SERVER2',getServer2('release')
        }
    }

    // 多渠道打包
    productFlavors{
        xiaomi{
            buildConfigField 'String','PLATE_FORM',&quot;\&quot;xiaomi\&quot;&quot;
            manifestPlaceholders = [UMENG_CHANNEL_VALUE: &quot;xiaomi&quot;]
        }
        yinyongbao{
            buildConfigField 'String','PLATE_FORM',&quot;\&quot;yingyongbao\&quot;&quot;
            manifestPlaceholders = [UMENG_CHANNEL_VALUE: &quot;yingyongbao&quot;]
        }
    }
}

static def getCurrentTime(){
    return new Date().format(&quot;yyyy-MM-dd&quot;,timeZone.getTimeZone(&quot;UTC&quot;))
}
</code></pre>
<h3 id="52-一键化配置多渠道打包">5.2 一键化配置多渠道打包</h3>
<pre><code class="language-gradle">    // 一键化多渠道打包
    productFlavors{
        xiaomi{}
        yingyongbao{}
    }
    productFlavors.all{
        flavor -&gt;
            flavor.manifestPlaceholders = [UMENG_CHANNEL_VALUE: name]
            buildConfigField 'String','PLATE_FORM',&quot;\&quot;${name}\&quot;&quot;
    }
</code></pre>
<h2 id="6-gradle打包加速">6、gradle打包加速</h2>
<p>和<code>maven</code>打包一样，<code>gradle</code>会在编译时的用户家目录，例如<code>/root/.gradle</code>目录下生成一个缓存目录，除此之外，在应用的目录下也会生成一个<code>build</code>目录，这个目录下也有相应的<code>build cache</code></p>
<p>可以在全局配置<code>gradle</code>，使其拉取插件时走国内的源</p>
<p>配置文件为<code>/root/.gradle/init.gradle</code>，内容如下</p>
<pre><code class="language-gradle">allprojects {
    repositories {
        mavenLocal()
		maven { name &quot;Aliyun&quot; ; url &quot;https://maven.aliyun.com/repository/public&quot; }
		maven { name &quot;Bstek&quot; ; url &quot;http://nexus.bsdn.org/content/groups/public/&quot; }
    }

	buildscript { 
		repositories { 
			maven { name &quot;Aliyun&quot; ; url 'https://maven.aliyun.com/repository/public' }
			maven { name &quot;Bstek&quot; ; url 'http://nexus.bsdn.org/content/groups/public/' }
			maven { name &quot;M2&quot; ; url 'https://plugins.gradle.org/m2/' }
		}
	}
}
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[基于阿里云RAM+ACK托管版集群的RBAC授权]]></title>
        <id>https://www.ssgeek.com/post/ji-yu-a-li-yun-ramack-tuo-guan-ban-ji-qun-de-rbac-shou-quan</id>
        <link href="https://www.ssgeek.com/post/ji-yu-a-li-yun-ramack-tuo-guan-ban-ji-qun-de-rbac-shou-quan">
        </link>
        <updated>2022-02-22T16:19:25.000Z</updated>
        <content type="html"><![CDATA[<p><ul class="markdownIt-TOC">
<li>
<ul>
<li><a href="#1-%E8%83%8C%E6%99%AF">1、背景</a></li>
<li><a href="#2-%E6%8E%88%E6%9D%83%E4%BD%93%E7%B3%BB%E6%A6%82%E8%BF%B0">2、授权体系概述</a>
<ul>
<li><a href="#21-k8s%E6%8E%88%E6%9D%83%E4%BD%93%E7%B3%BB">2.1 k8s授权体系</a></li>
<li><a href="#22-%E9%98%BF%E9%87%8C%E4%BA%91ram%E9%81%87%E4%B8%8Arbac">2.2 阿里云RAM遇上RBAC</a></li>
</ul>
</li>
<li><a href="#3-%E6%8E%88%E6%9D%83%E8%BF%87%E7%A8%8B">3、授权过程</a>
<ul>
<li><a href="#31-%E5%88%9B%E5%BB%BAram%E7%94%A8%E6%88%B7%E5%B9%B6%E6%8E%88%E6%9D%83">3.1 创建RAM用户并授权</a></li>
<li><a href="#32-ack%E9%9B%86%E7%BE%A4%E4%B8%AD%E5%88%9B%E5%BB%BAclusterrole">3.2 ACK集群中创建ClusterRole</a></li>
<li><a href="#33-%E6%8E%A7%E5%88%B6%E5%8F%B0%E6%8E%88%E6%9D%83%E7%BB%91%E5%AE%9A">3.3 控制台授权绑定</a></li>
<li><a href="#34-%E8%8E%B7%E5%8F%96%E8%BF%9E%E6%8E%A5%E9%9B%86%E7%BE%A4%E7%9A%84config">3.4 获取连接集群的config</a></li>
</ul>
</li>
<li><a href="#4-%E5%B0%8F%E7%BB%93">4、小结</a></li>
</ul>
</li>
</ul>
</p>
<figure data-type="image" tabindex="1"><img src="https://image.ssgeek.com/20220223-01.png" alt=""></figure>
<h2 id="1-背景">1、背景</h2>
<p>使用阿里云<code>ack</code>托管版运行<code>k8s</code>集群，有时需要对团队内成员授权集群非管理员的权限，以及某些服务需要调用<code>k8s</code>相关<code>api</code>做特定操作，例如在指定的某<code>namespace</code>下创建某控制器（例如<code>deployment</code>）的权限</p>
<p>由于在<code>ack</code>托管版环境下，集群的<code>master</code>节点由阿里云托管，对租户不可见，因此除了基于<code>k8s</code>的<code>RBAC</code>权限外，还需要授予阿里云的授权体系，即<code>RAM</code></p>
<h2 id="2-授权体系概述">2、授权体系概述</h2>
<h3 id="21-k8s授权体系">2.1 k8s授权体系</h3>
<p>先来回忆一下<code>k8s</code>的<code>RBAC</code>（Role-Based Access Control）基于角色的访问控制授权体系</p>
<p>这是一种很常见并通用的授权体系，在<code>k8s</code>中，<code>RBAC</code>使用<code>rbac.authorization.k8s.io</code> API Group 来实现授权决策</p>
<p><code>Kubernetes</code>从<code>1.6</code>版本开始支持<code>RBAC</code>，集群管理员可以对用户或服务账号的角色进行更精确的资源访问控制。允许管理员通过<code>Kubernetes API</code>动态配置策略，在<code>RBAC</code>中，权限与角色相关联，用户通过成为适当角色的成员而得到这些角色的权限。这就极大地简化了权限的管理。在一个组织中，角色是为了完成各种工作而创造，用户则依据它的责任和资格来被指派相应的角色，用户可以很容易地从一个角色被指派到另一个角色</p>
<figure data-type="image" tabindex="2"><img src="https://image.ssgeek.com/20220223-02.png" alt=""></figure>
<p>如上图所示，左边对于<code>Pod</code>资源的<code>get</code>、<code>list</code>操作（称为请求动词）类似于常见的<code>CRUD</code>，对<code>k8s</code>的相关资源操作都是以<code>REST API</code>形式发起，每一类请求动词对应<code>http</code>请求如下表</p>
<table>
<thead>
<tr>
<th>HTTP 动词</th>
<th>请求动词</th>
</tr>
</thead>
<tbody>
<tr>
<td>POST</td>
<td>create</td>
</tr>
<tr>
<td>GET, HEAD</td>
<td>get （针对单个资源）、list（针对集合）</td>
</tr>
<tr>
<td>PUT</td>
<td>update</td>
</tr>
<tr>
<td>PATCH</td>
<td>patch</td>
</tr>
<tr>
<td>DELETE</td>
<td>delete（针对单个资源）、deletecollection（针对集合）</td>
</tr>
</tbody>
</table>
<p><code>k8s</code>中的资源和<code>API Group</code>关联，不同的资源属于不同的<code>API Group</code>，例如<code>Pod</code>属于<code>Core API Group</code>，<code>Deployements</code>属于<code>apps API Group</code></p>
<p>资源操作的集合叫做<code>Rule</code>，<code>RBAC</code>中的角色，在k8s中分为<code>Role</code>和<code>ClusterRole</code>，其区别就是前者是命名空间级别下，后者不限命名空间（集群范围内生效）</p>
<p>上图最右边即用户，<code>k8s</code>中的<code>用户</code>可以分为三类：User、Group、Service Account，<code>User</code>即传统意义上的用户，这个用户一般由外部服务管理；<code>Group</code>用来关联多个账户；而<code>Service Account</code>（服务帐号）就是通过<code>Kubernetes API</code>来管理的一些用户帐号，适用于集群内部运行的应用程序。所有的用户称作一个<code>Subject</code></p>
<p>有了角色和用户，就需要两者之间的绑定关系，由于角色有<code>Role</code>和<code>ClusterRole</code>两类，因此绑定关系也分为<code>RoleBinding</code>和<code>ClusterRoleBinding</code>，即把声明的<code>Subject</code>和想要绑定的<code>Role</code>进行绑定（给某个用户绑定上某些操作的权限），二者作用范围和角色类似</p>
<h3 id="22-阿里云ram遇上rbac">2.2 阿里云RAM遇上RBAC</h3>
<p>如文章封面图所示，<code>ACK</code>的授权体系包含对基础资源层的<code>RAM</code>授权和对<code>ACK</code>集群层的<code>RBAC</code>授权两部分</p>
<ul>
<li><code>RAM</code>授权对应<code>ACK</code>集群的运维操作，需要获取<code>ACK</code>产品及其所依赖阿里云云产品的<code>OpenAPI</code>操作权限，主要包括以下操作：
<ul>
<li>集群：创建、查看、升级、删除</li>
<li>节点池：创建、修改、扩缩容</li>
<li>授权管理</li>
<li>集群监控、日志、事件</li>
</ul>
</li>
<li><code>RBAC</code>授权对应的是运行于<code>ACK</code>集群中<code>Kubernetes</code>应用的运维操作，需要获取ACK集群及其命名空间的操作权限，主要包括对以下<code>Kubernetes</code>对象的增删改查操作：
<ul>
<li>工作负载：Deployment、StatefulSet、DaemonSet、Job、CronJob、Pod、ReplicaSet、HPA等</li>
<li>网络：Service、Ingress、NetworkPolicy等</li>
<li>存储：PV、PVC、StorageClass等</li>
<li>Namespace、ConfigMap 、Secrets等</li>
</ul>
</li>
</ul>
<p>因此当<code>RAM</code>用户或<code>RAM</code>角色需要进行集群运维和应用运维时，需要依次对其进行<code>RAM</code>授权和<code>RBAC</code>授权</p>
<p>对于<code>RAM</code>这里不再深入，因为阿里云<code>RAM</code>关联了很多很多不同的云产品统一进行授权，因此很复杂，也不做过多研究</p>
<h2 id="3-授权过程">3、授权过程</h2>
<p>上面对阿里云<code>RAM</code>和<code>k8s</code>的<code>RBAC</code>两个体系做了简要介绍和回顾，接下来根据一个实际场景简要介绍授权的整个过程以及需要注意的踩坑点</p>
<p>需求如下：</p>
<p>研发或集群外服务需要操作某集群，例如<code>dev</code>（开发）<code>ack</code>集群，具有<code>dev</code>命名空间的创建、删除<code>deployment</code>、<code>service</code>、<code>ingress</code>这三类资源的权限</p>
<p>若服务在集群内，那么就可以通过<code>ServiceAccount</code>方式，假设服务在集群外，目的是要生成一个给<code>kubectl</code>使用的<code>config</code>文件</p>
<h3 id="31-创建ram用户并授权">3.1 创建RAM用户并授权</h3>
<p>由于用户最终只能通过控制台才能获取<code>config</code>文件，因此需要创建一个可以登录控制台，并对<code>ack</code>具有只读权限的用户</p>
<figure data-type="image" tabindex="3"><img src="https://image.ssgeek.com/20220223-03.png" alt=""></figure>
<p>然后对用户进行授权，记录下用户的密码</p>
<figure data-type="image" tabindex="4"><img src="https://image.ssgeek.com/20220223-04.png" alt=""></figure>
<h3 id="32-ack集群中创建clusterrole">3.2 ACK集群中创建ClusterRole</h3>
<p>在集群中创建相关授权通常是通过编写对应的<code>yaml</code>资源清单</p>
<p>这里推荐一个图形化的工具<code>Permission manager</code>，是一个简单便捷的<code>RBAC</code>管理界面工具，支持通过<code>web</code>界面创建用户，分配<code>Namespace</code>权限，并可以生成<code>kubeconfig</code>文件，项目地址https://github.com/sighupio/permission-manager</p>
<p>前面需求提到是指定命名空间下的权限，但这里是创建<code>ClusterRole</code>而不是<code>Role</code>，这个问题后面解释</p>
<p><code>ClusterRole</code>的内容如下</p>
<pre><code class="language-yaml">kind: ClusterRole
apiVersion: rbac.authorization.k8s.io/v1
metadata:
  name: project-rbac-role
rules:
  - apiGroups: [&quot;extensions&quot;, &quot;apps&quot;]
    resources: [&quot;deployments&quot;]
    verbs: [&quot;create&quot;, &quot;delete&quot;]
  - apiGroups: [&quot;&quot;]
    resources: [&quot;service&quot;]
    verbs: [&quot;create&quot;, &quot;delete&quot;]
  - apiGroups: [&quot;networking.k8s.io&quot;]
    resources: [&quot;ingress&quot;]
    verbs: [&quot;create&quot;, &quot;delete&quot;]

</code></pre>
<p>使用<code>kubectl</code>进行创建</p>
<pre><code class="language-shell">➜  rbac git:(master) ✗ kubectl apply -f clusterrole.yaml
</code></pre>
<h3 id="33-控制台授权绑定">3.3 控制台授权绑定</h3>
<p>在<code>ack</code>的控制台对<code>ram</code>用户授权，点击到某个集群——&gt;安全管理——&gt;授权，选择上面创建的<code>ram</code>子账号，点击“管理权限”，选择集群（这里虽然已经进入到了特定集群，但依然可以选择其他集群，或许是<code>ack</code>产品设计上有点不合理），选择对应要授权的命名空间，访问权限选择“自定义”，然后下拉就能找到上面创建的名为<code>project-rbac-role</code>的<code>ClusterRole</code></p>
<p>上面提到了创建<code>ClusterRole</code>而不是<code>Role</code>，原因就在这里，因为这里下拉只能读取到集群中存在的<code>ClusterRole</code>，选择完成后点击下一步，授权成功</p>
<figure data-type="image" tabindex="5"><img src="https://image.ssgeek.com/20220223-05.png" alt=""></figure>
<p>那么，既然已经使用了<code>ClusterRole</code>，又选定了命名空间，因此相当于还是基于<code>Role</code>的权限？</p>
<p>没错，实际上这里的操作是对应的在<code>ack</code>集群中创建了一个<code>Rolebinding</code>绑定集群的<code>ClusterRole</code>，正常来说应该是<code>Rolebinding</code>绑定集群的<code>Role</code>，<code>ClusterRolebinding</code>绑定集群的<code>ClusterRole</code>，这里相当于交叉绑定了，但实际上这个<code>ClusterRole</code>的权限范围缩小了</p>
<p>可以通过如下方式查看集群中的<code>Rolebinding</code>，名称大致为“ram用户的uid-命名空间-clusterrole的名称-rolebinding”，关联的<code>subjects</code>用户正是<code>ram</code>用户的<code>uid</code></p>
<pre><code class="language-shell">➜  rbac git:(master) ✗ kubectl get rolebinding -n dev|grep 29xxxxxxxxxxx1
29xxxxxxxxxxx1-dev-project-rbac-role-rolebinding   ClusterRole/project-rbac-role    41m
➜  rbac git:(master) ✗ kubectl -n dev get rolebinding 29xxxxxxxxxxx1-dev-project-rbac-role-rolebinding -o yaml|kubectl neat
apiVersion: rbac.authorization.k8s.io/v1
kind: RoleBinding
metadata:
  name: 29xxxxxxxxxxx1-dev-project-rbac-role-rolebinding
  namespace: dev
roleRef:
  apiGroup: rbac.authorization.k8s.io
  kind: ClusterRole
  name: project-rbac-role
subjects:
- apiGroup: rbac.authorization.k8s.io
  kind: User
  name: &quot;29xxxxxxxxxxx1&quot;
</code></pre>
<p>到这里授权就完成了</p>
<h3 id="34-获取连接集群的config">3.4 获取连接集群的config</h3>
<p>用上面创建的<code>readonly</code>这个<code>ram</code>用户登录到<code>ack</code>的每个集群控制台，获取这个<code>ram</code>用户的集群连接信息即<code>config</code>内容，保存成文件即可</p>
<h2 id="4-小结">4、小结</h2>
<p>使用<code>ack</code>托管版对集群授权需要关联<code>ram</code>用户和集群<code>RBAC</code>的<code>ClusterRole</code>，无需在集群中手动创建其他资源，整个过程中有一定的小坑和个人感觉设计不太合理的地方仅供参考~</p>
<p>See you ~</p>
<blockquote>
<p>参考</p>
<p>https://kubernetes.io/zh/docs/reference/access-authn-authz/authorization/</p>
<p>https://help.aliyun.com/document_detail/119596.html</p>
</blockquote>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[服务网格和Istio初识-续]]></title>
        <id>https://www.ssgeek.com/post/fu-wu-wang-ge-he-istio-chu-shi-xu</id>
        <link href="https://www.ssgeek.com/post/fu-wu-wang-ge-he-istio-chu-shi-xu">
        </link>
        <updated>2022-01-19T16:21:46.000Z</updated>
        <content type="html"><![CDATA[<p><ul class="markdownIt-TOC">
<li>
<ul>
<li><a href="#1-%E6%9C%8D%E5%8A%A1%E6%B2%BB%E7%90%86%E7%9A%84%E4%B8%89%E7%A7%8D%E5%BD%A2%E6%80%81">1、服务治理的三种形态</a></li>
<li><a href="#2-%E6%9C%8D%E5%8A%A1%E7%BD%91%E6%A0%BC%E7%9A%84%E7%89%B9%E7%82%B9">2、服务网格的特点</a></li>
<li><a href="#3-%E7%BD%91%E6%A0%BC%E5%B8%A6%E6%9D%A5%E7%9A%84%E6%8D%9F%E8%80%97">3、网格带来的损耗</a></li>
<li><a href="#4-%E4%B8%BA%E4%BB%80%E4%B9%88%E6%9C%8D%E5%8A%A1%E7%BD%91%E6%A0%BC%E9%80%89%E6%8B%A9istio">4、为什么服务网格选择Istio</a></li>
<li><a href="#5-istio%E4%B8%8Ekubernetes">5、Istio与kubernetes</a></li>
<li><a href="#6-%E5%BE%AE%E6%9C%8D%E5%8A%A1%E5%92%8Cistio%E7%9A%84%E9%80%89%E6%8B%A9%E4%BE%A7%E9%87%8D">6、微服务和Istio的选择侧重</a></li>
<li><a href="#7-istio%E7%9A%84%E4%BE%B5%E5%85%A5%E6%80%A7">7、Istio的侵入性</a></li>
<li><a href="#8-istio%E7%94%A8%E5%9C%A8%E5%93%AA">8、Istio用在哪</a></li>
<li><a href="#9-istio%E5%81%9A%E4%BA%86%E4%BB%80%E4%B9%88">9、Istio做了什么</a></li>
<li><a href="#10-%E7%94%A8%E4%BB%80%E4%B9%88%E5%A7%BF%E5%8A%BF%E6%8E%A5%E5%85%A5-istio">10、用什么姿势接入 Istio</a></li>
<li><a href="#11-istio%E4%B8%8D%E6%98%AF%E9%93%B6%E5%BC%B9">11、Istio不是银弹</a></li>
</ul>
</li>
</ul>
</p>
<p>本文是<a href="https://www.ssgeek.com/post/fu-wu-wang-ge-he-Istio-ru-men/">服务网格和Istio初识</a>的续篇内容，主要是漫谈(记录)一些关于服务网格、<code>Istio</code>的一些理论及个人认知</p>
<blockquote>
<p>为什么还要写这类看似枯燥的文章？我始终认为，学习和实践应用一门新技术之前，应该做好多方调研，全局认知，当前有什么痛点能解决而不是有哪些功能能拿来用等等，到最后不至于仅仅是用了起来而已</p>
</blockquote>
<h2 id="1-服务治理的三种形态">1、服务治理的三种形态</h2>
<p>服务治理的发展经过了以下三种形态的演进</p>
<ul>
<li>应用程序中包含治理逻辑（代码自行实现，复用性很低）</li>
<li>治理逻辑独立的代码（<code>sdk</code>方式，提高复用性，但避免不了的是要应用一起打包部署）</li>
<li>治理逻辑独立的进程（<code>sidecar</code>模式，对应用无感知，解耦合）</li>
</ul>
<h2 id="2-服务网格的特点">2、服务网格的特点</h2>
<ul>
<li>基础设施：服务网格是一种处理服务间通信的基础设施层</li>
<li>云原生：服务网格尤其适用于在云原生场景下帮助应用程序在复杂的服务拓扑间可靠地传递请求</li>
<li>网络代理：在实际使用中，服务网格一般是通过一组轻量级网络代理来执行治理逻辑的</li>
<li>对应用透明：轻量网络代理与应用程序部署在一起，但应用感知不到代理的存在，还是使用原来的方式工作</li>
</ul>
<h2 id="3-网格带来的损耗">3、网格带来的损耗</h2>
<p>传统环境下，服务<code>A</code>到服务<code>B</code>可以直接通过网络（<code>ip</code>或服务名）直连</p>
<p>用了网格后，从<code>A</code>服务到<code>B</code>服务的一个访问必须要经过<code>A</code>服务的<code>Sidecar</code>拦截<code>Outbound</code>流量执行治理动作；再经过<code>B</code>服务的<code>Sidecar</code>拦截<code>Inbound</code>流量，执行治理动作。 这就引入两个问题：</p>
<ul>
<li>增加了两处延迟和可能的故障点</li>
<li>多出来的这两跳对于访问性能、整体可靠性及整个系统的复杂度都带来了新的挑战</li>
</ul>
<p>通过保证转发代理的轻量和高性能降低时延影响，尤其是考虑到后端实际使用的应用程序一般比代理更重，叠加代理并不会明显影响应用的访问性能；另外，对于这些高性能的代理，只要消耗足够的资源总能达到期望的性能， 特别是云原生场景下服务的弹性特点使得服务实例的弹性扩展变得非常方便，通过扩展实例数量总是能得到期望的访问性能</p>
<p>因此最终需要决策的是：<br>
是否愿意花费额外的少量资源在这些基础设施上来换取开发、运维的灵活性、业务的非侵入性和扩展性等便利？</p>
<h2 id="4-为什么服务网格选择istio">4、为什么服务网格选择Istio</h2>
<ul>
<li>控制面设计</li>
</ul>
<p><code>Istio</code>作为一种全新的设计，在功能、形态、架构和扩展性上提供了远超服务网格的能力范围。它基于<code>xDS</code>协议提供了一套标准的控制面规范，向数据面传递服务信息和治理规则。<code>Istio</code>的早期版本使用<code>Envoy V1</code>版本的<code>API</code>，即<code>Restful</code>方式，其新版本使用<code>Envoy V2</code>版本的<code>API</code>，即<code>gRPC</code>协议。标准的控制面<code>API</code>解耦了控制面和数据面的绑定。<code>Nginx</code>的<code>nginMesh</code>、<code>F5 Networks</code>的<code>Aspen Mesh</code>等多种数据面代理支持<code>Istio</code>的控制面，甚至有些老牌微服务<code>SDK</code>也开始往<code>Istio</code>上集成</p>
<ul>
<li>数据面设计</li>
</ul>
<p><code>Istio</code>的标准数据面<code>Envoy</code>是由<code>Lyft</code>内部于<code>2016</code>年开发的，比<code>Linkerd</code>更早。<code>2016</code>年<code>9</code>月，<code>Envoy</code>开源并发布了<code>1.0.0</code>版本；<code>2017</code>年<code>9</code>月，<code>Envoy</code>加入<code>CNCF</code>，成为第<code>2</code>个<code>Service Mesh</code>项目；<code>2018</code>年<code>11</code>月，<code>Envoy</code>从<code>CNCF</code>毕业，这标志着其趋于成熟。从开发语言上看，<code>Envoy</code>是使用<code>C++</code>开发的，其性能和资源占用比用<code>Rust</code>开发的<code>Linkerd Proxy</code>要更好，更能满足服务网格中对透明代理的轻量高性能要求；从能力上看，<code>Envoy</code>提供<code>L3/L4</code>过滤器、<code>HTTP L7</code>过滤器，支持<code>HTTP/2</code>、<code>HTTP L7</code>路由及<code>gRPC</code>、<code>MongoDB</code>、<code>DynamoDB</code>等协议，有服务发现、健康检查、高级<code>LB</code>、前端代理等能力，具有极好的 可观察性、动态配置功能；从架构实现上看，<code>Envoy</code>是一个可高度定制化的程序，通过<code>Filter</code>机制提供了 高度扩展性，还支持热重启，其代码基于模块化编码，易于测试。除了在<code>Istio</code>中应用，<code>Envoy</code>在其他<code>Service Mesh</code>框架中也被广泛应用，渐渐成为<code>Service Mesh</code>的数据平面标准</p>
<ul>
<li>大厂加持</li>
</ul>
<p><code>Istio</code>由谷歌和<code>IBM</code>共同推出，从应用场景的分析规划到本身的定位，从自身架构的设计到与周边生态的结合，都有着比较严密的论证。<code>Istio</code>项目在发起时已经确认了将云原生生态系统中的容器作为核心打包和运行时，将<code>Kubernetes</code>作为管理容器的编排系统，需要一个系统管理在容器 平台上运行的服务之间的交互，包括控制访问、安全、运行数据收集等，而<code>Istio</code>正是为此而生的；另外，<code>Istio</code>成为架构的默认部分，就像容器和<code>Kubernetes</code>已经成为云原生架构的默认部分一样</p>
<p>另外一点，很多的公有云厂商在提供<code>kubernetes</code>容器服务时也内置了<code>Istio</code>功能或者二次开发（包装）了<code>Istio</code>，例如阿里云的<code>asm</code></p>
<h2 id="5-istio与kubernetes">5、Istio与kubernetes</h2>
<p><code>Istio</code>和<code>Kubernetes</code>从设计理念、使用体验、系统架构甚至代码风格等小细节来看，关系都非常紧密。更细粒度的proxy提供更多更细粒度的能力</p>
<p><img src="https://image.ssgeek.com/20220120-01.png" alt=""><code>Istio</code>最大化地利用了<code>Kubernetes</code>这个基础设施，与之叠加在一起形成了一个更强大的用于进行服务运行和治理的基础设施，并提供了更透明的用户体验。</p>
<ul>
<li>数据面</li>
</ul>
<p>数据面<code>Sidecar</code>运行在<code>Kubernetes</code>的<code>Pod</code>里，作为一个<code>Proxy</code>和业务容器部署在一起。在服务网格的定义中要求应用程序在运行的时候感知不到<code>Sidecar</code>的存在。而基于<code>Kubernetes</code>的一个<code>Pod</code>多个容器的优秀设计使得部署运维对用户透明，用户甚至感知不到部署<code>Sidecar</code>的过程。用户还是用原有的方式创建负载，通过<code>Istio</code>的自动注入服务，可以自动给指定的负载注入<code>Proxy</code>。如果在另一种环境下部署和使用<code>Proxy</code>，则不会有这样的便利</p>
<ul>
<li>统一服务发现</li>
</ul>
<p><code>Istio</code>的服务发现机制非常完美地基于<code>Kubernetes</code>的域名访问机制构建而成，省去了再搭一个类似<code>Eureka</code>的注册中心的麻烦，更避免了在<code>Kubernetes</code>上运行时服务发现数据不一致的问题</p>
<p>尽管<code>Istio</code>强调自己的可扩展性的重要性在于适配各种不同的平台，也可以对接其他服务发现机制，但在实际场景下，通过深入分析<code>Istio</code>几个版本的代码和设计，便可以发现其重要的能力都是基于<code>Kubernetes</code>进行构建的</p>
<ul>
<li>基于<code>Kubernetes CRD</code>描述规则</li>
</ul>
<p><code>Istio</code>的所有路由规则和控制策略都是通过<code>Kubernetes CRD</code>实现的，因此各种规则策略对应的数据也被存储在<code>kube-apiserver</code>中，不需要另外一个单独的<code>APIServer</code>和后端的配置管理。所以，可以说<code>Istio</code>的<code>APIServer</code>就是<code>Kubernetes</code>的<code>APIServer</code>，数据也自然地被存在了对应<code>Kubernetes</code>的<code>etcd</code>中</p>
<p><code>Istio</code>非常巧妙地应用了<code>Kubernetes</code>这个好基座，基于<code>Kubernetes</code>的已有能力来构建自身功能。<code>Kubernetes</code>里已经有的，绝不再自己搞一套，避免了数据不一致和用户使用体验的问题</p>
<p><code>Istio</code>不仅数据面<code>Envoy</code>跑在<code>Kubernetes</code>的<code>Pod</code>里，其控制面也运行在<code>Kubernetes</code>集群中，其控制面组件本身存在的形式也是<code>Kubernetes Deployment</code>和<code>Service</code>，基于<code>Kubernetes</code>扩展和构建</p>
<figure data-type="image" tabindex="1"><img src="https://image.ssgeek.com/20220120-02.png" alt=""></figure>
<p>最后，看看微服务、容器、<code>Kubernetes</code>、<code>Istio</code>四者的关系</p>
<figure data-type="image" tabindex="2"><img src="https://image.ssgeek.com/20220120-03.png" alt=""></figure>
<h2 id="6-微服务和istio的选择侧重">6、微服务和Istio的选择侧重</h2>
<p>微服务是架构风格、方法论，<code>Istio</code>是一套完整的实践</p>
<p>但是，回到我在本文开头提到的一点观念，<code>Istio</code>是用来解决问题的，并不是微服务理论的一种落地，在实际项目中拿着微服务的细节列表来硬套<code>Istio</code>的功能，比如要求<code>Istio</code>治理的服务必须实现微服务的服务注册的一些细节，就明显不太适当</p>
<h2 id="7-istio的侵入性">7、Istio的侵入性</h2>
<p>从单个应用来看，<code>Sidecar</code>与应用进程的解耦带来的应用完全无侵入、开发语言无关等特点解除了开发语言的约束，从而极大降低了应用开发者的开发成本。这种方式也经常被称为一种应用的基础设施层，类比<code>TCP/IP</code>网络协议栈，应用程序像使用<code>TCP/IP</code>一样使用这个通用代理：<code>TCP/IP</code>负责将字节码可靠地在网络节点间传递，<code>Sidecar</code>则负责将请求可靠地在服务间进行传递。<code>TCP/IP</code>面向的是底层的数据流，<code>Sidecar</code>则可以支持多种高级协议（<code>HTTP</code>、<code>gRPC</code>、<code>HTTPS</code>等），以及对服务运行时进行高级控制，使服务变得可监控、可管理</p>
<p>从全局来看，在多个服务间有复杂的互相访问时才有服务治理的需求。即我们关注的是这些<code>Sidecar</code>组成的网格，对网格内的服务间访问进行管理，应用还是按照本来的方式进行互相访问，每个应用程序的<code>Inbound</code>流量和<code>Outbound</code>流量都要经过<code>Sidecar</code>代理，并在<code>Sidecar</code>上执行治理动作</p>
<p><code>Sidecar</code>是网格动作的执行体，全局的管理规则和网格内的元数据维护通过一个统一的控制面实现，只有数据面的<code>Sidecar</code>和控制面有联系，应用感知不到<code>Sidecar</code>，更不会和控制面有任何联系，用户的业务和控制面彻底解耦</p>
<h2 id="8-istio用在哪">8、Istio用在哪</h2>
<p><code>Istio</code>是一个服务治理平台，治理的是服务间的访问，只要有访问就可以治理，不在乎这个服务是不是 所谓的微服务，也不要求跑在其上的代码是微服务化的。单体应用即使不满足微服务的若干哲学，用<code>Istio</code>治理也是完全可以的</p>
<h2 id="9-istio做了什么">9、Istio做了什么</h2>
<p>以前后端分离的服务为例<br>
前端 服务的代码中通过域名访问 后端 服务，在两个服务中都不用包含任何服务访问管理的逻辑。<code>Istio</code>在其中都做了什么（可以做些什么）</p>
<ul>
<li>自动通过服务发现获取服务实例列表，并根据负载均衡策略选择一个服务实例</li>
<li>对服务双方启用双向认证和通道加密</li>
<li>如果某个服务实例连续访问出错，则可以将该实例隔离一段时间，以提高访问质量</li>
<li>设置最大连接数、最大请求数、访问超时等对服务进行保护</li>
<li>限流</li>
<li>对请求进行重试</li>
<li>修改请求中的内容</li>
<li>将一定特征的服务重定向</li>
<li>灰度发布</li>
<li>自动记录服务访问信息</li>
<li>记录调用链，进行分布式追踪</li>
<li>根据访问数据形成完整的应用访问拓扑</li>
<li>……</li>
</ul>
<p>所有这些功能，都不需要用户修改代码，用户只需在<code>Istio</code>的控制面配置即可，并且动态生效</p>
<p>对业务代码完全没有侵入性</p>
<h2 id="10-用什么姿势接入-istio">10、用什么姿势接入 Istio</h2>
<p>虽然<code>Istio</code>能解决那么多的问题，但是引入<code>Istio</code>并不是没有代价的。最大的问题是<code>Istio</code>的复杂性，强大的功能也意味着<code>Istio</code>的概念和组件非常多，要想理解和掌握<code>Istio</code>，并成功在生产环境中部署需要非常详细的规划。一般情况下，集群管理团队需要对<code>kubernetes</code>非常熟悉，了解常用的使用模式，然后采用逐步演进的方式把<code>Istio</code>的功能分批掌控下来</p>
<ul>
<li>
<p>第一步，自然是在测试环境搭建一套<code>Istio</code>的集群，理解所有的核心概念和组件。了解<code>Istio</code>提供的接口和资源，知道它们的用处，思考如何应用到自己的场景中，然后是熟悉<code>Istio</code>的源代码，跟进社区的<code>issues</code>，了解目前还存在的<code>issues</code>和<code>bug</code>，思考如何规避或者修复。这一步是基础，需要积累到<code>Istio</code>安装部署、核心概念、功能和缺陷相关的知识，为后面做好准备</p>
</li>
<li>
<p>第二步，可以考虑接入<code>Istio</code>的观察性功能，包括<code>logging</code>、<code>tracing</code>、<code>metrics</code>数据。应用部署到集群中，选择性地（一般是流量比较小，影响范围不大的应用）为一些应用开启<code>Istio</code>自动注入功能，接管应用的流量，并安装<code>prometheus</code>和<code>zipkin</code>等监控组件，收集系统所有的监控数据。这一步可以试探性地了解 <code>Istio</code>对应用的性能影响，同时建立服务的性能测试基准，发现服务的性能瓶颈，帮助快速定位应用可能出现的问题。此时，这些功能可以是对应用开发者透明的，只需要集群管理员感知，这样可以减少可能带来的风险</p>
</li>
<li>
<p>第三步，为应用配置<code>timeout</code>超时参数、自动重试、熔断和降级等功能，增加服务的容错性。这样可以避免某些应用错误进行这些配置导致问题的出现，这一步完成后需要通知所有的应用开发者删除掉在应用代码中对应的处理逻辑。这一步需要开发者和集群管理员同时参与</p>
</li>
<li>
<p>第四步，和<code>ingress</code>、<code>helm</code>、应用上架等相关组件和流程对接，使用<code>Istio</code>接管应用的升级发布流程。让开发者可以配置应用灰度发布升级的策略，支持应用的蓝绿发布、金丝雀发布以及<code>AB</code>测试</p>
</li>
<li>
<p>第五步，接入安全功能。配置应用的<code>TLS</code>互信，添加<code>RBAC</code>授权，设置应用的流量限制，提升整个集群的安全性。因为安全的问题配置比较繁琐，而且优先级一般会比功能性相关的特性要低，所以这里放在了最后</p>
</li>
</ul>
<p>当然这个步骤只是一个参考，需要根据自己的情况、人力、时间和节奏来调整，找到适合的方案</p>
<h2 id="11-istio不是银弹">11、Istio不是银弹</h2>
<p><code>Istio</code>的架构在数据中心和集群管理中非常常见，每个<code>agent</code>分布在各个节点上（可以是服务器、虚拟机、pod、容器）负责接收指令并执行，以及汇报信息；控制中心负责汇聚整个集群的信息，并提供<code>API</code>让用户对集群进行管理。<code>kubernetes</code>也是类似的架构，<code>SDN（Software Defined Network）</code>也是如此。相信以后会有更多类似架构的出现，这是因为数据中心要管理的节点越来越多，我们需要把任务执行分布到各节点（<code>agent</code>负责的功能），同时也需要对整个集群进行管理和控制（<code>control plane</code>的功能），完全去中心化的架构是无法满足后面这个要求的</p>
<p><code>Istio</code>的出现为负责的微服务架构减轻了很多的负担，开发者不用关心服务调用的超时、重试、<code>rate limit</code>的实现，服务之间的安全、授权也自动得到了保证；集群管理员也能够很方便地发布应用（AB 测试和灰度发布），并且能清楚看到整个集群的运行情况</p>
<p>但是这并不表明有了<code>Istio</code>就可以高枕无忧了，<code>Istio</code>只是把原来分散在应用内部的复杂性统一抽象出来放到了统一的地方，并没有让原来的复杂消失不见。因此我们需要维护<code>Istio</code>整个集群，而<code>Istio</code>的架构比较复杂，尤其是它一般还需要架在<code>kubernetes</code>之上，这两个系统都比较复杂，而且它们的稳定性和性能会影响到整个集群。因此再采用<code>Isito</code>之前，必须做好清楚的规划，权衡它带来的好处是否远大于额外维护它的花费，需要有相关的人才对整个网络、<code>kubernetes</code>和<code>Istio</code>都比较了解才行</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[服务网格和Istio初识]]></title>
        <id>https://www.ssgeek.com/post/fu-wu-wang-ge-he-istio-ru-men</id>
        <link href="https://www.ssgeek.com/post/fu-wu-wang-ge-he-istio-ru-men">
        </link>
        <updated>2022-01-12T16:12:23.000Z</updated>
        <content type="html"><![CDATA[<p><ul class="markdownIt-TOC">
<li>
<ul>
<li><a href="#1-%E4%BA%91%E5%8E%9F%E7%94%9F">1、云原生</a></li>
<li><a href="#2-%E5%BE%AE%E6%9C%8D%E5%8A%A1%E6%9E%B6%E6%9E%84">2、微服务架构</a></li>
<li><a href="#3-kubernetes">3、Kubernetes</a></li>
<li><a href="#4-%E6%9C%8D%E5%8A%A1%E7%BD%91%E6%A0%BC">4、服务网格</a></li>
<li><a href="#5-istio">5、Istio</a></li>
</ul>
</li>
</ul>
</p>
<h2 id="1-云原生">1、云原生</h2>
<p>云原生的定义：</p>
<ul>
<li>2010年，WSO2技术总监PaulFremantle 首次提出Cloud Native，他一直想用一个词表达一个架构，这种架构能够描述应用程序和中间件能够在云环境中有良好的运行状态。云原生有以下特性 分布式、弹性、多租户，子服务，按需计量和计费，增量部署和测试</li>
<li>2013年，Netflix云架构师，Adrian Cockcroft介绍了Netflix在AWS上基于Cloud Native的成功应用，Netflix在AWS上有上万个实例</li>
<li>2015年，来自Pivotal的Matt Stine，他的电子书《迁移到云原生应用架构》，他认为单体架构在向云原生架构的演进过程中，需要流程、文化、技术共同变革，该书把Cloud Native描述为一组最佳实践，具体包含如下内容：十二因子，微服务，敏捷基础设施，基于API的协作，反脆弱性</li>
<li>2017年，Matt Stine在接受媒体采访时又改了口风，将云原生架构归纳为模块化、可观察、可部署、可测试、可替换、可处理6特质；而Pivotal最新官网对云原生概括为4个要点：DevOps+持续交付+微服务+容器<br>
2015年云原生计算基金会（CNCF）成立，最初把云原生定义为包括：容器化封装+自动化管理+面向微服务。</li>
<li>CNCF于2018年通过了对云原生重新定义的提案，V1.0的定义如下：<br>
云原生技术有利于各组织在公有云、私有云和混合云等新型动态环境中，构建和运行可弹性扩展的应用。云原生的代表技术包括容器、服务网格、微服务、不可变基础设施和声明式API<br>
这些技术能够构建容错性好、易于管理和便于观察的松耦合系统。结合可靠的自动化手段，云原生技术使工程师能够轻松地对系统作出频繁和可预测的重大变更</li>
</ul>
<p>云原生的英文原文叫<code>Cloud Native</code>，从英文的角度来理解，<code>Native</code>表示与生俱来，就是亲生的，把<code>Cloud</code>和<code>Native</code>放到一起又该如何理解？详细的解释是：应用原生被设计为在云上以最佳方式运行，充分发挥云的优势，享受云的特点</p>
<p>云原生这个词看起来比较新鲜，其实从开发人员的角度来理解是很简单的，就是应用在开发的时候就考虑到云上提供的各种服务，充分利用云的动态调度、自恢复、通过<code>API</code>访问服务等基本特性，以及敏捷高效的特性。传统的应用开发方式都是闷头开发，不管应用跑在哪个基础设施环境中，也不用考虑基础设施提供的各种能力，让应用能正常运行就好</p>
<p>上面都是从广义上来理解云原生，有点空洞，对应到具体的方法论就是大家耳熟能详的三板斧</p>
<ul>
<li>容器化</li>
<li>微服务</li>
<li>DevOps</li>
</ul>
<figure data-type="image" tabindex="1"><img src="https://image.ssgeek.com/20220112-01.png" alt=""></figure>
<h2 id="2-微服务架构">2、微服务架构</h2>
<p>微服务或微服务架构是一种架构风格，它将一个应用程序构建为服务的集合。松散耦合的微服务集合提供了与单个单体应用相同的功能，但有额外的优势。微服务可以独立于其他服务进行开发和部署。它们是围绕业务能力组织的，由较小的团队拥有。它们在部署/开发中更小、更独立，可以更好地维护和测试</p>
<p>开发人员经常将云原生应用程序分解为多个执行特定动作的服务。例如，可能有一个只处理客户的服务和另一个处理订单或付款的服务。所有这些服务都通过网络相互沟通。如果一个新的付款需要被处理，请求会被发送到付款服务。如果客户数据需要更新，请求会被发送到客户服务等等</p>
<figure data-type="image" tabindex="2"><img src="https://image.ssgeek.com/20220112-02.png" alt=""></figure>
<p>这种类型的架构被称为微服务架构。这种架构有几个好处。可以有多个较小的团队从事个别服务。这些团队可以灵活地选择他们的技术栈和语言，并且通常有独立部署和发布服务的自主权。这种机制得以运作得益于其背后通信网络。随着服务数量的增加，它们之间的网络通信也在增加。服务和团队的数量使得监控和管理通信逻辑变得相当复杂。由于我们也知道网络是不可靠的，它们会失败，所有这些的结合使得微服务的管理和监控相当复杂</p>
<h2 id="3-kubernetes">3、Kubernetes</h2>
<p><code>Kubernetes</code>是现代基于容器的<code>DevOps</code>和微服务以及容器携手并进的黄金标准，其设计之初就是按照云原生的理念设计的</p>
<p><code>Kubernetes</code>是一款用于管理容器化工作负载和服务的可移植、可扩展的开源平台，拥有庞大、快速发展的生态系统，它面向基础设施，将计算、网络、存储等资源进行紧密整合，为容器提供最佳运行环 境，并面向应用提供封装好的、易用的工作负载与服务编排接口，以及运维所需的资源规格、弹性、运行参数、调度等配置管理接口，是新一代的云原生基础设施平台。 从平台架构而言，<code>Kubernetes</code>的设计围绕平台化理念，强调插件化设计与易扩展性，这是它与其他同类系统的最大区别之一，保障了对各种不同客户应用场景的普遍适应性。另外，<code>Kubernetes</code>与其他容器编排系统的显著区别是<code>Kubernetes</code>并不把无状态化、微服务化等条件作为在其上可运行的工作负载的约束</p>
<p>随着互联网的发展，后端服务和容器编排技术的日益成熟，微服务成为了后端服务的首选，<code>Kubernetes</code>也已成为目前容器编排的事实标准</p>
<h2 id="4-服务网格">4、服务网格</h2>
<p>服务网格被定义为一个专门的基础设施层，用于管理服务与服务之间的通信，使其可管理、可见、可控制。在某些版本的定义中，可能还会听到服务网格如何使服务间的通信安全和可靠。用一个更直接的句子来描述服务网格：服务网格是关于服务之间的通信</p>
<p>但是，服务网格是如何帮助通信的呢？让我们思考一下通信逻辑和它通常所在的地方。在大多数情况下，开发人员将这种逻辑作为服务的一部分来构建。通信逻辑是处理入站或出站请求的任何代码，重试逻辑，超时，甚至可能是流量路由。因此，无论何时服务<code>A</code>调用服务<code>B</code>，请求都要经过这个通信代码逻辑，这个逻辑决定如何处理这个请求</p>
<p>如果我们采用微服务的方法，最终可能会有大量的服务。我们如何处理所有这些服务的通信逻辑呢？我们可以创建一个包含这种逻辑的共享库，并在多个地方重用它。假设我们对所有的服务都使用相同的堆栈或编程语言，共享库的方法可能会很有效。如果我们不这样做，我们将不得不重新实现这个库，这会带来巨大的工作量而且效率低下。你也可能使用自己本身不拥有代码库的服务。在这种情况下，我们无法控制通信逻辑或监控</p>
<p>另外一个问题是配置。除了配置你的应用程序外，我们还必须维护通信逻辑配置。如果我们需要同时调整或更新多个服务，我们将不得不为每个服务单独进行调整</p>
<p>服务网格所做的是，它将这种通信逻辑、重试、超时等从单个服务中分离出来，并将其移到一个单独的基础设施层。在服务网格的情况下，基础设施层是一个网络代理的阵列。这些网络代理的集合（每个服务实例旁边都有一个）处理你的服务之间的所有通信逻辑。我们称这些代理为<code>sidecar</code>，因为它们与每个服务并存</p>
<figure data-type="image" tabindex="3"><img src="https://image.ssgeek.com/20220112-03.png" alt=""></figure>
<p>我们让<code>Customer</code>服务直接与<code>Payment</code>服务通信，现在我们有一个<code>Customer</code>服务旁边的代理与<code>Payment</code>服务旁边的代理通信。服务网格控制平面以这样一种方式配置代理，即它们透明地拦截所有入站和出站请求。这些代理的集合（基础设施层）形成了一个网络网格，称为服务网格</p>
<p>将通信逻辑从业务和应用逻辑中分离出来，可以使开发人员专注于业务逻辑，而服务网格运维人员则专注于服务网格配置</p>
<p>因此，用到服务网格<code>sidecar</code>模式后，应用的拓扑可能是这样</p>
<figure data-type="image" tabindex="4"><img src="https://image.ssgeek.com/20220112-04.png" alt=""></figure>
<p>服务网格为我们提供了一种一致的方式来连接、保护和观察微服务。网格内的代理捕获了网格内所有通信的请求和指标。每一次失败、每一次成功的调用、重试或超时都可以被捕获、可视化，并发出警报。此外，可以根据请求属性做出决定。例如，我们可以检查入站（或出站）请求并编写规则，将所有具有特定头值的请求路由到不同的服务版本</p>
<h2 id="5-istio">5、Istio</h2>
<p><code>Istio</code>是服务网格技术云原生<code>Cloud Native</code>时代的产物，是云原生应用的新型架构模式，而云原生又是云计算产业发展的新制高点</p>
<p><code>2016</code>年，<code>Google</code>决定开发一个对微服务进行管理的开源项目，它与<code>Google</code>内部使用的平台有很大的相似性，该项目被命名为<code>Istio</code>,<code>Istio</code>在希腊语中的意思是“启航”。就在<code>Google</code>启动<code>Istio</code>项目的几乎同一时间，<code>IBM</code>也发布了一个名为<code>Amalgam8</code>的开源项目，这是一个基于<code>Nginx</code>代理技术，为微服务提供基于内容路由方案的项目。随后，<code>Google</code>和<code>IBM</code>意识到这两个项目在使用场景与产品愿景上存在很大一部分交集，于是答应成为合作伙伴，<code>IBM</code>放弃<code>Amalgam8</code>的开发，与<code>Google</code>共同基于<code>Lyft</code>公司开源的<code>envoy</code>项目打造<code>Istio</code>这款产品</p>
<p><code>Istio</code>是一个与<code>Kubernetes</code>紧密结合的适用于云原生场景的<code>Service Mesh</code>形态的用于服务治理的开放平台</p>
<p><code>Istio</code>与<code>Kubernetes</code>的关系如下</p>
<figure data-type="image" tabindex="5"><img src="https://image.ssgeek.com/20220112-05.png" alt=""></figure>
<p><code>Istio</code>的出现将服务网格的概念发扬光大，它创新性地将服务网格从逻辑上划分为“数据面板”和“控制面板</p>
<ul>
<li>随着分布式应用一起部署的<code>sidecar</code>成为数据平面，它能够拦截网络请求并控制服务之间的通信</li>
<li>而集中式的管理模块成为控制平面，它提供服务发现、流量管理、遥测数据收集以及证书轮换等功能</li>
</ul>
<p>在整个网络里面，所有的流量都在<code>sidecar</code>代理的控制当中，所有的<code>sidecar</code>代理都在控制面板控制当中，因此，可以通过控制面板控制整个服务网格，这是<code>Istio</code>带来的最大革新</p>
<figure data-type="image" tabindex="6"><img src="https://image.ssgeek.com/20220112-06.png" alt=""></figure>
<p><code>Istio</code>提供一种简单的方式来为已部署的服务建立网络，该网络具有负载均衡、服务间认证、监控等功能，只需要对服务的代码进行一点或不需要做任何改动，让服务支持<code>Istio</code>，只需要在环境中部署一个特殊的<code>sidecar</code>代理，使用<code>Istio</code>控制平面功能配置和管理代理，拦截微服务之间的所有网络通信</p>
<ul>
<li>HTTP、gRPC、WebSocket 和 TCP 流量的自动负载均衡</li>
<li>通过丰富的路由规则、重试、故障转移和故障注入，可以对流量行为进行细粒度控制</li>
<li>可插入的策略层和配置 API，支持访问控制、速率限制和配额</li>
<li>对出入集群入口和出口中所有流量的自动度量指标、日志记录和追踪</li>
<li>通过强大的基于身份的验证和授权，在集群中实现安全的服务间通信</li>
</ul>
<p>本文就写（参考）到这里，后面围绕<code>Istio</code>做更多学习、实践的分享</p>
<p>See you ~</p>
<blockquote>
<p>参考</p>
<p>https://istio.io/latest/zh/docs/concepts/what-is-istio/</p>
<p>https://www.infoq.cn/article/fA42rfjV*dYGAvRANFqE</p>
<p>https://mp.weixin.qq.com/s/csY8T02Ck8bnE3vVcZxVjQ</p>
</blockquote>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[2021总结与公众号文章回顾]]></title>
        <id>https://www.ssgeek.com/post/2021-zong-jie-yu-gong-zhong-hao-wen-zhang-hui-gu</id>
        <link href="https://www.ssgeek.com/post/2021-zong-jie-yu-gong-zhong-hao-wen-zhang-hui-gu">
        </link>
        <updated>2021-12-31T16:14:44.000Z</updated>
        <content type="html"><![CDATA[<figure data-type="image" tabindex="1"><img src="https://image.ssgeek.com/20220101-03.png" alt=""></figure>
<h2 id="1-年度总结">1、年度总结</h2>
<p>时间一转眼就到了2021年最后一天，以2021最后一个工作周的周五结束，是的2021年就这样过去了</p>
<p>2021年是来北京的第3个年头，也是本科毕业的第2年</p>
<p>在这一年年末，完成了北漂两件（大）事：换工作、换房</p>
<h3 id="工作">工作</h3>
<p>如封面图，现在的工作地点在五道口</p>
<p>有时候我会觉得我是一个念旧的人，对于人生旅途上的人和事总会有那些美好让你难以释怀</p>
<p>因此换工作对我来说是一件艰难的事情</p>
<p>但转而一想，从初中开始，我们所处的环境、我们身边的人每过3年、4年就会换一拨</p>
<p>所以工作其实也是一样罢了，只要我们时常想起的时候总是充满美好就可以了</p>
<p>换工作对于职业发展、技术路线、公司发展等多方面也进行了多方取舍，最终选择了现在的公司</p>
<h3 id="学习">学习</h3>
<p>这一年也在Todo中定下了不少学习计划，具体这里就不列出了</p>
<p>部分计划的成果以博客/公众号文章的形式进行了输出，公众号原创的确是一件不容易的事情，上半年坚持周更三篇，下半年就只能周更两篇了，明年再接再厉</p>
<p>当然，在计划充分饱满的前提下，应该没有人能说把年初计划完美的完成了</p>
<p>计划赶不上变化，人生总会有遗憾 ~</p>
<h3 id="生活">生活</h3>
<p>从实习来到北京，就一直住在被冠以“老破小”称号的六七十年代筒子楼</p>
<p>搬家或许对于多数人来说都是一件很艰难的事情</p>
<p>为了减少通勤时间，改善改善居住环境</p>
<p>终于在最近一个周末狠下了心，连续完成了看房、搬家</p>
<p>下面就是以后经常战斗的小窝啦 ~</p>
<figure data-type="image" tabindex="2"><img src="https://image.ssgeek.com/20220101-02.png" alt=""></figure>
<h3 id="骑行">骑行</h3>
<p>这一年由于在前司找到了完美的停车位，感谢领导让我的小小爱好得以坚持</p>
<p>由于工作以及个人时间安排经常和俱乐部时间冲突，所以这一年去俱乐部一起参加活动的时间也就少了</p>
<p>更多骑行的时间还是在通勤以及和朋友休闲骑</p>
<p>希望新的一年到来后能继续并有所突破</p>
<figure data-type="image" tabindex="3"><img src="https://image.ssgeek.com/20220101-01.png" alt=""></figure>
<h2 id="2-公众号文章回顾">2、公众号文章回顾</h2>
<p>这一年开始在写博客的同时发表到了公众号，除去转载的部分好文，剩下的原创文章和学习笔记按照领域分类，或按时间先后、阅读量排序整理如下，方便大家继续点击直达</p>
<h3 id="云原生-kubernetes-容器相关">云原生、Kubernetes、容器相关</h3>
<p><a href="http://mp.weixin.qq.com/s?__biz=MzkxNzAzNDA3Ng==&amp;mid=2247485062&amp;idx=1&amp;sn=7d751b21c7b3380e1c443dde2942e9a2&amp;chksm=c14783b5f6300aa32c1822a419bfeca9f55b1b9b2efc8e7667f71bcd7e9808f391aeabe071a2#rd">k8s生产实践之获取客户端真实IP</a></p>
<p><a href="http://mp.weixin.qq.com/s?__biz=MzkxNzAzNDA3Ng==&amp;mid=2247486148&amp;idx=1&amp;sn=dcf97946659a08f6e6c8d3f61c9a79c1&amp;chksm=c1478ff7f63006e18128340348cb501d5dd16978bc354b3e72d373e7386d7bddc84ebf6ccc02#rd">基于ack k8s集群调度的方案设计</a></p>
<p><a href="http://mp.weixin.qq.com/s?__biz=MzkxNzAzNDA3Ng==&amp;mid=2247484919&amp;idx=1&amp;sn=443693984b2dc9fe857f6f3248034e86&amp;chksm=c14780c4f63009d272151b3af19f62916e9040c9e751ce5c21f268a0b9aaf09ecdd08abab6d7#rd">Dockerfile语法概要</a></p>
<p><a href="http://mp.weixin.qq.com/s?__biz=MzkxNzAzNDA3Ng==&amp;mid=2247485679&amp;idx=1&amp;sn=1172cd2c386058ab365d1429af727a9e&amp;chksm=c1478ddcf63004cade1312dd70e660e3be50842387b7d36ee3c3898b90bf28f0e0a42c662bb8#rd">k8s环境下处理容器时间问题的多种姿势</a></p>
<p><a href="http://mp.weixin.qq.com/s?__biz=MzkxNzAzNDA3Ng==&amp;mid=2247484589&amp;idx=1&amp;sn=d0c4d6ad8860cf19d69fb71aea29f112&amp;chksm=c147819ef63008884b835f52d91af4ec64534ee8c5528ab6da7d84d52d46713ff04d0f754cae#rd">SkyWalking链路追踪系统-部署篇</a></p>
<p><a href="http://mp.weixin.qq.com/s?__biz=MzkxNzAzNDA3Ng==&amp;mid=2247484641&amp;idx=1&amp;sn=201eccd78ee681fdbe45f1c372e9abcc&amp;chksm=c14781d2f63008c4b8bb9d30cd12c1e483771ec5ccfca1d78dba3b213ffbf610973e1bd738e1#rd">SkyWalking链路追踪系统-接入篇</a></p>
<p><a href="http://mp.weixin.qq.com/s?__biz=MzkxNzAzNDA3Ng==&amp;mid=2247484682&amp;idx=1&amp;sn=df8ee7180314c1f21435e845d817ac25&amp;chksm=c1478039f630092f10dfc756aa70512d1f300199734148aa72df405527df35793e3413b83e54#rd">SkyWalking链路追踪系统-告警篇</a></p>
<p><a href="http://mp.weixin.qq.com/s?__biz=MzkxNzAzNDA3Ng==&amp;mid=2247485577&amp;idx=1&amp;sn=295216d1196b88ecae65abb1bca094e7&amp;chksm=c1478dbaf63004ac6b4a4926766545725ed0a19bb11bcc5cdcc3ee2ec727c3ac28a7050caa83#rd">浅谈Prometheus的数据存储</a></p>
<p><a href="http://mp.weixin.qq.com/s?__biz=MzkxNzAzNDA3Ng==&amp;mid=2247484339&amp;idx=1&amp;sn=0c2e848ea27ba9b8e98cf3f5df504deb&amp;chksm=c1478680f6300f9674b8b359db89ba4b7db161f84f3501ce849300d9a9fc6cb3ac80ffb35f1e#rd">使用kube-prometheus部署k8s监控(最新版)</a></p>
<p><a href="http://mp.weixin.qq.com/s?__biz=MzkxNzAzNDA3Ng==&amp;mid=2247484976&amp;idx=1&amp;sn=538491aed942ad44c1beb109afb8569f&amp;chksm=c1478303f6300a15dfb55822cae2d53d32a9043c178685d5bc222c2cc8d5f87f61699bcaed41#rd">基于k8s集群部署Nexus与旧数据的迁移</a></p>
<p><a href="http://mp.weixin.qq.com/s?__biz=MzkxNzAzNDA3Ng==&amp;mid=2247486090&amp;idx=1&amp;sn=dfdaf970062f188a363c25f040f7fcfd&amp;chksm=c1478fb9f63006af4faae0df7e274419222c20c2b049abab7bc153c82dd714fb3eca95c11180#rd">基于Dockerfile构建容器镜像的最佳实践</a></p>
<p><a href="http://mp.weixin.qq.com/s?__biz=MzkxNzAzNDA3Ng==&amp;mid=2247484200&amp;idx=1&amp;sn=9917913be9e70d236980238574bdf2d8&amp;chksm=c147861bf6300f0dcff1e0d43e5d6d728d61267a33618f95d67fb3550af610a2753016f1f16d#rd">两大grafana实用插件快速监控kubernetes</a></p>
<p><a href="http://mp.weixin.qq.com/s?__biz=MzkxNzAzNDA3Ng==&amp;mid=2247485927&amp;idx=1&amp;sn=51df3b19c1eba86b0c579ae9859172c8&amp;chksm=c1478cd4f63005c233a3bfcbc2baab9693c5443fd810bbdb2afacdfb78577686b51dc9c786f1#rd">Helm Chart语法概要 </a></p>
<p><a href="http://mp.weixin.qq.com/s?__biz=MzkxNzAzNDA3Ng==&amp;mid=2247483979&amp;idx=1&amp;sn=7191ef5094026b40b8bbcbb27efa9a53&amp;chksm=c1478778f6300e6e42ad2e4a690889cf814e215c0bbe583f2e36d96767c83a2abe3174d1d70c#rd">k8s内网和办公网络的打通实践</a></p>
<p><a href="http://mp.weixin.qq.com/s?__biz=MzkxNzAzNDA3Ng==&amp;mid=2247484276&amp;idx=1&amp;sn=b75de92fca5fabea821f898522bb520d&amp;chksm=c1478647f6300f51b5b7353b5b805172b2b81cd2880920ed066450dc8ddfb945a2f5b83580ce#rd">基于k8s手动部署rabbitmq集群</a></p>
<p><a href="http://mp.weixin.qq.com/s?__biz=MzkxNzAzNDA3Ng==&amp;mid=2247486165&amp;idx=1&amp;sn=77e3a4c387b2b8fab703f363c3b1d066&amp;chksm=c1478fe6f63006f0eee5fd9bd6eceb62ca7cfa25b3c5ff177cfdb28a55b30c62b40ef36731d8#rd">任务执行龟速，原因竟然是......</a></p>
<p><a href="http://mp.weixin.qq.com/s?__biz=MzkxNzAzNDA3Ng==&amp;mid=2247484680&amp;idx=1&amp;sn=059c46572a30daeae174dbbeda766cc9&amp;chksm=c147803bf630092d846cd2e568db58426676a4301c7d007b3897ab9e76fd90f3f6ae8e2d6919#rd">在k8s中解决pod资源的正确识别</a></p>
<p><a href="http://mp.weixin.qq.com/s?__biz=MzkxNzAzNDA3Ng==&amp;mid=2247484131&amp;idx=1&amp;sn=96c45bd0f5ff434feb686a457ee7d9f1&amp;chksm=c14787d0f6300ec61a564ef213ad044e686a0666f02f9f9a250b3ecd4bec4fdbf8549b681bc5#rd">k8s之Ingress自动化https</a></p>
<p><a href="http://mp.weixin.qq.com/s?__biz=MzkxNzAzNDA3Ng==&amp;mid=2247483790&amp;idx=1&amp;sn=c397d4bf5bce3889907d2b26fd33d436&amp;chksm=c14784bdf6300dabbfc13b2917ef27b1183d5c81c75a1fbc148f163c00e0efd74b52bbfc3951#rd">k8s Ingress nginx错误页面的深度定制</a></p>
<p><a href="http://mp.weixin.qq.com/s?__biz=MzkxNzAzNDA3Ng==&amp;mid=2247484161&amp;idx=1&amp;sn=56e724442e5344735f817deb71779bf7&amp;chksm=c1478632f6300f24cb37c404a522706dbf9c9056229a86893502dba52856a72e22ef923aa831#rd">基于k8s Ingress Nginx+OAuth2+Gitlab无代码侵入实现自定义服务的外部验证</a></p>
<p><a href="http://mp.weixin.qq.com/s?__biz=MzkxNzAzNDA3Ng==&amp;mid=2247484396&amp;idx=1&amp;sn=ae3d8a38ce0f620a8b12644b7d9d0a81&amp;chksm=c14786dff6300fc9cf005e2777cc29d6f1009a4e3753741bfc61297b82cdac68c8f37c1ca035#rd">使用flannel+canal实现k8s的NetworkPolicy</a></p>
<p><a href="http://mp.weixin.qq.com/s?__biz=MzkxNzAzNDA3Ng==&amp;mid=2247484446&amp;idx=1&amp;sn=72a72501a4505850bbdc08fe3bca8a10&amp;chksm=c147812df630083b3b7a090ec1eebe2eeee42c219ca59325a55ee732ae9357cf62633ca17b09#rd">kubernetes存储之GlusterFS</a></p>
<p><a href="http://mp.weixin.qq.com/s?__biz=MzkxNzAzNDA3Ng==&amp;mid=2247486242&amp;idx=1&amp;sn=22a7a21a3b95eb02911f17e860556b7c&amp;chksm=c1478e11f6300707e4341202f8cb1ce3ca125d321f73dcca2b94997de67007d700e916a12b9b#rd">ack集群Terway网络场景下的vSwitch扩容</a></p>
<h3 id="devops-jenkins相关">DevOps、Jenkins相关</h3>
<p><a href="http://mp.weixin.qq.com/s?__biz=MzkxNzAzNDA3Ng==&amp;mid=2247484542&amp;idx=1&amp;sn=9913acdc1487af0f82b24acadc4346f6&amp;chksm=c147814df630085b19309d408c1789b6df2d200b5faa05419f5170466cef40e4a644db752d23#rd">DevOps建设之基于钉钉OA审批流的自动化上线</a></p>
<p><a href="http://mp.weixin.qq.com/s?__biz=MzkxNzAzNDA3Ng==&amp;mid=2247484622&amp;idx=1&amp;sn=ef9bdc890fafdd3a079a666d0cbaf96f&amp;chksm=c14781fdf63008eb48301a2d5e85d03b4040bcdcaf5baf99353f35c8d318eebf54c202e65a21#rd">Jenkins API+Pipeline深度实践之input的自动化</a></p>
<p><a href="http://mp.weixin.qq.com/s?__biz=MzkxNzAzNDA3Ng==&amp;mid=2247484257&amp;idx=1&amp;sn=f045a7d853788d929cde64598a0506b9&amp;chksm=c1478652f6300f4432ae9d16a0e791b9d13dfd8114b8cba9418601bfb3e0f4c513e7d266c196#rd">JenkinsPipeline语法概要</a></p>
<p><a href="http://mp.weixin.qq.com/s?__biz=MzkxNzAzNDA3Ng==&amp;mid=2247485525&amp;idx=1&amp;sn=6ba00bde1bbe9de20d47949298034ab1&amp;chksm=c1478d66f630047037327621c410b79fda27234818b7405186149746ef478b8e1e28abb1b92b#rd">Jenkins连接k8s的多种姿势</a></p>
<p><a href="http://mp.weixin.qq.com/s?__biz=MzkxNzAzNDA3Ng==&amp;mid=2247484159&amp;idx=1&amp;sn=7e77064d3ab78c29fb425a807ae00301&amp;chksm=c14787ccf6300edaea534e21bdde7b9618956f28fe70faf5857814d1b0998f759d2d9d7644a5#rd">Jenkins workflowLibs库的使(妙)用</a></p>
<p><a href="http://mp.weixin.qq.com/s?__biz=MzkxNzAzNDA3Ng==&amp;mid=2247483946&amp;idx=1&amp;sn=c7ce84dcb7986bc982e06843720dde1b&amp;chksm=c1478719f6300e0fa6fbe7dec5e2f26903c28de668459fdff7a9e5cc87d504ec2fd2c459076b#rd">Jenkins ShareLibrary实践之自定义通知器</a></p>
<p><a href="http://mp.weixin.qq.com/s?__biz=MzkxNzAzNDA3Ng==&amp;mid=2247485043&amp;idx=1&amp;sn=06ffc7f908282566adc61997230fe6d5&amp;chksm=c1478340f6300a562a798395f247d9c449c3dd5933986aa8418edb4ffac39faf6062eaab3fea#rd">使用Jenkins Operator在k8s中部署Jenkins</a></p>
<p><a href="http://mp.weixin.qq.com/s?__biz=MzkxNzAzNDA3Ng==&amp;mid=2247485440&amp;idx=1&amp;sn=582d3ccf4c792673b21f6c9ee0e3ea16&amp;chksm=c1478d33f6300425ca98cc39a5635770a6b6f6f761d94214a009bcdbac3019aa3b9db26b6556#rd">利用Github Action实现Github到Gitee的持续同步</a></p>
<p><a href="http://mp.weixin.qq.com/s?__biz=MzkxNzAzNDA3Ng==&amp;mid=2247485893&amp;idx=1&amp;sn=4cc54576548aa36c2d7368dc1cffd7f7&amp;chksm=c1478cf6f63005e099581220d6918f21f295e42fa0e620a4d6f76b55061a214aa765ae0a4d1c#rd">Azure DevOps的使用入门</a></p>
<h3 id="python">Python</h3>
<p><a href="http://mp.weixin.qq.com/s?__biz=MzkxNzAzNDA3Ng==&amp;mid=2247484359&amp;idx=1&amp;sn=8f57dee9db3bc3c5d3689834e42344eb&amp;chksm=c14786f4f6300fe2ff8435ffa74bb6205d8dac2590ca6e8b7baa4d02aaa75200787d6eb8457c#rd">Celery在Django中的简单应用</a></p>
<p><a href="http://mp.weixin.qq.com/s?__biz=MzkxNzAzNDA3Ng==&amp;mid=2247484816&amp;idx=1&amp;sn=29e1079e32c1c3a087f31a89b90d701e&amp;chksm=c14780a3f63009b5d613ee7081cc9ca437a783db517d7a930e9d61c453ab60552be714c9cadf#rd">drf的接口文档生成与管理</a></p>
<p><a href="http://mp.weixin.qq.com/s?__biz=MzkxNzAzNDA3Ng==&amp;mid=2247484985&amp;idx=1&amp;sn=7e71be3a4557a9341592b7ed688dd8b8&amp;chksm=c147830af6300a1cb85f7b0b0ec9ff09ab35e456a99d6a8bed298c1fb3f791f454a273d3b7cb#rd">浅谈Python鸭子类型</a></p>
<p><a href="http://mp.weixin.qq.com/s?__biz=MzkxNzAzNDA3Ng==&amp;mid=2247484603&amp;idx=1&amp;sn=7798e00ed1ad2eb4e250605e235d910c&amp;chksm=c1478188f630089e4465712d0b21644499dd7322dbe48741a8d861bb8d05e00095575c354e65#rd">drf分页器的使用</a></p>
<p><a href="http://mp.weixin.qq.com/s?__biz=MzkxNzAzNDA3Ng==&amp;mid=2247485794&amp;idx=1&amp;sn=adff09a613039e0bdc187fef4c8fa7eb&amp;chksm=c1478c51f63005474e6c76a39c92bb333e1470e269a383bb57fbc1440ecb139f5c5d58256b13#rd">基于Python实现原生的登录验证码</a></p>
<p><a href="http://mp.weixin.qq.com/s?__biz=MzkxNzAzNDA3Ng==&amp;mid=2247484035&amp;idx=1&amp;sn=125a7afe8d651f0ecf628d0e2b487f7c&amp;chksm=c14787b0f6300ea6342a94e008a3097a1c9491ff43a446cacf1bc7e6a74639745141291c831e#rd">Python分析Nginx日志</a></p>
<p><a href="http://mp.weixin.qq.com/s?__biz=MzkxNzAzNDA3Ng==&amp;mid=2247485092&amp;idx=1&amp;sn=bd3644e0c7365c2305198d12be02eeb2&amp;chksm=c1478397f6300a81bc2e248524286cfcd39830be4a0315a7edf6870163b7b3d202fb0054c644#rd">Django分页器的用法</a></p>
<p><a href="http://mp.weixin.qq.com/s?__biz=MzkxNzAzNDA3Ng==&amp;mid=2247485105&amp;idx=1&amp;sn=0a4bb00d5fbd256fa6dab5ced3f7e781&amp;chksm=c1478382f6300a94e0a8138e0d24b93403e62fe92d29fcf23a43b299fbf58a60e84599128a04#rd">Django自定义实现分页器</a></p>
<p><a href="http://mp.weixin.qq.com/s?__biz=MzkxNzAzNDA3Ng==&amp;mid=2247484227&amp;idx=1&amp;sn=64d8946f2fa45d773e0290c1af1a32a4&amp;chksm=c1478670f6300f66b0afd3b7420554c2cddc57cb25eb9ebceffab93fb8193c811f13fb093e60#rd">vue+drf+第三方滑动验证码的接入实现</a></p>
<p><a href="http://mp.weixin.qq.com/s?__biz=MzkxNzAzNDA3Ng==&amp;mid=2247484315&amp;idx=1&amp;sn=49dd46595542a17653f3d0925cf793ef&amp;chksm=c14786a8f6300fbe1d03b155fe1e7edeafe6d9446e41326fe78873af980f73ec773d89a8b9fe#rd">数据分析之Numpy入门</a></p>
<p><a href="http://mp.weixin.qq.com/s?__biz=MzkxNzAzNDA3Ng==&amp;mid=2247483903&amp;idx=1&amp;sn=e42f762df5e920813736b5dd0af64d22&amp;chksm=c14784ccf6300ddac40e93fcc2421e5165449706a6bd9e7886ccd37f4b15f178d88bac36a4b5#rd">剖析和解决Python中网络粘包的正确姿势</a></p>
<p><a href="http://mp.weixin.qq.com/s?__biz=MzkxNzAzNDA3Ng==&amp;mid=2247484105&amp;idx=1&amp;sn=0fb8940e5b6c67100a8598fab85cdc3f&amp;chksm=c14787faf6300eec2dda1fb346a47c28e4bae9da39301d21c4aa9f8efbd7718629ddf7bc8bb3#rd">drf序列化器之反序列化的数据验证</a></p>
<p><a href="http://mp.weixin.qq.com/s?__biz=MzkxNzAzNDA3Ng==&amp;mid=2247484182&amp;idx=1&amp;sn=79bfc700c56650f4ef0da06433fe31e5&amp;chksm=c1478625f6300f33186cd09631c9919c1d07b8f4094835d42849cb4c9d9a342c117cb3ace18f#rd">Django之URL反向解析</a></p>
<h3 id="golang">Golang</h3>
<p><a href="http://mp.weixin.qq.com/s?__biz=MzkxNzAzNDA3Ng==&amp;mid=2247485172&amp;idx=1&amp;sn=1d22b06a23aebbbff489ba9280b41064&amp;chksm=c14783c7f6300ad1b53abb72d206cd95e05b6b7c36c75b70cdae9a1c5adbe715f3d547de9078#rd">浅谈GoPath和Go Modules包管理</a></p>
<p><a href="http://mp.weixin.qq.com/s?__biz=MzkxNzAzNDA3Ng==&amp;mid=2247485285&amp;idx=1&amp;sn=904482e5d4df182352679869451fdcad&amp;chksm=c1478256f6300b401d62ffded83e68aebd8d27e414d8df1b9c6b9797dc7c3fd71b39a6cb4904#rd">Golang格式化输出</a></p>
<p><a href="http://mp.weixin.qq.com/s?__biz=MzkxNzAzNDA3Ng==&amp;mid=2247485307&amp;idx=1&amp;sn=f3c11e71df00fd81f65a0d4de2c53ebd&amp;chksm=c1478248f6300b5ecb3de72cda3f5e0ffa7aa6c7f928b833c56cf8da62817c3fa7eaf390de2f#rd">Golang数据类型之数组</a></p>
<p><a href="http://mp.weixin.qq.com/s?__biz=MzkxNzAzNDA3Ng==&amp;mid=2247485336&amp;idx=1&amp;sn=0864f1872bd11bdb580ff0e6f9798372&amp;chksm=c14782abf6300bbd5e40bcbf87fe5e21d01de8c9303e54ec92147beee8039ebca02d950f2cb8#rd">Golang数据类型之切片</a></p>
<p><a href="http://mp.weixin.qq.com/s?__biz=MzkxNzAzNDA3Ng==&amp;mid=2247485420&amp;idx=1&amp;sn=ec2065a55399d2baefe364cd3b5ff4e1&amp;chksm=c14782dff6300bc98ef5b333f9fb405316821b9511fad249de29ce98184e19fdbaf949956f9d#rd">浅谈float浮点型的底层存储与运算</a></p>
<p><a href="http://mp.weixin.qq.com/s?__biz=MzkxNzAzNDA3Ng==&amp;mid=2247485456&amp;idx=1&amp;sn=1b8bbb62b04d65d647fbb96be86ca4ed&amp;chksm=c1478d23f6300435b835e834c6ce13484e2a12c2de328df17de93d06f59d6c97c4cd0da42313#rd">Golang数据类型之Map</a></p>
<p><a href="http://mp.weixin.qq.com/s?__biz=MzkxNzAzNDA3Ng==&amp;mid=2247485465&amp;idx=1&amp;sn=754f42d74c7322d782d7720cca5b0d89&amp;chksm=c1478d2af630043c60d200cc268916f5f091e2f9c9b2726f01117d8d803cb3dbe005661efd9e#rd">Golang函数参数的值传递和引用传递</a></p>
<p><a href="http://mp.weixin.qq.com/s?__biz=MzkxNzAzNDA3Ng==&amp;mid=2247485477&amp;idx=1&amp;sn=2ce6d3b5ff8200b0bf994aa62cf8212c&amp;chksm=c1478d16f63004001abfd36ef530a3f01387195e634bbb08093b58b9a8c87f51131278e4460a#rd">Golang结构体类型的深浅拷贝</a></p>
<p><a href="http://mp.weixin.qq.com/s?__biz=MzkxNzAzNDA3Ng==&amp;mid=2247485505&amp;idx=1&amp;sn=210cb61e6621fb569be29d968c0abced&amp;chksm=c1478d72f6300464f301aab305a5fefd35c7bb6d52b73a9846379f400d56ed9454cc68ce0ed9#rd">Golang数据类型之指针</a></p>
<p><a href="http://mp.weixin.qq.com/s?__biz=MzkxNzAzNDA3Ng==&amp;mid=2247485555&amp;idx=1&amp;sn=1bf1e39f053f3736833f8cf942244a76&amp;chksm=c1478d40f630045625996a9a3e1f93caf38a53d6964620e2c8fc7f2d919afac47bd9f2136fdd#rd">Golang单元测试</a></p>
<p><a href="http://mp.weixin.qq.com/s?__biz=MzkxNzAzNDA3Ng==&amp;mid=2247485595&amp;idx=1&amp;sn=9981e6103a6b33cc3a06be0781a2bf10&amp;chksm=c1478da8f63004be44a8c84941280f3888d4e5a2120a4288ed1a21f8a1a82fe65d719c31bae6#rd">Golang基准测试</a></p>
<p><a href="http://mp.weixin.qq.com/s?__biz=MzkxNzAzNDA3Ng==&amp;mid=2247485625&amp;idx=1&amp;sn=c05b5293ce7b327ddc9d8c85f957f10a&amp;chksm=c1478d8af630049c7b51a5c7cc3076f661d0059257accdbf21510439cca7e7a9fe6447d94822#rd">Golang数据类型之结构体-上篇</a></p>
<p><a href="http://mp.weixin.qq.com/s?__biz=MzkxNzAzNDA3Ng==&amp;mid=2247485652&amp;idx=1&amp;sn=9c35ae5aea09f961c57c41d908d1ad8d&amp;chksm=c1478de7f63004f15d51ea599a3847e3a7cf674a8f73d2fd4b7cd536af5b4e20297326b83bdf#rd">Golang数据类型之结构体-下篇</a></p>
<p><a href="http://mp.weixin.qq.com/s?__biz=MzkxNzAzNDA3Ng==&amp;mid=2247485722&amp;idx=1&amp;sn=55bd2a8ecce44d87273a7a50c85baad0&amp;chksm=c1478c29f630053f8c99078f8af318a81390754367b13c063e9998e76b56b875a4b2f741e4c7#rd">Golang文件操作-上篇</a></p>
<p><a href="http://mp.weixin.qq.com/s?__biz=MzkxNzAzNDA3Ng==&amp;mid=2247485736&amp;idx=1&amp;sn=4c68adc053985ba303d21c04c473fd5d&amp;chksm=c1478c1bf630050d55b3d5bc25c54b42f324f4a3529cdd26085799f63936b63be3e3201a2c10#rd">Golang文件操作-下篇</a></p>
<p><a href="http://mp.weixin.qq.com/s?__biz=MzkxNzAzNDA3Ng==&amp;mid=2247485777&amp;idx=1&amp;sn=effb4f3ee2568f240f9a68d987f51b58&amp;chksm=c1478c62f6300574ccbef49b3eece7992a2113c0be86f91de285f63d37469a4c37a9a5f96e85#rd">Golang开发命令行工具之flag包的使用</a></p>
<p><a href="http://mp.weixin.qq.com/s?__biz=MzkxNzAzNDA3Ng==&amp;mid=2247485814&amp;idx=1&amp;sn=54dd476d953db5b94319bdeebedc285f&amp;chksm=c1478c45f63005532d82b9d901a58e6c35340e4d7a945ac2fa8582bc7db3547fcfbf25ef0373#rd">Golang接口类型-上篇</a></p>
<p><a href="http://mp.weixin.qq.com/s?__biz=MzkxNzAzNDA3Ng==&amp;mid=2247485844&amp;idx=1&amp;sn=442b1416eece7038b473e057871321ab&amp;chksm=c1478ca7f63005b19667bf36112602919f8d0ec3cc946435df2aec36dc3f273611ea421a4546#rd">Golang接口类型-下篇</a></p>
<p><a href="http://mp.weixin.qq.com/s?__biz=MzkxNzAzNDA3Ng==&amp;mid=2247485960&amp;idx=1&amp;sn=21150114527a1513e576156fa35fa747&amp;chksm=c1478f3bf630062d346b6091cb55ef7d5c5d2f4b3b99618a0932775f139305d9311b1adc5140#rd">Golang反射-上篇</a></p>
<p><a href="http://mp.weixin.qq.com/s?__biz=MzkxNzAzNDA3Ng==&amp;mid=2247485986&amp;idx=1&amp;sn=20cdfba27e172904032a1f69987e35e3&amp;chksm=c1478f11f63006073b83265315b8205d625fe3851506f3d210be516c45c7d247d3f00c15a630#rd">Golang反射-下篇</a></p>
<p><a href="http://mp.weixin.qq.com/s?__biz=MzkxNzAzNDA3Ng==&amp;mid=2247486194&amp;idx=1&amp;sn=4de07e00b093cacc737b9f500902cb41&amp;chksm=c1478fc1f63006d7cc80406cac0ac38f44c5858354c9cabca0c7ae987f53bf7b5f31ce43968e#rd">Golang与散列算法</a></p>
<p><a href="http://mp.weixin.qq.com/s?__biz=MzkxNzAzNDA3Ng==&amp;mid=2247486226&amp;idx=1&amp;sn=e31e32bf90657414e8fbdc5dc74b9d63&amp;chksm=c1478e21f630073781bdfdc576721f6b8c8983911783d2a96b9d7e606afb95d8953e7eceba0c#rd">Golang与对称加密</a></p>
<p><a href="http://mp.weixin.qq.com/s?__biz=MzkxNzAzNDA3Ng==&amp;mid=2247486250&amp;idx=1&amp;sn=bc116d95bccb12304da67b95e9d8d82d&amp;chksm=c1478e19f630070fd3531bcea0db3211d04c0082ee3ddda422f7a20dbf820cc37c84b2e57c9c#rd">Golang与非对称加密</a></p>
<h3 id="数据库相关">数据库相关</h3>
<p><a href="https://mp.weixin.qq.com/s?__biz=MzkxNzAzNDA3Ng==&amp;mid=2247485260&amp;idx=1&amp;sn=2f33901654d6fcc80d5ad84846fb10b2&amp;chksm=c147827ff6300b69dd8a0216e8c3b677f4dd5876a00fc3285eb7962ec2c513d2346872c70088&amp;token=1559315116&amp;lang=zh_CN#rd">MySQL工具Atlas的安装使用</a></p>
<p><a href="http://mp.weixin.qq.com/s?__biz=MzkxNzAzNDA3Ng==&amp;mid=2247484876&amp;idx=1&amp;sn=7969397e4439f776ee5e23c4738d9e2e&amp;chksm=c14780fff63009e900c0cd5b49f30d19ac4262c553325be9a9a26e59b77ed3a60f1e7e051f34#rd">MySQL多实例的部署</a></p>
<p><a href="http://mp.weixin.qq.com/s?__biz=MzkxNzAzNDA3Ng==&amp;mid=2247485213&amp;idx=1&amp;sn=c1fdfc51d28b370ea561fea77f130a1d&amp;chksm=c147822ef6300b380178f55603744029e62fe08ae33b4d37e5a9f5e52cabc53bb3a8437474f2#rd">MySQL MHA部署与测试-上篇</a></p>
<p><a href="http://mp.weixin.qq.com/s?__biz=MzkxNzAzNDA3Ng==&amp;mid=2247485236&amp;idx=1&amp;sn=cabf3539e6c51b81ccdf9c50f6040d0c&amp;chksm=c1478207f6300b115f2ab5ece5c8483c57423c797df107cb21ad4f1491a5b5f93f6ac2f02ca8#rd">MySQL MHA部署与测试-下篇</a></p>
<p><a href="http://mp.weixin.qq.com/s?__biz=MzkxNzAzNDA3Ng==&amp;mid=2247484523&amp;idx=1&amp;sn=adb4b0240bb8a38e4e5e226866619125&amp;chksm=c1478158f630084e9f94357882f5d6bc50bdbcd3c4f35d08b8acde3d791fdd02a7da551672de#rd">MySQL备份工具之Xtrabackup</a></p>
<p><a href="http://mp.weixin.qq.com/s?__biz=MzkxNzAzNDA3Ng==&amp;mid=2247485763&amp;idx=1&amp;sn=3e60b5319af27b5fac671e8cc736bf75&amp;chksm=c1478c70f6300566a38a098c59fe26ec7735c232ff1860467fa106aaa2a3b781dee4daebbafe#rd">MySQL基于Binlog的数据恢复实战</a></p>
<p><a href="http://mp.weixin.qq.com/s?__biz=MzkxNzAzNDA3Ng==&amp;mid=2247485403&amp;idx=1&amp;sn=103001d61242efa1dbd1a24a26b8a39d&amp;chksm=c14782e8f6300bfe674b8b6d1b67cc6787998af2358ef523f27487568615454f5e620cbb4fa1#rd">数据库中间件Mycat的安装使用</a></p>
<p><a href="http://mp.weixin.qq.com/s?__biz=MzkxNzAzNDA3Ng==&amp;mid=2247484771&amp;idx=1&amp;sn=9cbbc8b339f0938210b263cf542f7390&amp;chksm=c1478050f6300946eefd4ee42408756bfa4ee399f45965689468d266f8fe1104e12ad4efcba7#rd">Centos7静默安装Oracle11g</a></p>
<h3 id="git相关">Git相关</h3>
<p><a href="http://mp.weixin.qq.com/s?__biz=MzkxNzAzNDA3Ng==&amp;mid=2247484891&amp;idx=1&amp;sn=4db0b1eaacc75b3708ec688ec9d23e57&amp;chksm=c14780e8f63009fedb48cbc07ea59b20d2de794675b570ce95a2a74efaae5046aef17dd2e45e#rd">使用git-svn无损迁移SVN至GitLab</a></p>
<p><a href="http://mp.weixin.qq.com/s?__biz=MzkxNzAzNDA3Ng==&amp;mid=2247485157&amp;idx=1&amp;sn=af94bde24f161dd1ac643612d7b82dc2&amp;chksm=c14783d6f6300ac0adb476bf0da7421b2fad58ca752fbc46a21dc129272a45a0f9b8b6076529#rd">Git目录为什么这么大</a></p>
<p><a href="http://mp.weixin.qq.com/s?__biz=MzkxNzAzNDA3Ng==&amp;mid=2247484050&amp;idx=1&amp;sn=ef680c7e03784ee10d003155e6e6b833&amp;chksm=c14787a1f6300eb7f959134fd16825ff1f90c29e0eb6fd3f95ef9a4627c6acbb49d1ef1f08d7#rd">利用Git钩子实现代码发布</a></p>
<h3 id="linux相关">Linux相关</h3>
<p><a href="http://mp.weixin.qq.com/s?__biz=MzkxNzAzNDA3Ng==&amp;mid=2247484474&amp;idx=1&amp;sn=1028b711dbd77cf9e49ff8b4b273c2c8&amp;chksm=c1478109f630081fd478c648e03d56821c5bd18c406fe23920384c43fb87f5bf19411b281538#rd">Squid代理及常见的代理上网</a></p>
<p><a href="http://mp.weixin.qq.com/s?__biz=MzkxNzAzNDA3Ng==&amp;mid=2247485077&amp;idx=1&amp;sn=6968792a0e6b2d1d8b3f02fd045c585d&amp;chksm=c14783a6f6300ab099708d9eb7a4ebc31e446557670d63ef7b339a32b03167d43b8ef08f8f8b#rd">非LVM的xfs文件系统扩容</a></p>
<p><a href="http://mp.weixin.qq.com/s?__biz=MzkxNzAzNDA3Ng==&amp;mid=2247485493&amp;idx=1&amp;sn=936b6dc64dea5c26a8f560272cec254a&amp;chksm=c1478d06f63004109956ea7e25f42a001fd4c8b73f6fc6d40c4aa220b00be0e5f1b8c7064764#rd">DNS or hosts ？</a></p>
<p><a href="http://mp.weixin.qq.com/s?__biz=MzkxNzAzNDA3Ng==&amp;mid=2247485020&amp;idx=1&amp;sn=af9f9df88e858bdcf76e9ca7075d7e89&amp;chksm=c147836ff6300a790160417514756b93fcedd8ec9c9baa00afa19ccddc1d665eb0dc705f030d#rd">Tomcat调优整理</a></p>
<p><a href="http://mp.weixin.qq.com/s?__biz=MzkxNzAzNDA3Ng==&amp;mid=2247484846&amp;idx=1&amp;sn=9aad99123f49a8f5d77cff81925d92ad&amp;chksm=c147809df630098ba97ec68bde0b60960b8926a370af007882b258a352f08f9d92c024f301ef#rd">利用GoAccess分析web服务日志</a></p>
<p><a href="http://mp.weixin.qq.com/s?__biz=MzkxNzAzNDA3Ng==&amp;mid=2247484956&amp;idx=1&amp;sn=277cfaa8604297d6275115f1307e6aad&amp;chksm=c147832ff6300a397b62edec3a7cfc12c9a88c6888b6586b7df934c371b10ce978578e6ab226#rd">LVS负载均衡之DR模式</a></p>
<p><a href="http://mp.weixin.qq.com/s?__biz=MzkxNzAzNDA3Ng==&amp;mid=2247484932&amp;idx=1&amp;sn=a9915b11cb5b3e2533bec119986bc18f&amp;chksm=c1478337f6300a21f7261a41e7c09734a46b13ccbd23dd130087b193cc597fac5fdd899f5d40#rd">LVS负载均衡之NAT模式</a></p>
<p><a href="http://mp.weixin.qq.com/s?__biz=MzkxNzAzNDA3Ng==&amp;mid=2247483872&amp;idx=1&amp;sn=5c203be6ee99e12d09d5b6818cce199c&amp;chksm=c14784d3f6300dc57439da14c379f36d2fe2228c3fe9376de721b5e6c39250678f3ce28b8bf0#rd">Nginx 目录浏览基础与进阶</a></p>
<h3 id="其他杂文">其他杂文</h3>
<p><a href="http://mp.weixin.qq.com/s?__biz=MzkxNzAzNDA3Ng==&amp;mid=2247484726&amp;idx=1&amp;sn=b8efc2e4df151aef51b002510856d35d&amp;chksm=c1478005f6300913629ba167d6090ae3a9fb01f9f812aa0c07d0a9951ade02840077a5461637#rd">我的生产力工具推荐-终端01篇</a></p>
<p><a href="http://mp.weixin.qq.com/s?__biz=MzkxNzAzNDA3Ng==&amp;mid=2247484995&amp;idx=1&amp;sn=a4fcdb33dae8802b3a2f97a04c8452f5&amp;chksm=c1478370f6300a66e888782af016280b3f540a4667343ba02eaa130e3d3779cc785570aa0252#rd">我的生产力工具推荐-IDE插件篇</a></p>
<p><a href="http://mp.weixin.qq.com/s?__biz=MzkxNzAzNDA3Ng==&amp;mid=2247485876&amp;idx=1&amp;sn=85a3ec9dc9dea8ee83093885c3a52cc8&amp;chksm=c1478c87f63005919e8ea72210181075629094598847f0a73f8231f25c6f57509e289862b2a4#rd">Mac + VMware Fusion + Windows11尝鲜</a></p>
<p><a href="http://mp.weixin.qq.com/s?__biz=MzkxNzAzNDA3Ng==&amp;mid=2247484557&amp;idx=1&amp;sn=8c1d98d7cd7a7d074cf2a5a12648e111&amp;chksm=c14781bef63008a8506829ad237fb0f0ec042542b3148e4115987ab07c215163ce4c89dab331#rd">Mac下iTerm2配置lrzsz功能</a></p>
<p><a href="http://mp.weixin.qq.com/s?__biz=MzkxNzAzNDA3Ng==&amp;mid=2247485690&amp;idx=1&amp;sn=33cc1934b4c22949f8ad40b058bea36b&amp;chksm=c1478dc9f63004df01eb7a2444def3802a72dd4f561f0169222443236a44dbf272bd4c52d8c9#rd">写在 2021 快要结束的夏天</a></p>
<p>好了，年度总结就到这里吧</p>
<p>感谢身边时长陪伴与关心的人，感谢这一年来遇到的人和事，感谢所有公众号读者</p>
<p>新的一年继续保持初心，向大家分享更好的内容，一起进步</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Golang与非对称加密]]></title>
        <id>https://www.ssgeek.com/post/golang-yu-fei-dui-cheng-jia-mi</id>
        <link href="https://www.ssgeek.com/post/golang-yu-fei-dui-cheng-jia-mi">
        </link>
        <updated>2021-12-30T16:55:28.000Z</updated>
        <content type="html"><![CDATA[<p><ul class="markdownIt-TOC">
<li>
<ul>
<li><a href="#1-%E9%9D%9E%E5%AF%B9%E7%A7%B0%E5%8A%A0%E5%AF%86%E4%BB%8B%E7%BB%8D">1、非对称加密介绍</a></li>
<li><a href="#2-dsa">2、DSA</a></li>
<li><a href="#3-rsa">3、RSA</a>
<ul>
<li><a href="#31-rsa%E7%9A%84%E5%8A%A0%E5%AF%86%E8%BF%87%E7%A8%8B">3.1 RSA的加密过程</a></li>
<li><a href="#32-%E8%B0%83%E7%94%A8%E7%A4%BA%E4%BE%8B">3.2 调用示例</a></li>
</ul>
</li>
<li><a href="#4-ecc">4、ECC</a></li>
<li><a href="#5-ecc%E4%B8%8Ersa%E7%9A%84%E6%AF%94%E8%BE%83">5、ECC与RSA的比较</a></li>
<li><a href="#6-ecdsa">6、ECDSA</a></li>
</ul>
</li>
</ul>
</p>
<figure data-type="image" tabindex="1"><img src="https://image.ssgeek.com/golang.png" alt=""></figure>
<h2 id="1-非对称加密介绍">1、非对称加密介绍</h2>
<p>非对称加密和对称加密不同，主要区别如下</p>
<ul>
<li>
<p>使用公钥加密，使用私钥解密</p>
</li>
<li>
<p>公钥和私钥不同</p>
</li>
<li>
<p>公钥可以公布给所有人</p>
</li>
<li>
<p>私钥只有自己保存</p>
</li>
<li>
<p>相比于对称加密，运算速度非常慢</p>
</li>
</ul>
<p>加密过程：明文+公钥——&gt;密文<br>
解密过程：密文+私钥——&gt;明文</p>
<p>非对称加密算法常用于数据加密和身份认证, 常见的非对称加密算法如下</p>
<ul>
<li>RSA: 由RSA公司发明，是一个支持变长密钥的公共密钥算法，需要加密的文件块的长度也是可变的</li>
<li>DSA(Digital Signature Algorithm): 数字签名算法，是一种标准的<code>DSS</code>(数字签名标准)</li>
<li>ECC(Elliptic Curves Cryptography): 椭圆曲线密码编码学</li>
<li>ECDSA(Elliptic Curve Digital Signature Algorithm): 基于椭圆曲线的<code>DSA</code>签名算法</li>
</ul>
<h2 id="2-dsa">2、DSA</h2>
<p><code>DSA</code>是基于整数有限域离散对数难题的，其安全性与<code>RSA</code>相比差不多。<code>DSA</code>的一个重要特点是两个素数公开，这样，当使用别人的<code>p</code>和<code>q</code>时，即使不知道私钥，你也能确认它们是否是随机产生的，还是作了手脚。<code>RSA</code>算法却做不到，但是其缺点就是只能用于数字签名，不能用于加密</p>
<h2 id="3-rsa">3、RSA</h2>
<p>在<code>1976</code>年，由于对称加密算法已经不能满足需要，<code>Diffie</code>和<code>Hellman</code>发表了一篇叫《密码学新动向》的文章，介绍了公匙加密的概念，由<code>Rivet</code>、<code>Shamir</code>、<code>Adelman</code>提出了<code>RSA</code>算法<br>
<code>RSA</code>是目前最有影响力的公钥加密算法，它能够抵抗到目前为止已知的绝大多数密码攻击，已被<code>ISO</code>推荐为公钥数据加密标准</p>
<p>命名：Ron Rivest、Adi Shamir、Leonard Adleman</p>
<ul>
<li>密钥越长，越难破解，目前<code>768</code>位的密钥还无法破解（至少没人公开宣布），因此可以认为<code>1024</code>位的<code>RSA</code>密钥基本安全，<code>2048</code>位的密钥极其安全</li>
<li><code>RSA</code>的算法原理主要用到了数论</li>
</ul>
<h3 id="31-rsa的加密过程">3.1 RSA的加密过程</h3>
<p>1、随机选择两个不相等的质数<code>p</code>和<code>q</code>，p=61，q=53</p>
<p>2、计算<code>p</code>和<code>q</code>的乘积，n=3233</p>
<p>3、计算<code>n</code>的欧拉函数∅(n) = (p-1)(q-1)，∅(n)=3120</p>
<p>4、随机选择一个整数<code>e</code>，使得1&lt;e&lt;∅(n)，且<code>e</code>与<code>∅(n)</code>互质，e=17</p>
<p>5、计算<code>e</code>对于<code>∅(n)</code>的模反元素d，即求解e*d + ∅(n)*y =1，d=2753，y=-15</p>
<p>6、将<code>n</code>和<code>e</code>封装成公钥，<code>n</code>和<code>d</code>封装成私钥，公钥=(3233, 17)，私钥=(3233, 2753)</p>
<h3 id="32-调用示例">3.2 调用示例</h3>
<p><code>RSA</code>使用示例代码</p>
<pre><code class="language-go">package main
import (
	&quot;crypto/rand&quot;
	&quot;crypto/rsa&quot;
	&quot;crypto/sha1&quot;
	&quot;crypto/x509&quot;
	&quot;encoding/pem&quot;
	&quot;fmt&quot;
)
// 使用对方的公钥的数据, 只有对方的私钥才能解开
func encrypt(plain string, publicKey string) (cipherByte []byte, err error) {
	msg := []byte(plain)
	// 解码公钥
	pubBlock, _ := pem.Decode([]byte(publicKey))
	// 读取公钥
	pubKeyValue, err := x509.ParsePKIXPublicKey(pubBlock.Bytes)
	if err != nil {
		panic(err)
	}
	pub := pubKeyValue.(*rsa.PublicKey)
	// 加密数据方法: 不用使用EncryptPKCS1v15方法加密,源码里面推荐使用EncryptOAEP, 因此这里使用安全的方法加密
	encryptOAEP, err := rsa.EncryptOAEP(sha1.New(), rand.Reader, pub, msg, nil)
	if err != nil {
		panic(err)
	}
	cipherByte = encryptOAEP
	return
}
// 使用私钥解密公钥加密的数据
func decrypt(cipherByte []byte, privateKey string) (plainText string, err error) {
	// 解析出私钥
	priBlock, _ := pem.Decode([]byte(privateKey))
	priKey, err := x509.ParsePKCS1PrivateKey(priBlock.Bytes)
	if err != nil {
		panic(err)
	}
	// 解密RSA-OAEP方式加密后的内容
	decryptOAEP, err := rsa.DecryptOAEP(sha1.New(), rand.Reader, priKey, cipherByte, nil)
	if err != nil {
		panic(err)
	}
	plainText = string(decryptOAEP)
	return
}
func test() {
	msg := &quot;Content bo be encrypted!&quot;
	// 获取公钥, 生产环境往往是文件中读取, 这里为了测试方便, 直接生成了.
	publicKeyData := `-----BEGIN PUBLIC KEY-----
MIGfMA0GCSqGSIb3DQEBAQUAA4GNADCBiQKBgQDZsfv1qscqYdy4vY+P4e3cAtmv
ppXQcRvrF1cB4drkv0haU24Y7m5qYtT52Kr539RdbKKdLAM6s20lWy7+5C0Dgacd
wYWd/7PeCELyEipZJL07Vro7Ate8Bfjya+wltGK9+XNUIHiumUKULW4KDx21+1NL
AUeJ6PeW+DAkmJWF6QIDAQAB
-----END PUBLIC KEY-----
`
	// 获取私钥
	privateKeyData := `-----BEGIN RSA PRIVATE KEY-----
MIICXQIBAAKBgQDZsfv1qscqYdy4vY+P4e3cAtmvppXQcRvrF1cB4drkv0haU24Y
7m5qYtT52Kr539RdbKKdLAM6s20lWy7+5C0DgacdwYWd/7PeCELyEipZJL07Vro7
Ate8Bfjya+wltGK9+XNUIHiumUKULW4KDx21+1NLAUeJ6PeW+DAkmJWF6QIDAQAB
AoGBAJlNxenTQj6OfCl9FMR2jlMJjtMrtQT9InQEE7m3m7bLHeC+MCJOhmNVBjaM
ZpthDORdxIZ6oCuOf6Z2+Dl35lntGFh5J7S34UP2BWzF1IyyQfySCNexGNHKT1G1
XKQtHmtc2gWWthEg+S6ciIyw2IGrrP2Rke81vYHExPrexf0hAkEA9Izb0MiYsMCB
/jemLJB0Lb3Y/B8xjGjQFFBQT7bmwBVjvZWZVpnMnXi9sWGdgUpxsCuAIROXjZ40
IRZ2C9EouwJBAOPjPvV8Sgw4vaseOqlJvSq/C/pIFx6RVznDGlc8bRg7SgTPpjHG
4G+M3mVgpCX1a/EU1mB+fhiJ2LAZ/pTtY6sCQGaW9NwIWu3DRIVGCSMm0mYh/3X9
DAcwLSJoctiODQ1Fq9rreDE5QfpJnaJdJfsIJNtX1F+L3YceeBXtW0Ynz2MCQBI8
9KP274Is5FkWkUFNKnuKUK4WKOuEXEO+LpR+vIhs7k6WQ8nGDd4/mujoJBr5mkrw
DPwqA3N5TMNDQVGv8gMCQQCaKGJgWYgvo3/milFfImbp+m7/Y3vCptarldXrYQWO
AQjxwc71ZGBFDITYvdgJM1MTqc8xQek1FXn1vfpy2c6O
-----END RSA PRIVATE KEY-----
`
	cipherData, err := encrypt(msg, publicKeyData)
	if err != nil {
		panic(err)
	}
	fmt.Printf(&quot;encrypt message: %x\n&quot;, cipherData)
	plainData, err := decrypt(cipherData, privateKeyData)
	if err != nil {
		panic(err)
	}
	fmt.Printf(&quot;decrypt message:%s\n&quot;, plainData)
}
func main() {
	test()
}
</code></pre>
<h2 id="4-ecc">4、ECC</h2>
<p><code>ECC</code>又称椭圆曲线加密</p>
<p><code>ECC</code>（Elliptic Curve Cryptography）椭圆曲线加密算法，相比<code>RSA</code>，<code>ECC</code>可以使用更短的密钥，来实现与<code>RSA</code>相当或更高的安全</p>
<p>定义了椭圆曲线上的加法和二倍运算</p>
<p>椭圆曲线依赖的数学难题是：<code>k</code>为正整数，<code>p</code>是椭圆曲线上的点（称为基点），k*p=Q，已知<code>Q</code>和<code>P</code>，很难计算出k</p>
<p><code>ECC</code>是建立在基于椭圆曲线的离散对数的难度, 大概过程如下</p>
<pre><code>给定椭圆曲线上的一个点P，一个整数k，求解Q=kP很容易；给定一个点P、Q，知道Q=kP，求整数k确是一个难题。ECDH即建立在此数学难题之上
</code></pre>
<p>今天只有短的<code>RSA</code>钥匙才可能被强力方式解破。到<code>2008</code>年为止，世界上还没有任何可靠的攻击RSA算法的方式。只要其钥匙的长度足够长，用<code>RSA</code>加密的信息实际上是不能被解破的。但在分布式计算和量子计算机理论日趋成熟的今天，<code>RSA</code>加密安全性受到了挑战</p>
<p>随着分解大整数方法的进步及完善、计算机速度的提高以及计算机网络的发展，为了保障数据的安全，<code>RSA</code>的密钥需要不断增加，但是，密钥长度的增加导致了其加解密的速度大为降低，硬件实现也变得越来越难以忍受，这对使用<code>RSA</code>的应用带来了很重的负担，因此需要一种新的算法来代替<code>RSA</code></p>
<p><code>1985</code>年<code>N.Koblitz</code>和<code>Miller</code>提出将椭圆曲线用于密码算法，根据是有限域上的椭圆曲线上的点群中的离散对数问题<code>ECDLP</code>。<code>ECDLP</code>是比因子分解问题更难的问题，它是指数级的难度</p>
<p>椭圆曲线算法因参数不同有多种类型, 这个网站列出了现阶段那些<code>ECC</code>是相对安全的:椭圆曲线算法安全列表, 而<code>curve25519</code>便是其中的佼佼者</p>
<p><code>Curve25519/Ed25519/X25519</code>是著名密码学家<code>Daniel J. Bernstein</code>在<code>2006</code>年独立设计的椭圆曲线加密/签名/密钥交换算法, 和现有的任何椭圆曲线算法都完全独立<br>
特点是：</p>
<ul>
<li>完全开放设计: 算法各参数的选择直截了当，非常明确，没有任何可疑之处，相比之下目前广泛使用的椭圆曲线是NIST系列标准，方程的系数是使用来历不明的随机种子 c49d3608 86e70493 6a6678e1 139d26b7 819f7e90 生成的，非常可疑，疑似后门；</li>
<li>高安全性： 一个椭圆曲线加密算法就算在数学上是安全的，在实用上也并不一定安全，有很大的概率通过缓存、时间、恶意输入摧毁安全性，而25519系列椭圆曲线经过特别设计，尽可能的将出错的概率降到了最低，可以说是实践上最安全的加密算法。例如，任何一个32位随机数都是一个合法的X25519公钥，因此通过恶意数值攻击是不可能的，算法在设计的时候刻意避免的某些分支操作，这样在编程的时候可以不使用if ，减少了不同if分支代码执行时间不同的时序攻击概率，相反， NIST系列椭圆曲线算法在实际应用中出错的可能性非常大，而且对于某些理论攻击的免疫能力不高， Bernstein 对市面上所有的加密算法使用12个标准进行了考察， 25519是几乎唯一满足这些标准的；</li>
<li>速度快: 25519系列曲线是目前最快的椭圆曲线加密算法，性能远远超过NIST系列，而且具有比P-256更高的安全性；</li>
<li>作者功底深厚: Daniel J. Bernstein是世界著名的密码学家，他在大学曾经开设过一门 UNIX 系统安全的课程给学生，结果一学期下来，发现了 UNIX 程序中的 91 个安全漏洞；他早年在美国依然禁止出口加密算法时，曾因为把自己设计的加密算法发布到网上遭到了美国政府的起诉，他本人抗争六年，最后美国政府撤销所有指控，目前另一个非常火的高性能安全流密码 ChaCha20 也是出自 Bernstein 之手；</li>
<li>下一代的标准: 25519系列曲线自2006年发表以来，除了学术界无人问津， 2013 年爱德华·斯诺登曝光棱镜计划后，该算法突然大火，大量软件，如OpenSSH都迅速增加了对25519系列的支持，如今25519已经是大势所趋，可疑的NIST曲线迟早要退出椭圆曲线的历史舞台，目前， RFC增加了SSL/TLS对X25519密钥交换协议的支持，OpenSSL 1.1也加入支持，是摆脱老大哥的第一步，下一步是将 Ed25519做为可选的TLS证书签名算法，彻底摆脱NIST</li>
</ul>
<h2 id="5-ecc与rsa的比较">5、ECC与RSA的比较</h2>
<p><code>ECC</code>和<code>RSA</code>相比，在许多方面都有对绝对的优势，主要体现在以下方面：</p>
<ul>
<li>抗攻击性强。相同的密钥长度，其抗攻击性要强很多倍</li>
<li>计算量小，处理速度快。<code>ECC</code>总的速度比<code>RSA</code>、<code>DSA</code>要快得多</li>
<li>存储空间占用小。<code>ECC</code>的密钥尺寸和系统参数与<code>RSA</code>、<code>DSA</code>相比要小得多，意味着它所占的存贮空间要小得多。这对于加密算法在<code>IC</code>卡上的应用具有特别重要的意义</li>
<li>带宽要求低。当对长消息进行加解密时，三类密码系统有相同的带宽要求，但应用于短消息时<code>ECC</code>带宽要求却低得多。带宽要求低使<code>ECC</code>在无线网络领域具有广泛的应用前景</li>
</ul>
<p><code>ECC</code>的这些特点使它必将取代<code>RSA</code>，成为通用的公钥加密算法。比如<code>SET</code>协议的制定者已把它作为下一代<code>SET</code>协议中缺省的公钥密码算法</p>
<h2 id="6-ecdsa">6、ECDSA</h2>
<p>因为在数字签名的安全性高, 基于<code>ECC</code>的<code>DSA</code>更高, 所以非常适合数字签名使用场景, 在<code>SSH TLS</code>有广泛使用, <code>ECC</code>把离散对数安全性高很少，所以<code>ECC</code>在安全领域会成为下一个标准</p>
<p>在<code>golang</code>的<code>ssh</code>库中就是使用这个算法来签名的：<code>A</code>使用自己的私钥签名一段数据，然后将公钥发放出去。用户拿到公钥后，验证数据的签名,如果通过则证明数据来源是<code>A</code>，从而达到身份认证的作用</p>
<pre><code class="language-go">package main

import (
	&quot;crypto/ecdsa&quot;
	&quot;crypto/elliptic&quot;
	&quot;crypto/md5&quot;
	&quot;crypto/rand&quot;
	&quot;fmt&quot;
	&quot;hash&quot;
	&quot;io&quot;
	&quot;math/big&quot;
)
// SignData 用于保存签名的数据
type SignData struct {
	r         *big.Int
	s         *big.Int
	signhash  *[]byte
	signature *[]byte
}
// 使用私钥签名一段数据
func sign(message string, privateKey *ecdsa.PrivateKey) (signData *SignData, err error) {
	// 签名数据
	var h hash.Hash
	h = md5.New()
	r := big.NewInt(0)
	s := big.NewInt(0)
	io.WriteString(h, message)
	signhash := h.Sum(nil)
	r, s, serr := ecdsa.Sign(rand.Reader, privateKey, signhash)
	if serr != nil {
		return nil, serr
	}
	signature := r.Bytes()
	signature = append(signature, s.Bytes()...)
	signData = &amp;SignData{
		r:         r,
		s:         s,
		signhash:  &amp;signhash,
		signature: &amp;signature,
	}
	return
}
// 校验数字签名
func verifySign(signData *SignData, publicKey *ecdsa.PublicKey) (status bool) {
	status = ecdsa.Verify(publicKey, *signData.signhash, signData.r, signData.s)
	return
}
func test() {
	//使用椭圆曲线的P256算法,现在一共也就实现了4种,我们使用折中一种,具体见http://golang.org/pkg/crypto/elliptic/#P256
	pubkeyCurve := elliptic.P256()
	privateKey := new(ecdsa.PrivateKey)
	// 生成秘钥对
	privateKey, err := ecdsa.GenerateKey(pubkeyCurve, rand.Reader)
	if err != nil {
		panic(err)
	}
	var publicKey ecdsa.PublicKey
	publicKey = privateKey.PublicKey
	// 签名
	signData, err := sign(&quot;This is a message to be signed and verified by ECDSA!&quot;, privateKey)
	if err != nil {
		panic(err)
	}
	fmt.Printf(&quot;The signhash: %x\nThe signature: %x\n&quot;, *signData.signhash, *signData.signature)
	// 验证
	status := verifySign(signData, &amp;publicKey)
	fmt.Printf(&quot;The verify result is: %v\n&quot;, status)
}
func main() {
	test()
}
</code></pre>
<p>See you ~</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[ack集群Terway网络场景下的vSwitch扩容]]></title>
        <id>https://www.ssgeek.com/post/ack-ji-qun-terway-wang-luo-chang-jing-xia-de-vswitch-kuo-rong</id>
        <link href="https://www.ssgeek.com/post/ack-ji-qun-terway-wang-luo-chang-jing-xia-de-vswitch-kuo-rong">
        </link>
        <updated>2021-12-27T17:00:49.000Z</updated>
        <content type="html"><![CDATA[<p><ul class="markdownIt-TOC">
<li>
<ul>
<li><a href="#1-terway%E7%BD%91%E7%BB%9C%E4%BB%8B%E7%BB%8D">1、Terway网络介绍</a></li>
<li><a href="#2-%E9%97%AE%E9%A2%98%E7%8E%B0%E8%B1%A1">2、问题现象</a></li>
<li><a href="#3-%E6%89%A9%E5%AE%B9%E6%93%8D%E4%BD%9C">3、扩容操作</a>
<ul>
<li><a href="#31-%E6%96%B0%E5%A2%9E%E4%BA%A4%E6%8D%A2%E6%9C%BA%E5%B9%B6%E9%85%8D%E7%BD%AEnat">3.1 新增交换机并配置NAT</a></li>
<li><a href="#32-%E9%85%8D%E7%BD%AE%E9%9B%86%E7%BE%A4%E7%9A%84terway">3.2 配置集群的Terway</a></li>
<li><a href="#33-%E9%87%8D%E5%90%AFterway">3.3 重启terway</a></li>
</ul>
</li>
</ul>
</li>
</ul>
</p>
<figure data-type="image" tabindex="1"><img src="https://image.ssgeek.com/20211228-01.png" alt=""></figure>
<h2 id="1-terway网络介绍">1、Terway网络介绍</h2>
<p><code>Terway</code>是阿里云开源的基于专有网络VPC的容器网络接口<code>CNI</code>（Container Network Interface）插件，支持基于<code>Kubernetes</code>标准的网络策略来定义容器间的访问策略。可以通过使用<code>Terway</code>网络插件实现<code>Kubernetes</code>集群内部的网络互通</p>
<p><code>Terway</code>网络插件将原生的弹性网卡分配给<code>Pod</code>实现<code>Pod</code>网络，支持基于<code>Kubernetes</code>标准的网络策略（Network Policy）来定义容器间的访问策略，并兼容<code>Calico</code>的网络策略</p>
<p>在<code>Terway</code>网络插件中，每个<code>Pod</code>都拥有自己网络栈和<code>IP</code>地址。同一台<code>ECS</code>内的<code>Pod</code>之间通信，直接通过机器内部的转发，跨<code>ECS</code>的<code>Pod</code>通信，报文通过<code>VPC</code>的弹性网卡直接转发。由于不需要使用<code>VxLAN</code>等的隧道技术封装报文，因此<code>Terway</code>模式网络具有较高的通信性能</p>
<p>一句话总结，<code>Terway</code>最大的特点就是借助于云上<code>ECS</code>服务器的特性，将<code>pod</code>与<code>node</code>的网络进行了拉平，同时使用<code>VPC</code>下<code>vSwitch</code>中的<code>ip</code></p>
<h2 id="2-问题现象">2、问题现象</h2>
<p>由于使用了<code>Terway</code>网络模式，随着<code>node</code>机器和<code>pod</code>数量的增多，每分配一个<code>ip</code>出去都需要消耗掉<code>vpc</code>下<code>vsw</code>的可用<code>ip</code>。如果某短时间业务快速增长，导致<code>pod</code>大量消耗可用<code>ip</code>，这个时候就有可能因前期规划不充足导致<code>vSwitch</code>的可用<code>ip</code>不足</p>
<p>这个时候新创建的<code>pod</code>状态为<code>ContainerCreating</code>，<code>describe</code>查看<code>pod</code>提示<code>error allocate ip...</code>，这个时候查看<code>Pod</code>所在节点的<code>Terway</code>的日志，会有下面内容</p>
<pre><code class="language-shell">Message: The specified VSwitch &quot;vsw-xxxxx&quot; has not enough IpAddress.
</code></pre>
<p>提示没有足够的<code>ip</code>，这个时候基本都是由于交换机的<code>ip</code>不够用，登录到交换机的控制台可以查看到这个节点所在的交换机的可用<code>ip</code>数，如果很少甚至为<code>0</code>，就表示需要扩容了</p>
<h2 id="3-扩容操作">3、扩容操作</h2>
<h3 id="31-新增交换机并配置nat">3.1 新增交换机并配置NAT</h3>
<p>在专有网络管理控制台对应的<code>VPC</code>创建新的<code>vSwitch</code>，该<code>vSwitch</code>必须与<code>IP</code>资源不足的<code>vSwitch</code>在同一个区域。这是因为<code>Terway</code>分配给<code>pod ip</code>时的策略是，分配<code>node</code>所在可用区中的<code>vSwitch</code>对应的<code>ip</code>，因此，扩容就需要扩容同一可用区的交换机</p>
<p>在初始化集群新建交换机以及扩容交换机的时候都应该考虑，因<code>Pod</code>密度越来越大，为了满足<code>Pod</code>对<code>IP</code>地址日益增长的需求，建议创建给<code>Pod</code>使用的<code>vSwitch</code>的网络位小于等于<code>19</code>，即每个网段中至少包含<code>8192</code>个可用<code>IP</code>地址</p>
<figure data-type="image" tabindex="2"><img src="https://image.ssgeek.com/20211228-02.png" alt=""></figure>
<p><code>vSwitch</code>创建完成后，需要对这个<code>vSwitch</code>配置<code>NAT</code>策略，以便访问外部网络</p>
<figure data-type="image" tabindex="3"><img src="https://image.ssgeek.com/20211228-03.png" alt=""></figure>
<h3 id="32-配置集群的terway">3.2 配置集群的Terway</h3>
<p>配置集群的<code>Terway</code>，添加上面创建的<code>vSwitch</code>到<code>Terway</code>的<code>ConfigMap</code>配置中</p>
<pre><code class="language-shell">kubectl -n kube-system edit cm eni-config
</code></pre>
<p>配置样例参考<a href="https://github.com/AliyunContainerService/terway/blob/main/docs/dynamic-config.md">Terway配置参考</a>，部分内容说明如下</p>
<pre><code class="language-yaml">
apiVersion: v1
kind: ConfigMap
metadata:
  name: eni-config
  namespace: kube-system
data:
  10-terway.conf: |-
    {
      &quot;cniVersion&quot;: &quot;0.3.0&quot;,
      &quot;name&quot;: &quot;terway&quot;,
      &quot;type&quot;: &quot;terway&quot;
    }
  disable_network_policy: &quot;true&quot;
  eni_conf: |-
    {
      &quot;version&quot;: &quot;1&quot;,  # 版本
      &quot;max_pool_size&quot;: 80,  # 资源池最大水位
      &quot;min_pool_size&quot;: 20,  # 资源池最小水位
      &quot;credential_path&quot;: &quot;/var/addon/token-config&quot;,
      &quot;vswitches&quot;: {&quot;cn-shanghai-f&quot;:[&quot;vsw-AAA&quot;, &quot;vsw-BBB&quot;]},  # 关联的虚拟交换机(ENI多IP模式)，添加vsw-BBB到VSwitches部分，其中vsw-AAA是已经存在的且IP资源不足的VSwitch
      &quot;eni_tags&quot;: {&quot;ack.aliyun.com&quot;:&quot;xxxxxxxxx&quot;},
      &quot;service_cidr&quot;: &quot;172.16.0.0/16&quot;,  # 服务CIDR
      &quot;security_group&quot;: &quot;sg-xxxxxxx&quot;, # 安全组ID
      &quot;vswitch_selection_policy&quot;: &quot;ordered&quot;
    }
</code></pre>
<p>上面配置参数中，资源池水位的配置值。<code>Terway</code>使用底层虚拟化底层的网络资源打通容器网络，网络资源的创建和释放需要一系列的<code>API</code>调用，如果在<code>Pod</code>创建销毁时频繁调用<code>API</code>会导致<code>Pod</code>配置时间较长。 <code>Terway</code>通过池化的方式对资源进行缓存，当小于资源的池的最小水位时自动补充资源，在大于资源池最大水位时开始释放资源，这样保障了高效的资源利用和分配的效率</p>
<p>相当于预先分配了<code>ip</code>，具体设置可以考虑到所在机器节点规格支持的最大<code>eni</code>辅助网卡个数以及最大<code>pod</code>数灵活设置</p>
<h3 id="33-重启terway">3.3 重启terway</h3>
<p>重启所有<code>Terway</code>的<code>pod</code>以便快速刷新缓存生效</p>
<pre><code class="language-shell"># kubectl -n kube-system delete pod -l app=terway-eniip
# kubectl -n kube-system get pod | grep terway
</code></pre>
<p>重启后检查异常的<code>pod</code>是否正常获取了<code>ip</code>即可</p>
<p>当排查某个<code>pod</code>的<code>ip</code>分配相关问题时，也可以通过进入到所在节点的<code>terway pod</code>中，执行命令行，查看当前已分配的ip情况，以及已经从<code>vSwitch</code>分配得来后，暂时空闲的<code>ip</code>情况</p>
<pre><code class="language-shell"># terway-cli mapping
Status | Pod Name                                               | Res ID                           | Factory Res ID
Normal | node-problem-detector-l5h52                            | 00:16:10:48:3e:37.10.244.18.167 | 00:16:10:48:3e:37.10.244.18.167
...
Idle   |                                                        | 00:16:10:48:3e:37.10.244.18.132 | 00:16:10:48:3e:37.10.244.18.132
Idle   |                                                        | 00:16:10:48:3e:37.10.244.18.18  | 00:16:10:48:3e:37.10.244.18.18
Idle   |                                                        | 00:16:10:48:3e:37.10.244.18.54  | 00:16:10:48:3e:37.10.244.18.54
</code></pre>
<p>See you ~</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Golang与对称加密]]></title>
        <id>https://www.ssgeek.com/post/golang-yu-dui-cheng-jia-mi</id>
        <link href="https://www.ssgeek.com/post/golang-yu-dui-cheng-jia-mi">
        </link>
        <updated>2021-12-22T18:03:10.000Z</updated>
        <content type="html"><![CDATA[<p><ul class="markdownIt-TOC">
<li>
<ul>
<li><a href="#1-%E5%AF%B9%E7%A7%B0%E5%8A%A0%E5%AF%86%E4%BB%8B%E7%BB%8D">1、对称加密介绍</a></li>
<li><a href="#2-des">2、DES</a>
<ul>
<li><a href="#21-%E6%A6%82%E8%BF%B0">2.1 概述</a></li>
<li><a href="#22-%E4%B8%BB%E8%A6%81%E6%80%9D%E8%B7%AF">2.2 主要思路</a></li>
<li><a href="#23-des%E5%AD%90%E5%AF%86%E9%92%A5%E7%94%9F%E6%88%90">2.3 DES子密钥生成</a></li>
<li><a href="#24-des%E5%8A%A0%E5%AF%86%E8%BF%87%E7%A8%8B">2.4 DES加密过程</a></li>
<li><a href="#25-%E4%BD%BF%E7%94%A8%E7%A4%BA%E4%BE%8B">2.5 使用示例</a></li>
<li><a href="#26-%E5%88%86%E7%BB%84%E6%A8%A1%E5%BC%8F">2.6 分组模式</a></li>
</ul>
</li>
<li><a href="#3-aes">3、AES</a></li>
<li><a href="#4-cbc">4、CBC</a></li>
</ul>
</li>
</ul>
</p>
<figure data-type="image" tabindex="1"><img src="https://image.ssgeek.com/golang.png" alt=""></figure>
<h2 id="1-对称加密介绍">1、对称加密介绍</h2>
<p>对称加密算法用来对敏感数据等信息进行加密，常用的算法包括：</p>
<ul>
<li>DES(Data Encryption Standard)：数据加密标准，速度较快，适用于加密大量数据的场合</li>
<li>3DES(Triple DES)：是基于<code>DES</code>，对一块数据用三个不同的密钥进行三次加密，强度更高</li>
<li>AES(Advanced Encryption Standard)：高级加密标准，是下一代的加密算法标准，速度快，安全级别高</li>
<li>CBC 分组加密的四种模式之一<code>ECB</code>、<code>CBC</code>、<code>CFB</code>、<code>OFB</code></li>
</ul>
<p>对称加密又分为分组加密和序列密码</p>
<ul>
<li>
<p>分组密码，也叫块加密<code>block cyphers</code>，一次加密明文中的一个块。是将明文按一定的位长分组，明文组经过加密运算得到密文组，密文组经过解密运算（加密运算的逆运算），还原成明文组</p>
</li>
<li>
<p>序列密码，也叫流加密<code>stream cyphers</code>，一次加密明文中的一个位。是指利用少量的密钥（制乱元素）通过某种复杂的运算（密码算法）产生大量的伪随机位流，用于对明文位流的加密</p>
</li>
</ul>
<p>对称加密的特点</p>
<ul>
<li>
<p>加密过程每一步都是可逆的</p>
</li>
<li>
<p>加密和解密用的是同一组密钥</p>
</li>
</ul>
<h2 id="2-des">2、DES</h2>
<h3 id="21-概述">2.1 概述</h3>
<p>DES（<code>Data Encryption Standard</code>）数据加密标准，是目前最为流行的加密算法之一<br>
DES是一种使用密钥加密的块算法，<code>1977</code>年被美国联邦政府的国家标准局确定为联邦资料处理标准<code>FIPS</code>，并授权在非密级政府通信中使用，随后该算法在国际上广泛流传开来</p>
<p>AES与3DES的比较</p>
<table>
<thead>
<tr>
<th>算法名称</th>
<th>算法类型</th>
<th>密钥长度</th>
<th>速度</th>
<th>解密时间（建设机器每秒尝试255个密钥）</th>
<th>资源消耗</th>
</tr>
</thead>
<tbody>
<tr>
<td>AES</td>
<td>对称block密码</td>
<td>128、192、256位</td>
<td>高</td>
<td>1490000亿年</td>
<td>低</td>
</tr>
<tr>
<td>3DES</td>
<td>对称feistel密码</td>
<td>112位或168位</td>
<td>低</td>
<td>46亿年</td>
<td>中</td>
</tr>
</tbody>
</table>
<p>破解历史</p>
<p>历史上有三次对<code>DES</code>有影响的攻击实验。<code>1997</code>年，利用当时各国 <code>7</code>万台计算机，历时<code>96</code>天破解了<code>DES</code>的密钥。<code>1998</code>年，电子边境基金会（EFF）用<code>25</code>万美元制造的专用计算机，用<code>56</code>小时破解了<code>DES</code>的密钥。1999年，<code>EFF</code>用<code>22</code>小时<code>15</code>分完成了破解工作</p>
<h3 id="22-主要思路">2.2 主要思路</h3>
<p>对原始数据（明文）进行分组，每组<code>64</code>位<code>bit</code>，最后一组不足<code>64</code>位时按一定规则填充，每一组上单独施加<code>DES</code>算法</p>
<h3 id="23-des子密钥生成">2.3 DES子密钥生成</h3>
<ul>
<li>第一步</li>
</ul>
<p>初始密钥<code>64</code>位，实际有效位<code>56</code>位，每隔<code>7</code>位有一个校验位<br>
根据初始密钥生成<code>16</code>个<code>48</code>位的字密钥</p>
<p>密钥置换（打散），64——&gt;56<br>
<img src="https://image.ssgeek.com/20211223-01.png" alt=""><br>
例如，第<code>57</code>位放在第<code>1</code>个位置，第<code>49</code>位放在第<code>2</code>个位置，将顺序打乱并去除了校验位</p>
<ul>
<li>第二步</li>
</ul>
<p>左旋右旋，再次置换56——&gt;48<br>
<img src="https://image.ssgeek.com/20211223-02.png" alt=""></p>
<h3 id="24-des加密过程">2.4 DES加密过程</h3>
<p>明文——&gt;初始置换——&gt;L0(<code>32</code>位)、R0(<code>32</code>位)<br>
<img src="https://image.ssgeek.com/20211223-03.png" alt=""></p>
<p><code>S</code>盒替换的逻辑<br>
输入<code>48</code>位，输出<code>32</code>位，各分为<code>8</code>组，输入每组<code>6</code>位，输出每组<code>4</code>位<br>
分别在每组上施加<code>S</code>盒替换，一共<code>8</code>个<code>S</code>盒</p>
<figure data-type="image" tabindex="2"><img src="https://image.ssgeek.com/20211223-04.png" alt=""></figure>
<p>合并<br>
L16(<code>32</code>位)、R16(<code>32</code>位)——&gt;合并——&gt;最终置换——&gt;密文（<code>64</code>位）</p>
<h3 id="25-使用示例">2.5 使用示例</h3>
<pre><code class="language-go">/DesEncrypt DES加密
//密钥必须是64位，所以key必须是长度为8的byte数组
func DesEncrypt(text string, key []byte) (string, error) {
	if len(key) != 8 {
		return &quot;&quot;, fmt.Errorf(&quot;DES加密算法要求key必须是64位bit&quot;)
	}
	block, err := des.NewCipher(key) //用des创建一个加密器cipher
	if err != nil {
		return &quot;&quot;, err
	}
	src := []byte(text)
	blockSize := block.BlockSize()           //分组的大小，blockSize=8
	src = common.ZeroPadding(src, blockSize) //填充成64位整倍数

	out := make([]byte, len(src)) //密文和明文的长度一致
	dst := out
	for len(src) &gt; 0 {
		//分组加密
		block.Encrypt(dst, src[:blockSize]) //对src进行加密，加密结果放到dst里
		//移到下一组
		src = src[blockSize:]
		dst = dst[blockSize:]
	}
	return hex.EncodeToString(out), nil
}

//DesDecrypt DES解密
//密钥必须是64位，所以key必须是长度为8的byte数组
func DesDecrypt(text string, key []byte) (string, error) {
	src, err := hex.DecodeString(text) //转成[]byte
	if err != nil {
		return &quot;&quot;, err
	}
	block, err := des.NewCipher(key)
	if err != nil {
		return &quot;&quot;, err
	}

	blockSize := block.BlockSize()
	out := make([]byte, len(src))
	dst := out
	for len(src) &gt; 0 {
		//分组解密
		block.Decrypt(dst, src[:blockSize])
		src = src[blockSize:]
		dst = dst[blockSize:]
	}
	out = common.ZeroUnPadding(out) //反填充
	return string(out), nil
}
</code></pre>
<h3 id="26-分组模式">2.6 分组模式</h3>
<ul>
<li>CBC（Cipher Block Chaining）密文分组链接模式，将当前明文分组与前一个密文分组进行异或运算，然后再进行加密</li>
<li>其他分组模式还有ECB、CTR、CFR、OFB</li>
</ul>
<p>分组模式使用示例</p>
<pre><code class="language-go">func DesEncryptCBC(text string, key []byte) (string, error) {
	src := []byte(text)
	block, err := des.NewCipher(key) //用des创建一个加密器cipher
	if err != nil {
		return &quot;&quot;, err
	}
	blockSize := block.BlockSize()           //分组的大小，blockSize=8
	src = common.ZeroPadding(src, blockSize) //填充

	out := make([]byte, len(src))                   //密文和明文的长度一致
	encrypter := cipher.NewCBCEncrypter(block, key) //CBC分组模式加密
	encrypter.CryptBlocks(out, src)
	return hex.EncodeToString(out), nil
}

func DesDecryptCBC(text string, key []byte) (string, error) {
	src, err := hex.DecodeString(text) //转成[]byte
	if err != nil {
		return &quot;&quot;, err
	}
	block, err := des.NewCipher(key)
	if err != nil {
		return &quot;&quot;, err
	}

	out := make([]byte, len(src))                   //密文和明文的长度一致
	encrypter := cipher.NewCBCDecrypter(block, key) //CBC分组模式解密
	encrypter.CryptBlocks(out, src)
	out = common.ZeroUnPadding(out) //反填充
	return string(out), nil
}
</code></pre>
<h2 id="3-aes">3、AES</h2>
<p>AES（<code>Advanced Encryption Standard</code>）高级加密标准，旨在取代<code>DES</code></p>
<p><code>2000</code>年<code>10</code>月，<code>NIST</code>(美国国家标准和技术协会)宣布通过从<code>15</code>种侯选算法中选出的一项新的密匙加密标准。<code>Rijndael</code>被选中成为将来的<code>AES</code>。 <code>Rijndael</code>是在<code>1999</code>年下半年，由研究员<code>Joan Daemen</code>和<code>Vincent Rijmen</code>创建的。<code>AES</code>正日益成为加密各种形式的电子数据的实际标准<br>
并于<code>2002</code>年<code>5</code>月<code>26</code>日制定了新的高级加密标准<code>AES</code>规范</p>
<p>算法原理</p>
<p><code>AES</code>算法基于排列和置换运算。排列是对数据重新进行安排，置换是将一个数据单元替换为另一个。<code>AES</code>使用几种不同的方法来执行排列和置换运算。<br>
<code>AES</code>是一个迭代的、对称密钥分组的密码，它可以使用<code>128</code>、<code>192</code>和<code>256</code>位密钥，并且用<code>128</code>位（<code>16</code>字节）分组加密和解密数据。与公共密钥密码使用密钥对不同，对称密钥密码使用相同的密钥加密和解密数据。通过分组密码返回的加密数据的位数与输入数据相同。迭代加密使用一个循环结构，在该循环中重复置换和替换输入数据</p>
<p>综上看来<code>AES</code>安全度最高, 基本现状就是<code>AES</code>已经替代<code>DES</code>成为新一代对称加密的标准</p>
<p><code>AES</code>使用示例</p>
<pre><code class="language-go">package main
import (
	&quot;crypto/aes&quot;
	&quot;crypto/cipher&quot;
	&quot;fmt&quot;
)
var commonIV = []byte{0x00, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x08, 0x09, 0x0a, 0x0b, 0x0c, 0x0d, 0x0e, 0x0f}
func encrypt(plainText string, keyText string) (cipherByte []byte, err error) {
	// 转换成字节数据, 方便加密
	plainByte := []byte(plainText)
	keyByte := []byte(keyText)
	// 创建加密算法aes
	c, err := aes.NewCipher(keyByte)
	if err != nil {
		return nil, err
	}
	//加密字符串
	cfb := cipher.NewCFBEncrypter(c, commonIV)
	cipherByte = make([]byte, len(plainByte))
	cfb.XORKeyStream(cipherByte, plainByte)
	return
}
func decrypt(cipherByte []byte, keyText string) (plainText string, err error) {
	// 转换成字节数据, 方便加密
	keyByte := []byte(keyText)
	// 创建加密算法aes
	c, err := aes.NewCipher(keyByte)
	if err != nil {
		return &quot;&quot;, err
	}
	// 解密字符串
	cfbdec := cipher.NewCFBDecrypter(c, commonIV)
	plainByte := make([]byte, len(cipherByte))
	cfbdec.XORKeyStream(plainByte, cipherByte)
	plainText = string(plainByte)
	return
}
func main() {
	plain := &quot;The text need to be encrypt.&quot;
	// AES 规定有3种长度的key: 16, 24, 32分别对应AES-128, AES-192, or AES-256
	key := &quot;abcdefgehjhijkmlkjjwwoew&quot;
	// 加密
	cipherByte, err := encrypt(plain, key)
	if err != nil {
		fmt.Println(err)
	}
	fmt.Printf(&quot;%s ==&gt; %x\n&quot;, plain, cipherByte)
	// 解密
	plainText, err := decrypt(cipherByte, key)
	if err != nil {
		fmt.Println(err)
	}
	fmt.Printf(&quot;%x ==&gt; %s\n&quot;, cipherByte, plainText)
}
</code></pre>
<h2 id="4-cbc">4、CBC</h2>
<p>分组密码，也叫块加密<code>block cyphers</code>，一次加密明文中的一个块。是将明文按一定的位长分组，明文组经过加密运算得到密文组，密文组经过解密运算（加密运算的逆运算），还原成明文组。<br>
序列密码，也叫流加密<code>stream cyphers</code>，一次加密明文中的一个位。是指利用少量的密钥（制乱元素）通过某种复杂的运算（密码算法）产生大量的伪随机位流，用于对明文位流的加密。<br>
解密是指用同样的密钥和密码算法及与加密相同的伪随机位流，用以还原明文位流</p>
<p>分组加密算法中，有<code>ECB</code>,<code>CBC</code>,<code>CFB</code>,<code>OFB</code>这几种算法模式, 我们介绍其中常用的一种<code>CBC</code></p>
<p><code>CBC</code>(<code>Cipher Block Chaining</code>)密文分组链接方式</p>
<p>加密步骤如下：</p>
<ul>
<li>首先将数据按照8个字节一组进行分组得到<code>D1D2......Dn</code>（若数据不是8的整数倍，用指定的<code>PADDING</code>数据补位）</li>
<li>第一组数据<code>D1</code>与初始化向量I异或后的结果进行<code>DES</code>加密得到第一组密文<code>C1</code>（初始化向量I为全零）</li>
<li>第二组数据<code>D2</code>与第一组的加密结果<code>C1</code>异或以后的结果进行<code>DES</code>加密，得到第二组密文<code>C2</code></li>
<li>之后的数据以此类推，得到<code>Cn</code></li>
<li>按顺序连为<code>C1C2C3......Cn</code>即为加密结果</li>
</ul>
<pre><code class="language-go">// aesCBCEncrypt aes加密，填充秘钥key的16位，24,32分别对应AES-128, AES-192, or AES-256.
func aesCBCEncrypt(rawData, key []byte) ([]byte, error) {
	block, err := aes.NewCipher(key)
	if err != nil {
		return nil, err
	}

	//填充原文
	blockSize := block.BlockSize()
	rawData = pkcs7Padding(rawData, blockSize)
	//初始向量IV必须是唯一，但不需要保密
	cipherText := make([]byte, blockSize+len(rawData))
	//block大小 16
	iv := cipherText[:blockSize]
	if _, err := io.ReadFull(rand.Reader, iv); err != nil {
		return nil, err
	}

	//block大小和初始向量大小一定要一致
	mode := cipher.NewCBCEncrypter(block, iv)
	mode.CryptBlocks(cipherText[blockSize:], rawData)

	return cipherText, nil
}
</code></pre>
<p>解密是加密的逆过程，步骤如下：</p>
<ul>
<li>首先将数据按照<code>8</code>个字节一组进行分组得到<code>C1C2C3......Cn</code></li>
<li>将第一组数据进行解密后与初始化向量<code>I</code>进行异或得到第一组明文<code>D1</code>（注意：一定是先解密再异或）</li>
<li>将第二组数据<code>C2</code>进行解密后与第一组密文数据进行异或得到第二组数据<code>D2</code></li>
<li>之后依此类推，得到<code>Dn</code></li>
<li>按顺序连为<code>D1D2D3......Dn</code>即为解密结果</li>
</ul>
<pre><code class="language-go">func aesCBCDecrypt(encryptData, key []byte) ([]byte, error) {
	block, err := aes.NewCipher(key)
	if err != nil {
		return nil, err
	}

	blockSize := block.BlockSize()

	if len(encryptData) &lt; blockSize {
		return nil, errors.New(&quot;ciphertext too short&quot;)
	}
	iv := encryptData[:blockSize]
	encryptData = encryptData[blockSize:]

	// CBC mode always works in whole blocks.
	if len(encryptData)%blockSize != 0 {
		return nil, errors.New(&quot;ciphertext is not a multiple of the block size&quot;)
	}

	mode := cipher.NewCBCDecrypter(block, iv)

	// CryptBlocks can work in-place if the two arguments are the same.
	mode.CryptBlocks(encryptData, encryptData)
	//解填充
	encryptData = pkcs7UnPadding(encryptData)
	return encryptData, nil
}
</code></pre>
<p>这里要注意的是，解密的结果并不一定是我们原来的加密数据，可能还含有补位，一定要把补位去掉才是原来的数据</p>
<p>特点：</p>
<ul>
<li>不容易主动攻击,安全性好于<code>ECB</code>,适合传输长度长的报文,是<code>SSL</code>、<code>IPSec</code>的标准。每个密文块依赖于所有的信息块, 明文消息中一个改变会影响所有密文块</li>
<li>发送方和接收方都需要知道初始化向量</li>
<li>加密过程是串行的，无法被并行化（在解密时，从两个邻接的密文块中即可得到一个平文块。因此，解密过程可以被并行化）</li>
</ul>
<p>See you ~</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Golang与散列算法]]></title>
        <id>https://www.ssgeek.com/post/golang-yu-san-lie-suan-fa</id>
        <link href="https://www.ssgeek.com/post/golang-yu-san-lie-suan-fa">
        </link>
        <updated>2021-12-16T16:41:52.000Z</updated>
        <content type="html"><![CDATA[<p><ul class="markdownIt-TOC">
<li>
<ul>
<li><a href="#1-%E5%93%88%E5%B8%8C%E5%87%BD%E6%95%B0%E7%9A%84%E5%9F%BA%E6%9C%AC%E7%89%B9%E5%BE%81">1、哈希函数的基本特征</a></li>
<li><a href="#2-sha-1">2、SHA-1</a></li>
<li><a href="#3-md5">3、MD5</a>
<ul>
<li><a href="#31-%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8-%E7%9B%B4%E6%8E%A5%E8%AE%A1%E7%AE%97">3.1 基本使用-直接计算</a></li>
<li><a href="#32-%E5%A4%A7%E9%87%8F%E6%95%B0%E6%8D%AE-%E6%95%A3%E5%88%97%E8%AE%A1%E7%AE%97">3.2 大量数据-散列计算</a></li>
</ul>
</li>
<li><a href="#4-sha-1%E4%B8%8Emd5%E7%9A%84%E6%AF%94%E8%BE%83">4、SHA-1与MD5的比较</a></li>
<li><a href="#5-hmac">5、Hmac</a></li>
<li><a href="#6-%E5%93%88%E5%B8%8C%E5%87%BD%E6%95%B0%E7%9A%84%E5%BA%94%E7%94%A8">6、哈希函数的应用</a></li>
</ul>
</li>
</ul>
</p>
<figure data-type="image" tabindex="1"><img src="https://image.ssgeek.com/golang.png" alt=""></figure>
<p>散列是信息的提炼，通常其长度要比信息小得多，且为一个固定长度。加密性强的散列一定是不可逆的，这就意味着通过散列结果，无法推出任何部分的原始信息。任何输入信息的变化，哪怕仅一位，都将导致散列结果的明显变化，这称之为雪崩效应。散列还应该是防冲突的，即找不出具有相同散列结果的两条信息。具有这些特性的散列结果就可以用于验证信息是否被修改。常用于保证数据完整性</p>
<p>单向散列函数一般用于产生消息摘要，密钥加密等，常见的有</p>
<ul>
<li>MD5(Message Digest Algorithm 5)：是<code>RSA</code>数据安全公司开发的一种单向散列算法</li>
<li>SHA(Secure Hash Algorithm)：可以对任意长度的数据运算生成一个<code>160</code>位的数值</li>
</ul>
<h2 id="1-哈希函数的基本特征">1、哈希函数的基本特征</h2>
<p>哈希函数不是加密算法，其特征为单向性和唯一性</p>
<p>具体如下</p>
<ul>
<li>输入可以是任意长度</li>
<li>输出是固定长度</li>
<li>根据输入很容易计算出输出</li>
<li>根据输出很难计算出输入（几乎不可能）</li>
<li>两个不同的输入几乎不可能得到相同的输出</li>
</ul>
<h2 id="2-sha-1">2、SHA-1</h2>
<blockquote>
<p>https://golang.google.cn/pkg/crypto/sha1/</p>
</blockquote>
<p>在<code>1993</code>年，安全散列算法（SHA）由美国国家标准和技术协会(NIST)提出，并作为联邦信息处理标准（FIPS PUB 180）公布；<code>1995</code>年又发布了一个修订版<code>FIPS PUB 180-1</code>，通常称之为<code>SHA-1</code>。<code>SHA-1</code>是基于<code>MD4</code>算法的，并且它的设计在很大程度上是模仿<code>MD4</code>的。现在已成为公认的最安全的散列算法之一，并被广泛使用</p>
<p><code>SHA-1</code>是一种数据加密算法，该算法的思想是接收一段明文，然后以一种不可逆的方式将它转换成一段（通常更小）密文，也可以简单的理解为取一串输入码（称为预映射或信息），并把它们转化为长度较短、位数固定的输出序列即散列值（也称为信息摘要或信息认证代码）的过程<br>
该算法输入报文的最大长度不超过<code>264</code>位，产生的输出是一个<code>160</code>位的报文摘要。输入是按<code>512</code>位的分组进行处理的。<code>SHA-1</code>是不可逆的、防冲突，并具有良好的雪崩效应</p>
<p><code>sha1</code>是<code>SHA</code>家族的五个算法之一(其它四个是<code>SHA-224</code>、<code>SHA-256</code>、<code>SHA-384</code>，和<code>SHA-512</code>)</p>
<p><code>SHA（Secure Hash Algorithm）</code>安全散列算法，是一系列密码散列函数，有多个不同安全等级的版本：<code>SHA-1，SHA-224，SHA-256，SHA-384，SHA-512</code></p>
<p>防伪装，防窜扰，保证信息的合法性和完整性</p>
<p>算法流程：</p>
<ul>
<li>
<p>填充，使得数据长度对<code>512</code>求余的结果为<code>448</code></p>
</li>
<li>
<p>在信息摘要后面附加<code>64bit</code>，表示原始信息摘要的长度</p>
</li>
<li>
<p>初始化<code>h0</code>到<code>h4</code>，每个<code>h</code>都是<code>32</code>位</p>
</li>
<li>
<p><code>h0</code>到<code>h4</code>历经<code>80</code>轮复杂的变换</p>
</li>
<li>
<p>把<code>h0</code>到<code>h4</code>拼接起来，构成<code>160</code>位，返回</p>
</li>
</ul>
<p>常用函数</p>
<ul>
<li>New：创建Hash对象用于计算字节/字符<code>sha1</code>值</li>
<li>Sum：计算字节切片<code>sha1</code>值</li>
</ul>
<pre><code class="language-go">package main

import (
	&quot;crypto/sha1&quot;
	&quot;fmt&quot;
)

func main() {
	data := []byte(&quot;This page intentionally left blank.&quot;)
	fmt.Printf(&quot;%x\n&quot;, sha1.Sum(data))
}
</code></pre>
<p><code>sha256</code>、<code>sha512</code>同理</p>
<p>使用示例</p>
<pre><code class="language-go">package main

import (
	&quot;crypto/sha1&quot;
	&quot;fmt&quot;
	&quot;io&quot;
)
// sha1散列算法
func sha1Hash(msg string) (hashData []byte) {
	h := sha1.New()
	io.WriteString(h, msg)
	hashData = h.Sum(nil)
	return
}

func main() {
	msg := &quot;This is the message to hash!&quot;
	// sha1
	sha1Data := sha1Hash(msg)
	fmt.Printf(&quot;SHA1: %x\n&quot;, sha1Data)
}
</code></pre>
<h2 id="3-md5">3、MD5</h2>
<blockquote>
<p>https://golang.google.cn/pkg/crypto/md5/</p>
</blockquote>
<p><code>MD5</code>即<code>Message-Digest Algorithm 5</code>（信息-摘要算法5），用于确保信息传输完整一致。是计算机广泛使用的杂凑算法之一（又译摘要算法、哈希算法），主流编程语言普遍已有<code>MD5</code>实现。将数据（如汉字）运算为另一固定长度值，是杂凑算法的基础原理，<code>MD5</code>的前身有<code>MD2</code>、<code>MD3</code>和<code>MD4</code></p>
<ul>
<li>
<p>算法流程跟<code>SHA-1</code>大体相似</p>
</li>
<li>
<p><code>MD5</code>的输出是<code>128</code>位，比<code>SHA-1</code>短了<code>32</code>位</p>
</li>
<li>
<p><code>MD5</code>相对易受密码分析的攻击，运算速度比<code>SHA-1</code>快</p>
</li>
</ul>
<p>常用函数</p>
<ul>
<li>
<p>New：创建<code>Hash</code>对象用于计算字节/字符<code>md5</code>值</p>
</li>
<li>
<p>Sum：计算字节切片<code>md5</code>值</p>
</li>
</ul>
<pre><code class="language-go">import (
	&quot;crypto/md5&quot;
	&quot;fmt&quot;
)

func main() {
    // 最基础的使用方式: Sum 返回数据的MD5校验和
	fmt.Printf(&quot;%x\n&quot;, md5.Sum([]byte(&quot;测试数据&quot;)))
}
</code></pre>
<h3 id="31-基本使用-直接计算">3.1 基本使用-直接计算</h3>
<pre><code class="language-go">package main

import (
	&quot;crypto/md5&quot;
	&quot;encoding/hex&quot;
	&quot;fmt&quot;
)

func main() {
	// 结果是byte类型的数组
	bytes := md5.Sum([]byte(&quot;i am geek&quot;))
	// 转换为32位小写
	fmt.Printf(&quot;%x\n&quot;, bytes)  // 397f77c74db1e25084653531a8046f21
	// 转换为字符串
	x := fmt.Sprintf(&quot;%x\n&quot;, bytes)
	fmt.Println(x)  // 397f77c74db1e25084653531a8046f21
	fmt.Println(hex.EncodeToString(bytes[:]))  // 397f77c74db1e25084653531a8046f21
}
</code></pre>
<h3 id="32-大量数据-散列计算">3.2 大量数据-散列计算</h3>
<pre><code class="language-go">package main

import (
	&quot;crypto/md5&quot;
	&quot;fmt&quot;
)

func main() {
	// 较大时，分开批量计算
	m := md5.New()
	m.Write([]byte(&quot;i am&quot;))
	m.Write([]byte(&quot; geek&quot;))
	fmt.Printf(&quot;%x\n&quot;, m.Sum(nil))  // 397f77c74db1e25084653531a8046f21
}
</code></pre>
<h2 id="4-sha-1与md5的比较">4、SHA-1与MD5的比较</h2>
<p>因为二者均由<code>MD4</code>导出，<code>SHA-1</code>和<code>MD5</code>彼此很相似。相应的，他们的强度和其他特性也是相似，但还有以下几点不同：</p>
<ul>
<li>对强行供给的安全性：最显著和最重要的区别是<code>SHA-1</code>摘要比<code>MD5</code>摘要长<code>32</code>位。使用强行技术，产生任何一个报文使其摘要等于给定报摘要的难度对<code>MD5</code>是<code>2128</code>数量级的操作，而对<code>SHA-1</code>则是<code>2160</code>数量级的操作。这样，<code>SHA-1</code>对强行攻击有更大的强度。</li>
<li>对密码分析的安全性：由于<code>MD5</code>的设计，易受密码分析的攻击，<code>SHA-1</code>显得不易受这样的攻击。</li>
<li>速度：在相同的硬件上，<code>SHA-1</code>的运行速度比<code>MD5</code>慢</li>
</ul>
<h2 id="5-hmac">5、Hmac</h2>
<blockquote>
<p>https://golang.google.cn/pkg/crypto/hmac/</p>
</blockquote>
<p><code>Hmac</code>算法也是一种哈希算法，它可以利用<code>MD5</code>或<code>SHA1</code>等哈希算法。不同的是，<code>Hmac</code>还需要一个密钥, 只要密钥发生了变化，那么同样的输入数据也会得到不同的签名，因此，可以把<code>Hmac</code>理解为用随机数“增强”的哈希算法</p>
<p>常用函数</p>
<ul>
<li>New：创建<code>Hash</code>对象用于计算字节/字符<code>hmac</code>值</li>
<li>Equal：比较<code>hmac</code>值是否相等</li>
</ul>
<p><code>Hs256</code>实现</p>
<pre><code class="language-go">package main

import (
	&quot;crypto/hmac&quot;
	&quot;crypto/sha256&quot;
	&quot;fmt&quot;
	&quot;io&quot;
)

func main()  {
	key := []byte(&quot;1234567890abcdefg&quot;)
	// 创建hmac hash对象
	hash := hmac.New(sha256.New, key)
	// 写入字符串计算散列
	io.WriteString(hash, &quot;hi,geek&quot;)
	// 计算hmac散列
	fmt.Printf(&quot;%x\n&quot;, hash.Sum(nil))  // 89fda53d5e71e8c87adb15f8bf11c2c931af019a5c040321e243b82a3bb45ee5

	hash2 := hmac.New(sha256.New, key)
	hash2.Write([]byte(&quot;hi,geek&quot;))

	fmt.Println(hmac.Equal(hash2.Sum(nil), hash.Sum(nil)))  // true
}
</code></pre>
<p>使用示例</p>
<pre><code class="language-go">package main

import (
	&quot;crypto/hmac&quot;
	&quot;fmt&quot;
	&quot;io&quot;
)

// 使用sha1的Hmac散列算法
func hmacHash(msg string, key string) (hashData []byte) {
	k := []byte(key)
	mac := hmac.New(sha1.New, k)
	io.WriteString(mac, msg)
	hashData = mac.Sum(nil)
	return
}

func main() {
	msg := &quot;This is the message to hash!&quot;
	// hmac
	hmacData := hmacHash(msg, &quot;The key string!&quot;)
	fmt.Printf(&quot;HMAC: %x\n&quot;, hmacData)
}
</code></pre>
<h2 id="6-哈希函数的应用">6、哈希函数的应用</h2>
<ul>
<li>
<p>用户密码的存储</p>
</li>
<li>
<p>文件上传/下载完整性校验</p>
</li>
<li>
<p>mysql大字段的快速对比</p>
</li>
<li>
<p>数字签名（区块链，比特币）</p>
</li>
</ul>
<p>示例代码</p>
<pre><code class="language-go">package main

import (
	&quot;crypto/md5&quot;
	&quot;crypto/sha1&quot;
	&quot;encoding/hex&quot;
	&quot;fmt&quot;
)

func Sha1(data string) string {
	sha1 := sha1.New()
	sha1.Write([]byte(data))
	return hex.EncodeToString(sha1.Sum(nil))
}

func Md5(data string) string {
	md5 := md5.New()
	md5.Write([]byte(data))
	return hex.EncodeToString(md5.Sum(nil))
}

func main() {
	data := &quot;abcdefg&quot;
	fmt.Printf(&quot;SHA-1: %s\n&quot;, Sha1(data))
	fmt.Printf(&quot;MD5: %s\n&quot;, Md5(data))
}
</code></pre>
<p>一个实际的例子，用户名密码校验</p>
<p>密码校验则是一个很常见的问题, 当我们设计用户中心时，是一个必不可少的功能, 为了安全，我们都不会保存用户的明文密码, 最好的方式就是保存为<code>Hash</code>, 这样即使是数据泄露了，也不会导致用户的明文密码泄露(<code>hash</code>的过程是不可逆的)</p>
<p>示例需求如下</p>
<ul>
<li>能校验密码</li>
</ul>
<ul>
<li>用户可以修改密码</li>
<li>修改密码时，禁止使用最近已经使用过的密码</li>
</ul>
<pre><code class="language-go">// NewHashedPassword 生产hash后的密码对象
func NewHashedPassword(password string) (*Password, error) {
	bytes, err := bcrypt.GenerateFromPassword([]byte(password), 10)
	if err != nil {
		return nil, err
	}

	return &amp;Password{
		Password: string(bytes),
		CreateAt: ftime.Now().Timestamp(),
		UpdateAt: ftime.Now().Timestamp(),
	}, nil
}

type Password struct {
	// hash过后的密码
	Password string
	// 密码创建时间
	CreateAt int64
	// 密码更新时间
	UpdateAt int64
	// 密码需要被重置
	NeedReset bool
	// 需要重置的原因
	ResetReason string
	// 历史密码
	History []string
	// 是否过期
	IsExpired bool
}

// Update 更新密码
func (p *Password) Update(new *Password, maxHistory uint, needReset bool) {
	p.rotaryHistory(maxHistory)
	p.Password = new.Password
	p.NeedReset = needReset
	p.UpdateAt = ftime.Now().Timestamp()
	if !needReset {
		p.ResetReason = &quot;&quot;
	}
}

// IsHistory 检测是否是历史密码
func (p *Password) IsHistory(password string) bool {
	for _, pass := range p.History {
		err := bcrypt.CompareHashAndPassword([]byte(pass), []byte(password))
		if err == nil {
			return true
		}
	}

	return false
}

// HistoryCount 保存了几个历史密码
func (p *Password) HistoryCount() int {
	return len(p.History)
}

func (p *Password) rotaryHistory(maxHistory uint) {
	if uint(p.HistoryCount()) &lt; maxHistory {
		p.History = append(p.History, p.Password)
	} else {
		remainHistry := p.History[:maxHistory]
		p.History = []string{p.Password}
		p.History = append(p.History, remainHistry...)
	}
}

// CheckPassword 判断password 是否正确
func (p *Password) CheckPassword(password string) error {
	err := bcrypt.CompareHashAndPassword([]byte(p.Password), []byte(password))
	if err != nil {
		return exception.NewUnauthorized(&quot;user or password not connrect&quot;)
	}
	return nil
}
</code></pre>
<p>See you ~</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[任务执行龟速，原因竟然是......]]></title>
        <id>https://www.ssgeek.com/post/ren-wu-zhi-xing-gui-su-yuan-yin-jing-ran-shi</id>
        <link href="https://www.ssgeek.com/post/ren-wu-zhi-xing-gui-su-yuan-yin-jing-ran-shi">
        </link>
        <updated>2021-12-08T17:25:17.000Z</updated>
        <content type="html"><![CDATA[<p><ul class="markdownIt-TOC">
<li>
<ul>
<li><a href="#1-%E9%97%AE%E9%A2%98%E8%83%8C%E6%99%AF">1、问题背景</a></li>
<li><a href="#2-%E5%88%86%E6%9E%90%E5%92%8C%E5%A4%8D%E7%9B%98">2、分析和复盘</a>
<ul>
<li><a href="#21-%E7%BD%91%E7%BB%9C%E5%B8%A6%E5%AE%BD%E6%B5%8B%E8%AF%95">2.1 网络带宽测试</a></li>
<li><a href="#22-dns%E8%A7%A3%E6%9E%90%E6%B5%8B%E8%AF%95">2.2 dns解析测试</a></li>
<li><a href="#23-%E4%B8%9A%E5%8A%A1%E4%BB%A3%E7%A0%81%E6%8E%92%E6%9F%A5">2.3 业务代码排查</a></li>
<li><a href="#24-%E5%A4%9A%E6%96%B9%E5%AF%B9%E6%AF%94%E6%B3%95">2.4 多方对比法</a>
<ul>
<li><a href="#241-%E5%9F%BA%E7%A1%80%E9%95%9C%E5%83%8F">2.4.1 基础镜像</a></li>
<li><a href="#242-%E4%B8%8B%E8%BD%BD%E5%A4%96%E7%BD%91%E6%96%87%E4%BB%B6">2.4.2 下载外网文件</a></li>
</ul>
</li>
<li><a href="#25-%E7%9B%B4%E6%8E%A5%E4%B8%8B%E8%BD%BD%E6%B5%8B%E8%AF%95">2.5 直接下载测试</a></li>
</ul>
</li>
<li><a href="#3-%E9%97%AE%E9%A2%98%E5%AE%9A%E4%BD%8D">3、问题定位</a></li>
<li><a href="#4-%E9%97%AE%E9%A2%98%E5%88%86%E6%9E%90">4、问题分析</a></li>
<li><a href="#5-%E9%97%AE%E9%A2%98%E8%A7%A3%E5%86%B3">5、问题解决</a></li>
<li><a href="#6-%E5%B0%8F%E7%BB%93">6、小结</a></li>
</ul>
</li>
</ul>
</p>
<figure data-type="image" tabindex="1"><img src="https://image.ssgeek.com/20211209-01.png" alt="20211209-01"></figure>
<h2 id="1-问题背景">1、问题背景</h2>
<p>某天，业务同学反馈生产环境<code>k8s</code>集群中由核心服务创建的<code>Job</code>任务执行速度奇慢......</p>
<p>通过分析服务日志发现，该服务运行前期主要是执行请求数据交换服务，获取到<code>oss</code>对象存储的文件<code>url</code>后进行下载，下载完成后再执行其他任务</p>
<h2 id="2-分析和复盘">2、分析和复盘</h2>
<p>“服务好好的，怎么用着用着就慢了呢？” 旁边的xx开始发起了灵魂拷问</p>
<p>由于此问题偏故障型，首先想到的当然是秉承着“有报错，看日志”的宗旨，去看各方服务的日志</p>
<p>通过排查日志，均无错误，但现象就是日志慢而且卡顿</p>
<p>于是先判断是不是服务之间的网络出问题了</p>
<p>简单思考了下，与网络因素相关，再加上排除法，最小化可能的相关原因有如下</p>
<ul>
<li><code>pod</code>网卡</li>
<li>节点和<code>pod</code>网络检查</li>
<li>调度到不同节点的网卡对比</li>
<li>不同场景下网卡出入站带宽</li>
<li><code>dns</code>解析</li>
<li>节点资源综合对比</li>
<li><code>oss</code>服务端限流等策略核查</li>
<li>服务本身代码是否变更等等</li>
</ul>
<p>对照可能原因开始一一排查，如下列举一些相关的具体排查方法，其余就不再赘述了</p>
<h3 id="21-网络带宽测试">2.1 网络带宽测试</h3>
<p>对于网络带宽的测试，可以选用<code>ethtool</code>、<code>iperf</code>等工具，可以很方便的帮我们查看网卡相关信息，测试网络出站入站的带宽，顺便加上抓包工具</p>
<pre><code class="language-shell"># ethtool
Settings for eth0:
	Supported ports: [ ]
	Supported link modes:   Not reported
	Supported pause frame use: No
	Supports auto-negotiation: No
	Advertised link modes:  Not reported
	Advertised pause frame use: No
	Advertised auto-negotiation: No
	Speed: 10000Mb/s
	Duplex: Full
	Port: Twisted Pair
	PHYAD: 0
	Transceiver: internal
	Auto-negotiation: off
	MDI-X: Unknown
Cannot get wake-on-lan settings: Operation not permitted
	Link detected: yes

# iperf
Server listening on TCP port 5001
TCP window size: 12.0 MByte (default)
------------------------------------------------------------
[  4] local 10.244.155.34 port 5001 connected with 10.244.0.196 port 42148
[ ID] Interval       Transfer     Bandwidth
[  4] 0.0000-2.0000 sec  1.62 GBytes  6.97 Gbits/sec
[  4] 2.0000-4.0000 sec  1.15 GBytes  4.93 Gbits/sec
[  4] 4.0000-6.0000 sec  1.15 GBytes  4.93 Gbits/sec
[  4] 6.0000-8.0000 sec  1.14 GBytes  4.91 Gbits/sec
[  4] 8.0000-10.0000 sec  1.14 GBytes  4.91 Gbits/sec
[  4] 10.0000-12.0000 sec  1.14 GBytes  4.92 Gbits/sec
[  4] 12.0000-14.0000 sec  1.14 GBytes  4.89 Gbits/sec
[  4] 14.0000-16.0000 sec  1.14 GBytes  4.90 Gbits/sec
[  4] 16.0000-18.0000 sec  1.14 GBytes  4.88 Gbits/sec
[  4] 18.0000-20.0000 sec  1.14 GBytes  4.88 Gbits/sec
[  4] 20.0000-22.0000 sec  1.14 GBytes  4.89 Gbits/sec
[  4] 22.0000-24.0000 sec  1.14 GBytes  4.89 Gbits/sec
[  4] 24.0000-26.0000 sec  1.13 GBytes  4.87 Gbits/sec
[  4] 26.0000-28.0000 sec  1.14 GBytes  4.88 Gbits/sec
[  4] 28.0000-30.0000 sec  1.14 GBytes  4.91 Gbits/sec
[  4] 30.0000-32.0000 sec  1.14 GBytes  4.88 Gbits/sec
[  4] 32.0000-34.0000 sec  1.14 GBytes  4.89 Gbits/sec
[  4] 34.0000-36.0000 sec  1.14 GBytes  4.91 Gbits/sec
[  4] 36.0000-38.0000 sec  1.14 GBytes  4.88 Gbits/sec
[  4] 38.0000-40.0000 sec  1.14 GBytes  4.91 Gbits/sec
[  4] 40.0000-42.0000 sec  1.14 GBytes  4.90 Gbits/sec
[  4] 42.0000-44.0000 sec  1.14 GBytes  4.90 Gbits/sec
[  4] 44.0000-46.0000 sec  1.14 GBytes  4.90 Gbits/sec
[  4] 46.0000-48.0000 sec  1.14 GBytes  4.90 Gbits/sec
[  4] 48.0000-50.0000 sec  1.15 GBytes  4.93 Gbits/sec
[  4] 50.0000-52.0000 sec  1.14 GBytes  4.91 Gbits/sec
[  4] 52.0000-54.0000 sec  1.14 GBytes  4.92 Gbits/sec
[  4] 54.0000-56.0000 sec  1.14 GBytes  4.90 Gbits/sec
[  4] 56.0000-58.0000 sec  1.14 GBytes  4.88 Gbits/sec
[  4] 58.0000-60.0000 sec  1.14 GBytes  4.89 Gbits/sec
[  4] 60.0000-60.0201 sec  13.6 MBytes  5.69 Gbits/sec
[  4] 0.0000-60.0201 sec  34.7 GBytes  4.97 Gbits/sec
</code></pre>
<p>结果：无果</p>
<h3 id="22-dns解析测试">2.2 dns解析测试</h3>
<p>对于<code>dns</code>解析的测试，利用<code>dig</code>、<code>nslookup</code>工具分别选取了公网域名，内网域名，集群内域名分别测试进行对比，例如</p>
<pre><code class="language-shell">www.baidu.com
data.ssgeek.com
data-download.default.svc.cluster.local
</code></pre>
<p>结果：无果</p>
<h3 id="23-业务代码排查">2.3 业务代码排查</h3>
<p>针对于此业务，排查了其发布的版本，在出故障时并未发布新版本</p>
<p>服务是<code>python</code>语言写的，于是结合<code>sdk</code>对代码进行分析，将<code>oss</code>下载相关逻辑拆分出来，写成<code>python</code>脚本，单独调用<code>sdk</code>获得下载地址，然后进行下载流程，分别计算每一步骤执行的时间</p>
<p>结果：无果</p>
<h3 id="24-多方对比法">2.4 多方对比法</h3>
<h4 id="241-基础镜像">2.4.1 基础镜像</h4>
<p>由于有同类以<code>deployment</code>形式部署的对应服务，但在<code>deployment</code>的<code>pod</code>中下载没有任何问题</p>
<p>代码一样，开始怀疑是否因<code>job</code>任务使用的镜像与正常的镜像底层有关系</p>
<p>分别检查了对应的<code>Dockerfile</code>，发现<code>base</code>镜像及版本都不一样</p>
<p>于是将其变为同样的<code>base</code>镜像再次对比，任务执行时间还是有很大区别</p>
<p>结果：无果</p>
<h4 id="242-下载外网文件">2.4.2 下载外网文件</h4>
<p>排除了镜像问题，继续排除<code>oss</code>服务端的问题，于是分别通过<code>shell</code>让两边的<code>pod</code>去公网下载同样的大文件以及同样的小文件分别进行对比</p>
<p>结果：无果</p>
<p>到这里已经近乎<code>mb</code>了</p>
<p>这里也省略其他对比的一些措施</p>
<h3 id="25-直接下载测试">2.5 直接下载测试</h3>
<p>通过上面的一些<code>sao</code>操作，发现都没有明显效果，这对问题的排查增加了一定难度</p>
<p>于是乎，能不能抛开代码业务逻辑不谈，先一次性拿到所有需要下载文件的地址，然后手动通过原始的<code>shell</code>脚本去批量执行下载任务进行对比呢？当然</p>
<p>这里举例，用<code>shell</code>下载文件的脚本如下</p>
<pre><code class="language-shell">#/bin/bash

j=1
for i in `cat 1.txt`
do
    echo $j
    curl -s -o $j.jpg $i
    let j=j+1
done
# 1.txt为文件的url列表
</code></pre>
<h2 id="3-问题定位">3、问题定位</h2>
<p>通过上面最后一次通过<code>shell</code>脚本下载文件测试时发现：</p>
<p>在测试脚本刚开始启动时，程序会停顿几分钟，然后再开始执行下载任务，这意味着<code>bash</code>程序启动慢</p>
<p>换做<code>job</code>，<code>job</code>运行的<code>pod</code>执行的是一次性任务，因此和脚本执行是一样的，只是<code>k8s</code>层提供了这个脚本执行的载体，即<code>pod</code></p>
<p>我们可以用一个简单的命令组合，检查当前<code>bash</code>的执行时间，发现相比正常情况下要慢很多</p>
<pre><code class="language-shell"># time bash -c exit

real        0m0.004s
user        0m0.000s
sys         0m0.000s
</code></pre>
<h2 id="4-问题分析">4、问题分析</h2>
<p>通过进一步检查程序启动慢的资料发现，程序在启动之前往往会加载系统的环境变量</p>
<p>由于<code>pod</code>执行的是一次性任务，因此这种<code>job</code>的执行时间就包含了</p>
<ul>
<li>加载环境变量的时间</li>
<li>程序执行时间（包含网络请求、<code>io</code>读写、计算等）</li>
</ul>
<p>而普通的<code>pod</code>，在正常运行第一次启动时就已经加载了环境变量，所以当<code>pod</code>再次去执行某些任务时，已经不需要这一步骤了 ~</p>
<p>这样一来，当环境变量过多时，程序启动就会变慢</p>
<p>通过<code>env</code>命令，可以打印出<code>pod</code>内所有的环境变量</p>
<p>默认情况下<code>k8s</code>会为每个<code>pod</code>都注入除了自定义的环境变量以外的，这个<code>pod</code>所在命名空间下所有的公共环境变量</p>
<p>到这里，事情开始出现了转机，于是默默兴奋了一把</p>
<p>于是计算了一下环境变量个数，竟然高达<code>35000+</code>个环境变量，进一步排查发现，几乎<code>99%</code>的环境变量都是一个大量任务的相关服务的环境变量，这个服务会以<code>deployment</code>、<code>service</code>的命名不同，来创建很多个定义一样，命名不同的副本服务，进一步在集群中检查，此类服务的数量达<code>4500</code>多个</p>
<p>在谷歌<code>Google Kubernetes Engine (GKE)</code>中建议</p>
<p>每个命名空间的<code>Service</code>数不应超过<code>5000</code>。如超过此值，<code>Service</code>环境变量的数量会超出<code>shell</code>限制，导致<code>Pod</code>在启动时变慢甚至崩溃。在<code>Kubernetes 1.13</code>版本后，可以通过将<code>PodSpec</code>中的<code>enableServiceLinks</code>设置为<code>false</code>来停止填充这些变量</p>
<p>这个值在阿里云<code>Alibaba Cloud Container Service for Kubernetes (ACK)</code>的默认建议是<code>1000</code>个</p>
<p>即想要禁止注入无关环境变量的注入，从<code>Kubernetes 1.13</code>版本开始，可以声明<code>enableServiceLinks: false</code></p>
<p>更巧的是，默认创建的<code>pod</code>，这个<code>enableServiceLinks</code>选项是不可见（隐式）的，即使<code>-o yaml</code>也不会输出，但是默认值又给了<code>true</code>，这就让人很难察觉了</p>
<p>源码部分参考</p>
<p><code>pkg/apis/core/v1/defaults.go</code></p>
<pre><code class="language-go">if obj.Spec.EnableServiceLinks == nil {
	enableServiceLinks := v1.DefaultEnableServiceLinks
	obj.Spec.EnableServiceLinks = &amp;enableServiceLinks
}
</code></pre>
<p><code>k8s.io/api/core/v1/types.go</code></p>
<pre><code class="language-go">const (
	// The default value for enableServiceLinks attribute.
	DefaultEnableServiceLinks = true
)
</code></pre>
<h2 id="5-问题解决">5、问题解决</h2>
<p>最终通过在<code>job</code>的定义中添加了这个参数的默认值，新创建的<code>pod</code>的就仅剩不到<code>30</code>个环境变量</p>
<p>修改创建<code>job</code>的相关代码<code>job_scheduler.go</code></p>
<pre><code class="language-go">var (
    ...
	jobTaskK8sEnableServiceLinks = false
)
...
targetJob.Spec.Template.Spec.EnableServiceLinks = &amp;jobTaskK8sEnableServiceLinks
...
</code></pre>
<p>再次部署新的服务并在相同场景下测试，下载速度恢复如常，问题得以解决~</p>
<h2 id="6-小结">6、小结</h2>
<p>小结一下，本文记录复盘的是一次<code>k8s</code>集群相关的生产故障</p>
<p>随着服务增多，集群的庞大，一些未知问题就必然会出现（而如果集群规模较小，也就基本不会遇到了）</p>
<p>对于一开始未知原因、诡异、没有思路的问题或者<code>bug</code>，往往利用穷举法列出所有可能的原因，然后采取最小化复现、差异化对比等等，基本能解决大部分这类问题</p>
<blockquote>
<p>今日发文试着标题党了一波，吸引一波阅读率，哈哈希望不要被喷，下次不会了0.0</p>
<p>参考<br>
https://github.com/kubernetes/kubernetes/issues/92226<br>
https://cloud.google.com/kubernetes-engine/docs/best-practices/scalability<br>
https://mozillazg.com/2020/06/kubernetes-k8s-too-many-service-environment-variables-cause-pod-container-start-bash-too-slow.html</p>
</blockquote>
<p>See you ~</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[基于ack k8s集群调度的方案设计]]></title>
        <id>https://www.ssgeek.com/post/ji-yu-ack-k8s-ji-qun-diao-du-de-she-ji-fang-an</id>
        <link href="https://www.ssgeek.com/post/ji-yu-ack-k8s-ji-qun-diao-du-de-she-ji-fang-an">
        </link>
        <updated>2021-11-29T16:22:34.000Z</updated>
        <content type="html"><![CDATA[<p><ul class="markdownIt-TOC">
<li>
<ul>
<li><a href="#1-%E6%A6%82%E8%BF%B0">1、概述</a></li>
<li><a href="#2-%E5%8E%9F%E7%94%9F%E8%B0%83%E5%BA%A6%E5%8E%9F%E5%88%99">2、原生调度原则</a>
<ul>
<li><a href="#21-%E8%B0%83%E5%BA%A6%E6%B5%81%E7%A8%8B">2.1 调度流程</a></li>
<li><a href="#22-%E8%B0%83%E5%BA%A6%E7%AD%96%E7%95%A5">2.2 调度策略</a></li>
</ul>
</li>
<li><a href="#3-%E5%BA%94%E7%94%A8%E5%92%8C%E6%9C%8D%E5%8A%A1%E6%A6%82%E5%86%B5">3、应用和服务概况</a></li>
<li><a href="#4-%E9%98%BF%E9%87%8C%E4%BA%91%E9%9B%86%E7%BE%A4%E6%A6%82%E5%86%B5">4、阿里云集群概况</a>
<ul>
<li><a href="#41-%E9%9B%86%E7%BE%A4%E6%A6%82%E5%86%B5">4.1 集群概况</a></li>
<li><a href="#41-node%E8%8A%82%E7%82%B9%E7%9A%84%E8%A7%84%E5%88%92">4.1 node节点的规划</a>
<ul>
<li><a href="#411-%E9%98%BF%E9%87%8C%E4%BA%91ecs%E4%BB%8B%E7%BB%8D">4.1.1 阿里云ecs介绍</a></li>
<li><a href="#412-k8s%E9%9B%86%E7%BE%A4%E8%8A%82%E7%82%B9%E9%80%89%E5%9E%8B%E5%8E%9F%E5%88%99">4.1.2 k8s集群节点选型原则</a></li>
<li><a href="#413-k8s%E9%9B%86%E7%BE%A4%E8%8A%82%E7%82%B9%E6%B1%A0%E8%AE%BE%E8%AE%A1">4.1.3 k8s集群节点池设计</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#5-%E8%B0%83%E5%BA%A6%E7%AD%96%E7%95%A5%E7%9A%84%E8%AE%BE%E8%AE%A1">5、调度策略的设计</a>
<ul>
<li><a href="#51-%E5%8E%9F%E7%94%9F%E8%B0%83%E5%BA%A6%E7%B1%BB%E5%9E%8B%E7%9A%84%E5%8F%96%E8%88%8D">5.1 原生调度类型的取舍</a></li>
<li><a href="#52-%E5%B1%80%E9%83%A8%E6%9C%80%E4%BC%98%E8%A7%A3%E7%90%86%E8%AE%BA">5.2 局部最优解理论</a></li>
<li><a href="#53-%E7%BB%93%E5%90%88%E6%9C%8D%E5%8A%A1%E7%89%B9%E6%80%A7%E7%9A%84%E8%B0%83%E5%BA%A6%E5%8E%9F%E5%88%99">5.3 结合服务特性的调度原则</a></li>
<li><a href="#54-%E5%BA%94%E7%94%A8%E5%88%86%E7%B1%BB%E6%A0%87%E5%87%86">5.4 应用分类标准</a></li>
</ul>
</li>
<li><a href="#6-%E5%B1%95%E6%9C%9B">6、展望</a></li>
</ul>
</li>
</ul>
</p>
<figure data-type="image" tabindex="1"><img src="https://image.ssgeek.com/20211130-01.png" alt=""></figure>
<blockquote>
<p>名词说明：本文提到的<code>k8s</code>集群特指阿里云<code>ack</code>（Alibaba Cloud Container Service for Kubernetes）集群</p>
</blockquote>
<h2 id="1-概述">1、概述</h2>
<p><code>Kubernetes</code>解决了应用的编排、生命周期、自我健康检查和恢复等问题，随着应用容器化（云原生化）的不断完善和落地，方方面面需要考虑的问题也就随之而来</p>
<p>其中应用的调度不乏重要，其关乎着应用的稳定性、资源利用率的完整性与合理性</p>
<h2 id="2-原生调度原则">2、原生调度原则</h2>
<p><code>Kubernetes API Server</code>接受客户端提交<code>Pod</code>对象创建请求后的操作过程中，一个重要的步骤是由调度器程序<code>kube-scheduler</code>从当前集群中选择一个可用的最佳节点来接收井运行它，通常是默认的调度器<code>default-scheduler</code>负责执行此类任务</p>
<pre><code class="language-shell">KIND:     Deployment
VERSION:  apps/v1

FIELD:    schedulerName &lt;string&gt;

DESCRIPTION:
     If specified, the pod will be dispatched by specified scheduler. If not
     specified, the pod will be dispatched by default scheduler.
</code></pre>
<p>设计调度需要考虑的因素：单独和整体的资源请求、硬件/软件/策略限制、亲和以及反亲和要求、数据局域性、负载间的干扰等等</p>
<p><code>k8s</code>调度机制是<code>k8s</code>原生提供的一种高效优雅的资源分配机制，它的核心功能是为每个<code>Pod</code>找到最适合它的节点，通过合理利用<code>k8s</code>原生提供的调度能力，根据业务特性配置合理的调度策略，能有效提高集群中的资源利用率</p>
<h3 id="21-调度流程">2.1 调度流程</h3>
<p>原生的调度流程整体上分为以下三步</p>
<ul>
<li>
<p>预选（过滤）——选出可以调度的节点</p>
</li>
<li>
<p>优选（打分）——对选出的节点进行排序</p>
</li>
<li>
<p>选定——按照<code>pod</code>优先级选定调度的节点</p>
</li>
</ul>
<h3 id="22-调度策略">2.2 调度策略</h3>
<p>常见的原生调度策略整体上也分为以下几种类型</p>
<ul>
<li>
<p>Topology——拓扑域调度：例如域（<code>Region</code>）、可用区（<code>Zone</code>）进行拓扑划分</p>
</li>
<li>
<p>nodeName——选定节点调度：直接指定<code>Node</code>主机名进行调度（点对点）</p>
</li>
<li>
<p>NodeSelector——节点选择器调度：节点标签选择器调度</p>
</li>
<li>
<p>NodeAffinity——节点亲和性调度：针对<code>pod</code>和<code>node</code>之间的调度关系，分为硬亲和和软亲和</p>
</li>
<li>
<p>podAffinity——Pod亲和性调度：针对<code>pod</code>和<code>pod</code>之间的调度关系，也分为硬亲和、软亲和和反亲和</p>
</li>
<li>
<p>Priority、QoS——优先和抢占调度：按照<a href="https://kubernetes.io/zh/docs/concepts/scheduling-eviction/pod-priority-preemption/">优先级</a>（<code>Priority</code>）和<a href="https://kubernetes.io/zh/docs/tasks/configure-pod-container/quality-service-pod/">服务质量等级</a>（<code>QoS</code>）两种维度进行调度</p>
</li>
<li>
<p>Taint、Toleration——污点和容忍调度：节点拒绝<code>Pod</code>调度（污点）和<code>Pod</code>能接纳节点污点（容忍）两个维度</p>
</li>
</ul>
<h2 id="3-应用和服务概况">3、应用和服务概况</h2>
<p>应用按照服务用途维度划分主要分为两类：普通<code>service</code>类型和<code>worker</code>类型，其中分别包含</p>
<p>普通<code>service</code>类型</p>
<ul>
<li>有状态服务：少数服务，如<code>mysql</code>、<code>redis</code></li>
<li>无状态服务：多数服务</li>
</ul>
<p><code>worker</code>类型</p>
<ul>
<li>普通<code>worker</code>服务</li>
<li><code>gpu</code>型<code>worker</code>服务</li>
</ul>
<p>按照应用使用的资源类别划分，可对应用大致分为以下几类</p>
<ul>
<li>通用计算
<ul>
<li><code>CPU</code>计算密集型：大量计算，消耗<code>CPU</code>资源</li>
<li><code>IO</code>密集型：网络、磁盘<code>IO</code>要求高</li>
<li>通用型：对<code>CPU</code>和<code>IO</code>要求相对适中</li>
</ul>
</li>
<li>异构计算
<ul>
<li><code>GPU</code>计算型：深度学习训练</li>
<li><code>GPU</code>虚拟化型：图形和图像处理</li>
</ul>
</li>
<li>某些特殊领域和用途的服务：例如高主频、高内存等等</li>
</ul>
<h2 id="4-阿里云集群概况">4、阿里云集群概况</h2>
<h3 id="41-集群概况">4.1 集群概况</h3>
<p>本文的<code>kubernetes</code>集群都是由阿里云<code>ack</code>托管的，其中包含了<code>ACK Pro</code>版和边缘 <code>Pro</code> 版两种类型的集群</p>
<p>边缘 <code>Pro</code> 版主要是涉及云上云下的<code>GPU</code>节点混合部署的集群</p>
<p>本文仅讨论<code>ACK Pro</code>集群（其中<code>Master</code>节点由阿里云容器服务创建并托管）</p>
<h3 id="41-node节点的规划">4.1 node节点的规划</h3>
<h4 id="411-阿里云ecs介绍">4.1.1 阿里云ecs介绍</h4>
<p>选择服务器的硬件资源配置就和我们购买办公或个人<code>PC</code>、笔记本一样，主要需要考虑主板、<code>CPU</code>、内存、硬盘等硬件配置</p>
<p><code>CPU</code>与内存通信，主要通过地址、数据、控制三大总线</p>
<p>先简单了解一下<code>CPU</code>核数与内存的配比主要要遵守的基本原则</p>
<ul>
<li>频率要同步：内存的核心频率要等于或稍大于<code>CPU</code>的外频</li>
<li>带宽要匹配：内存的数据带宽跟<code>CPU</code>前端总线的带宽尽量相等</li>
<li>主板要调控：当以上两个条件有时是不可能同时能满足时就要靠主板通过异步设置来调控</li>
</ul>
<p>通常<code>CPU</code>和内存的配比是<code>1:2</code>、<code>1:4</code>、<code>1:8</code>，至于为什么，这也是一个值得讨论的话题</p>
<p>阿里云<code>ack</code>将集群的<code>master</code>节点托管了，因此只需要考虑如何规划<code>node</code>节点。由于是“花钱”买服务，当然要本着较高“性价比”的原则去合理搭配<code>node</code>节点的选型和配比</p>
<p>节点即虚拟机，在阿里云也叫做<code>ECS</code>，先来看下目前阿里云通用的<code>x86</code>节点有哪些种类，在阿里云官网将<code>ECS</code>实例分为很多种：通用型、计算型、内存型、大数据型、本地<code>SSD</code>型、高主频型、安全增强型、<code>GPU</code>型、异构服务型、突发型、共享型等等（简直太多了）</p>
<p>为了合理选型，一个重要的途径是理解<code>ECS</code>的实例规格族的命名方式和其信息布局，常见的如下</p>
<ul>
<li>
<p>通用型，适用于大多数场景，代称是<code>g</code>系列，其<code>vCPU</code>和内存的配比是<code>1:4</code></p>
</li>
<li>
<p>计算型，某些场景下对<code>CPU</code>算力要求会更高一点，代称是<code>c</code>系列，其<code>vCPU</code>和内存的配比是<code>1:2</code></p>
</li>
<li>
<p>内存型，提供更多的内存能力，代称是<code>r</code>系列，其<code>vCPU</code>和内存的配比是<code>1:8</code></p>
</li>
<li>
<p>大数据型和本地<code>SSD</code>型，这两种的CPU和内存的配比都是<code>1:4</code>，区别在于本地盘的类型不一样，导致适合的场景也是不一样的，大数据型的简称是<code>d</code>，本地<code>SSD</code>型简称是<code>i</code></p>
</li>
<li>
<p>高主频型，通常的<code>CPU</code>的主频应该是<code>2.5G</code>赫兹，有一些可以是达到<code>3.2G</code>赫兹甚至更高，这种就是高主频型，代号会在前面加上<code>hf</code>标识</p>
</li>
</ul>
<p>阿里云实例规格的命名方式和规律如下</p>
<figure data-type="image" tabindex="2"><img src="https://image.ssgeek.com/20211126-01.png" alt=""></figure>
<p>实例选型原则通常遵循下面三点</p>
<ul>
<li>相同大小的企业级实例比入门级实例性能更稳定，但入门级实例性价比更高，因为企业级实例独占<code>vCPU</code>，不存在资源争抢</li>
<li>相同实例规格，新一代比老一代性价比更高，新一代实例规格释放更多技术红利</li>
<li>合适的实例规格搭配合适的块存储类型才能达到预期性能（高效云盘/<code>SSD</code>/<code>ESSD</code>/本地盘）</li>
</ul>
<h4 id="412-k8s集群节点选型原则">4.1.2 k8s集群节点选型原则</h4>
<p><code>k8s</code>集群节点如何选型？</p>
<p>从<code>CPU</code>为出发点，<code>CPU</code>选定的同时，按照一定配比的内存大小也相应确定</p>
<p>节点区分标准线的划定。<code>vCPU</code>的个数是决定实例价格的关键，<code>vCPU</code>个数实例的一个<code>xlarge</code>单位代表<code>4</code>个<code>vCPU</code>，以<code>8xlarge</code>即<code>32</code>个<code>vCPU</code>为分界线，小于<code>32</code>个<code>vCPU</code>的实例划分为较小<code>CPU</code>核数即<code>small</code>节点，把大于或等于<code>32</code>个<code>vCPU</code>的实例划分为较大<code>CPU</code>核数即<code>large</code>节点</p>
<p>但是，需要购买分别高、低至多少个<code>vCPU</code>的节点作为<code>k8s</code>集群的<code>node</code>呢？换句话说，是使用更少的大节点还是使用更多的小节点来组建<code>k8s</code>集群呢？</p>
<p>可以把整个<code>k8s</code>集群中所有<code>node</code>组成的节点理解成为一个大型的单个节点，换句话说，这就和一台价格昂贵全部满配的物理机一样，其<code>node</code>节点就是这台物理机虚拟出来的<code>VM</code></p>
<p>举个栗子，需要一个节点池总量为<code>64C/256GB</code>的集群，考虑<code>k8s</code>需要多节点，因此两个比较极端的配比是<code>2</code>台<code>32C/128GB</code>的较大节点和<code>8</code>台<code>8C/32GB</code>的较小节点</p>
<p>这里对大节点和小节点的优缺点分析和列举了以下几点</p>
<ul>
<li>大节点个数总量较少，带来的管理成本会更少</li>
<li>大节点支持资源使用较高的“饥饿”型应用，即资源消耗较高的应用</li>
<li>发生<code>node</code>节点级别的扩缩容时，大节点成本更高，因为一次就需要扩容配置较高的节点</li>
<li>大节点每个节点运行的<code>pod</code>数较多，相应的<code>k8s</code>组件压力更大，当出现大批量<code>pod</code>频繁创建销毁时，组件性能、时效性和可靠性都会下降，因此<code>k8s</code>官方推荐的节点<code>pod</code>最大数默认为<code>110</code></li>
<li>大节点<code>pod</code>副本分布更集中，由于节点数量减少，在同一个节点出现相关<code>pod</code>副本的可能性增大，当出现故障时，对<code>pod</code>影响较大。如果<code>pod</code>副本数更少，那么对整个应用来说，故障率和中断率也更高</li>
<li>按照阿里云<a href="https://help.aliyun.com/document_detail/330995.html">资源预留公式</a>推算的预留资源更多，大节点相对可分配给<code>pod</code>的资源总量就会变少</li>
</ul>
<figure data-type="image" tabindex="3"><img src="https://image.ssgeek.com/20211126-02.png" alt=""></figure>
<p>说到这里，到底是该使用少量大节点还是大量小节点呢？按照上面的分析，各有利弊，因此并没有一定之规</p>
<p>退而求其次，可以均衡搭配，使用不同大小的节点来混合构建集群，对于某些特殊的服务，还可以单独做节点池</p>
<p>另外，对于<code>worker</code>任务型服务，充分利用云平台弹性伸缩能力，选用抢占式实例，更节省成本</p>
<p><code>k8s</code>集群初始化创建时，会创建一个默认的节点池<code>default-nodepool</code>，一般会选择<code>3</code>台中等配置的<code>ECS</code>实例</p>
<p>往往为了应用在不同环境的隔离，在资源足够的情况下，会将<code>dev</code>、<code>staging</code>、<code>prod</code>等不同环境放在各自不同的集群中，当然也可以将<code>prod</code>生产环境单独做集群，<code>dev</code>和<code>staging</code>环境放在一套集群，这样成本更低</p>
<p>剩下就是根据应用的特点、成本设计与规划节点池</p>
<h4 id="413-k8s集群节点池设计">4.1.3 k8s集群节点池设计</h4>
<p>根据服务特性规划出不同的节点池，混合组建成集群，有助于集群资源利用率的提高</p>
<p>使用抢占式策略，并结合利用了公有云的弹性伸缩能力，用于自动扩缩集群节点数量，以真正实现资源利用率的提升，可以在较大程度上优化用户账单</p>
<p>根据业务现有相关服务的类型特点，加上合理考虑成本与收费类型的前提，加上默认的节点池，将节点池分为以下几类</p>
<table>
<thead>
<tr>
<th>节点池类型</th>
<th>适用环境</th>
<th>付费策略</th>
<th>节点池/节点命名</th>
<th>资源配额</th>
<th>服务特点</th>
</tr>
</thead>
<tbody>
<tr>
<td>系统节点池</td>
<td>prod nonprod</td>
<td>包年包月</td>
<td><code>default-nodepool</code></td>
<td></td>
<td>适用于部署<code>k8s</code>集群系统组件</td>
</tr>
<tr>
<td>稳定型节点池</td>
<td>prod nonprod</td>
<td>包年包月</td>
<td><code>${env}-packets</code></td>
<td><code>32C/128GB/500GB</code></td>
<td>适用于副本数相对稳定，资源要求相对适中，稳定性要求相对较高，版本迭代速率相对较小的核心服务</td>
</tr>
<tr>
<td>大磁盘型节点</td>
<td>prod</td>
<td>包年包月</td>
<td><code>${env}-disk-large</code></td>
<td><code>32C/256GB/5TB</code></td>
<td>适用于对磁盘读写空间较大的服务</td>
</tr>
<tr>
<td></td>
<td>nonprod</td>
<td>包年包月</td>
<td><code>${env}-disk-large</code></td>
<td><code>16C/128GB/2TB</code></td>
<td>适用于对磁盘读写空间较大的服务</td>
</tr>
<tr>
<td>大配置节点</td>
<td>prod nonprod</td>
<td>抢占式</td>
<td><code>${env}-large</code></td>
<td><code>32C/128GB/500GB</code> <code>32C/256GB/500GB</code></td>
<td>适用于<code>CPU/Mem</code>资源要求较大的<code>worker</code>类型服务</td>
</tr>
<tr>
<td>小配置节点</td>
<td>prod nonprod</td>
<td>抢占式</td>
<td><code>${env}-small</code></td>
<td><code>16C/64GB/300GB</code></td>
<td>适用于<code>CPU/Mem</code>资源要求较小的<code>worker</code>类型服务</td>
</tr>
<tr>
<td>大配置较大磁盘节点</td>
<td>prod</td>
<td>抢占式</td>
<td><code>${env}-medium-disk-large</code></td>
<td><code>32C/256GB/1TB</code></td>
<td>适用于<code>CPU/Mem/Disk</code>资源要求较大的<code>worker</code>类型服务</td>
</tr>
<tr>
<td></td>
<td>nonprod</td>
<td>抢占式</td>
<td><code>${env}-medium-disk-large</code></td>
<td><code>32C/128GB/500GB</code></td>
<td>适用于<code>CPU/Mem/Disk</code>资源要求较大的<code>worker</code>类型服务</td>
</tr>
</tbody>
</table>
<h2 id="5-调度策略的设计">5、调度策略的设计</h2>
<h3 id="51-原生调度类型的取舍">5.1 原生调度类型的取舍</h3>
<p>有了规划出的不同节点池，就需要根据每个应用的特性，基于原生的调度原则进行调度，但是原生的调度也相对多样，如何取舍，还是都用？（不是小孩子，当然不能全都要）</p>
<p>例如应用的<code>pod</code>之间还没有很明显的亲和性及反亲和性需求，也还没有严格的网络入站出站限制的需求，不同节点也都处于云网络的各个交换机组成的大型子网内</p>
<p>因此，不采用拓扑域、<code>Pod</code>亲和性调度这两种调度方式</p>
<p>对于<code>nodeName</code>调度，比较单一，也不采用</p>
<p>对于优先和抢占调度，目前也还没有严格意义上区分服务的优先等级，因为可以认为每个服务都是整个业务不可缺少的一环。换句话说，目前对于服务的优先级还没有明确的评判标准。因此服务质量<code>QoS</code>采用最高的优先级即<code>Guaranteed</code>，其要求<code>Pod</code>里的每个容器都必须有<code>CPU</code>和内存的<code>request</code>和<code>limit</code>，而且值必须相等</p>
<p>对于<code>NodeSelector</code>和<code>NodeAffinity</code>，后者更为灵活，具有优先调度的功能，其组合方式有两种，硬亲和和软亲和，其判断亲和性的计算方法也多样，不仅是等值匹配，相当于升级版本的<code>NodeSelector</code>。<code>NodeAffinity</code>适用于让<code>Pod</code>调度到某些节点上，以及不想让<code>pod</code>调度到某些节点上，而且如果节点设置了<code>Label</code>，但是<code>Pod</code>没有任何的<code>NodeAffinity</code>设置，那么<code>Pod</code>还是可以调度到这些节点上的</p>
<p>另外一方面，如果集群中的节点有多种类别，使用<code>NodeAffinity</code>对某一类节点做<code>label</code>，目的是想让某些<code>pod</code>调度到这些节点。而如果<code>pod</code>没有标识亲和性调度，那么<code>pod</code>有可能调度到集群中其他的节点，这种情况下结果是不可控的，因为总不可能所有节点都标识同样的亲和性</p>
<p><code>NodeAffinity</code>亲和性的设计本身就是为了拉近在调度时<code>pod</code>和<code>node</code>之间的距离，但又没有办法避免上面的问题，于是就有了污点和容忍</p>
<p>污点的特点是，常用在某个或某些<code>Node</code>不让大多数<code>Pod</code>调度而只让少部分<code>Pod</code>调度</p>
<p>对于<code>Taint</code>和<code>Toleration</code>，出发点一个在于<code>Node</code>，一个在于<code>Pod</code>，其组合方式有以下几种</p>
<table>
<thead>
<tr>
<th>Node污点</th>
<th>Pod容忍</th>
<th>是否调度成功</th>
<th>原因</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>PreferNoSchedule</code></td>
<td><code>PreferNoSchedule</code></td>
<td>是</td>
<td><code>node</code>的污点与<code>pod</code>的容忍相匹配</td>
</tr>
<tr>
<td><code>PreferNoSchedule</code></td>
<td><code>NoSchedule</code></td>
<td>是</td>
<td><code>node</code>的污点低于<code>pod</code>的容忍</td>
</tr>
<tr>
<td><code>PreferNoSchedule</code></td>
<td><code>NoExecute</code></td>
<td>是</td>
<td><code>node</code>的污点低于<code>pod</code>的容忍</td>
</tr>
<tr>
<td><code>NoSchedule</code></td>
<td><code>PreferNoSchedule</code></td>
<td>否</td>
<td><code>node</code>的污点高于<code>pod</code>的容忍</td>
</tr>
<tr>
<td><code>NoSchedule</code></td>
<td><code>NoSchedule</code></td>
<td>是</td>
<td><code>node</code>的污点与<code>pod</code>的容忍相匹配</td>
</tr>
<tr>
<td><code>NoSchedule</code></td>
<td><code>NoExecute</code></td>
<td>否</td>
<td><code>node</code>的污点与<code>pod</code>的容忍互逆</td>
</tr>
<tr>
<td><code>NoExecute</code></td>
<td><code>PreferNoSchedule</code></td>
<td>否</td>
<td><code>node</code>的污点高于<code>pod</code>的容忍</td>
</tr>
<tr>
<td><code>NoExecute</code></td>
<td><code>NoSchedule</code></td>
<td>否</td>
<td><code>node</code>的污点高于<code>pod</code>的容忍</td>
</tr>
<tr>
<td><code>NoExecute</code></td>
<td><code>NoExecute</code></td>
<td>否</td>
<td><code>pod</code>会不断重建和杀掉</td>
</tr>
</tbody>
</table>
<p>由上述分析可得</p>
<p><code>Node</code>如果打上<code>PreferNoSchedule</code>的污点，那么<code>Pod</code>只要配置了容忍都会被调度上，甚至于没有设置任何污点容忍的<code>Pod</code>也能调度到此节点上。原因在于<code>PreferNoSchedule</code>的意思是优先不调度，但是当没有节点可用时<code>Pod</code>仍然能调度到此节点</p>
<p><code>Node</code>如果打上<code>NoExecute</code>的污点，那么<code>Pod</code>只要配置了容忍都会被调度上</p>
<p>因此<code>Node</code>的污点类型为<code>NoSchedule</code>，对于不同的节点池，打上不同的污点，例如<code>large:true :NoSchedule</code></p>
<p>为了规范，对于<code>pod</code>来说，容忍度的操作符统一使用<code>Equal</code>属性。然后根据不同节点池的污点设置对应的容忍，例如</p>
<pre><code class="language-yaml">tolerations:
- effect: NoSchedule
  key: large
  operator: Equal
  value: 'true'
</code></pre>
<h3 id="52-局部最优解理论">5.2 局部最优解理论</h3>
<p>局部最优，是在工程设计中经常采用的理论，指对于一个问题的解在一定范围或区域内最优，或者说解决问题或达成目标的手段在一定范围或限制内最优</p>
<p>例如往往对于应用的优化是没有天花板的，拿到调度方案的设计来说也是一样，因为多种方案最终还是要为业务服务，随着业务的复杂性、变化性会不断变化，这种情况下会更容易实现和接收在某些局部条件下最优（更优）的方案</p>
<p>局部最优解的质量不一定都是差的。尤其是当有了确定的评判标准标明得出的解是可以接受的话，通常会接收局部最优的结果。这样，从成本、效率等多方面考虑，才是实际工程中会采取的策略</p>
<figure data-type="image" tabindex="4"><img src="https://image.ssgeek.com/20211126-03.png" alt=""></figure>
<h3 id="53-结合服务特性的调度原则">5.3 结合服务特性的调度原则</h3>
<p>基于对上面原生调度类型的分析及取舍，可以认为每个不同节点池即每一类节点都算作稀缺资源，通常应该不允许或者不建议对不符合的服务进行调度，也就是每一类节点都应该是被特定调度的。因为有了对应的服务我们才去合理取材，选择对应特性的节点，这也直接和用户的账单挂钩并且占比非常大</p>
<p>另外一方面，集群没有多租户，没有严格的应用隔离性要求</p>
<p>结合应用特性，目前采用的调度主要结合<code>nodeSelector</code>、<code>Taint</code>及<code>Toleration</code>，规范如下</p>
<p>按照节点池的分类，分别给<code>node</code>打上了以下污点</p>
<table>
<thead>
<tr>
<th>节点池</th>
<th>标签（label）</th>
<th>污点（Taints）</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>${env}-packets</code></td>
<td><code>packets:true</code></td>
<td><code>packets:true :NoSchedule</code></td>
</tr>
<tr>
<td><code>${env}-disk-large</code></td>
<td><code>disk-large:true</code></td>
<td><code>disk-large:true :NoSchedule</code></td>
</tr>
<tr>
<td><code>${env}-large</code></td>
<td><code>workload_type:spot</code> <code>prod:true</code></td>
<td><code>prod:true :NoSchedule</code>                                          <code>large:true :NoSchedule</code></td>
</tr>
<tr>
<td><code>${env}-small</code></td>
<td><code>workload_type:spot</code> <code>prod:true</code></td>
<td><code>prod:true :NoSchedule</code>                                          <code>small:true :NoSchedule</code></td>
</tr>
<tr>
<td><code>${env}-medium-disk-large</code></td>
<td><code>workload_type:spot</code>            <code>medium-disk-large:true</code></td>
<td><code>medium-disk-large:true :NoSchedule</code></td>
</tr>
</tbody>
</table>
<p>服务调度规范，根据上述<code>node</code>标签和污点，在对应服务的<code>pod</code>中分别对应需要如下的<code>nodeSelector</code>和<code>tolerations</code></p>
<pre><code class="language-yaml"># 调度到packets节点池的节点
nodeSelector:
  packets: 'true'
tolerations:
- effect: NoSchedule
  key: packets
  operator: Equal
  value: 'true'

---
# 调度到disk-large节点池的节点
nodeSelector:
  disk-large: 'true'
tolerations:
- effect: NoSchedule 
  key: disk-large 
  operator: Equal 
  value: 'true'

---
# 调度到large节点池的节点
nodeSelector:
  prod: 'true'
tolerations:
- effect: NoSchedule 
  key: prod
  operator: Equal 
  value: 'true'
- effect: NoSchedule
  key: large
  operator: Equal
  value: 'true'

---
# 调度到small节点池的节点
nodeSelector:
  prod: 'true'
tolerations:
- effect: NoSchedule 
  key: prod
  operator: Equal 
  value: 'true'
- effect: NoSchedule
  key: small
  operator: Equal
  value: 'true'

---
# 调度到medium-disk-large节点池的节点
nodeSelector:
  medium-disk-large: 'true'
tolerations:
- effect: NoSchedule 
  key: medium-disk-large
  operator: Equal 
  value: 'true'
</code></pre>
<h3 id="54-应用分类标准">5.4 应用分类标准</h3>
<p>有了对节点的分类规范及节点的调度方法使用规范，不同的应用服务应该以什么标准来区分它应该调度到哪一类节点呢，主要参考以下标准</p>
<ul>
<li>
<p>对于新接入的应用服务，在优化<code>code</code>的前提下，接入前做好应用占用稳定时资源测试、性能时资源测试以及持续观测，例如借助于监控、<code>netdata</code>等工具，对应用的资源限制给定一个较为合理的阈值</p>
</li>
<li>
<p>对于普适性应用，没有一个严格的标准来区分是应该调度到大节点还是小节点。因此和大节点和小节点区分标准一样，加上考虑到节点的资源预留情况，约定以<code>5C/5G</code>为判定应用资源大小的分界线，小于<code>5</code>个<code>vCPU</code>的应用划分为调度到较小<code>CPU</code>核数即<code>small</code>节点，把大于或等于<code>5</code>个<code>vCPU</code>的实例划分为较大<code>CPU</code>核数即<code>large</code>节点</p>
</li>
<li>
<p>对于占用<code>CPU</code>较低、但内存等<code>IO</code>要求较高的应用，这类也是应用最为普遍的类型，即<code>IO密集型</code>，应用在运行期间，<code>99%</code>的时间都花在<code>IO</code>上，花在<code>CPU</code>上的时间很少，为了不浪费<code>CPU</code>资源以及碎片化资源的集中管理，尽量保障节点<code>pod</code>数量的均衡，约定将这类应用调度到较大<code>CPU</code>核数即<code>large</code>节点</p>
</li>
<li>
<p>对于特殊应用，例如稳定且核心的、大磁盘的、大内存的、计算密集型的这类应用很好区分，对应节点池调度即可</p>
</li>
</ul>
<h2 id="6-展望">6、展望</h2>
<p>本文分析介绍基于<code>ack</code>，结合<code>k8s</code>原生调度方式，综合考虑现有应用自身特性、节点池资源特性、成本、效率等方向而设计的调度规范参考</p>
<p>后续随着业务的复杂性增强，会将更多的调度设计原理与业务相结合，充分利用公有云及<code>k8s</code>的新生特性，例如在离线业务混合部署、拓扑感知调度、二次调度、弹性容器实例<code>ECI</code>、<code>Serveless</code>函数计算等，甚至于出现可用的调度方式都不满足的调度需求，实现自定义调度，进而实现更多更好更强贴近业务、使用效率提升的服务调度方式，根据更多的数据指标和服务中链路的追踪来进一步优化业务，最终实现业务的快速迭代、自动部署、独立高效</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[基于Dockerfile构建容器镜像的最佳实践]]></title>
        <id>https://www.ssgeek.com/post/ji-yu-dockerfile-gou-jian-rong-qi-jing-xiang-de-zui-jia-shi-jian</id>
        <link href="https://www.ssgeek.com/post/ji-yu-dockerfile-gou-jian-rong-qi-jing-xiang-de-zui-jia-shi-jian">
        </link>
        <updated>2021-11-24T16:13:25.000Z</updated>
        <content type="html"><![CDATA[<p><ul class="markdownIt-TOC">
<li>
<ul>
<li><a href="#1-%E8%83%8C%E6%99%AF%E6%A6%82%E8%BF%B0">1、背景概述</a></li>
<li><a href="#2-%E4%B8%BA%E4%BB%80%E4%B9%88%E9%95%9C%E5%83%8F%E4%BC%9A%E8%BF%99%E4%B9%88%E5%A4%A7">2、为什么镜像会这么大</a>
<ul>
<li><a href="#21-%E5%9F%BA%E7%A1%80%E9%95%9C%E5%83%8F%E8%BF%87%E5%A4%A7">2.1 基础镜像过大</a></li>
<li><a href="#22-%E5%9F%BA%E7%A1%80%E9%95%9C%E5%83%8F%E8%BF%87%E5%A4%A7%E8%80%8C%E4%B8%94%E6%89%BE%E4%B8%8D%E5%88%B0%E4%BA%86">2.2 基础镜像过大，而且找不到了</a></li>
<li><a href="#23-git%E7%9B%AE%E5%BD%95%E9%9D%9E%E5%BF%85%E8%A6%81%E7%9B%AE%E5%BD%95">2.3 .git目录（非必要目录）</a></li>
<li><a href="#24-dockerfile%E6%9C%AC%E8%BA%AB%E6%9C%89%E5%85%B6%E4%BB%96%E9%97%AE%E9%A2%98">2.4 Dockerfile本身有其他问题</a></li>
</ul>
</li>
<li><a href="#3-dockerfile%E5%A6%82%E4%BD%95%E4%BC%98%E5%8C%96">3、Dockerfile如何优化</a>
<ul>
<li><a href="#31-%E4%BB%8E%E5%93%AA%E9%87%8C%E5%85%A5%E6%89%8B">3.1 从哪里入手</a>
<ul>
<li><a href="#311-%E4%B8%BE%E4%B8%AA%E6%A0%97%E5%AD%90">3.1.1 举个栗子</a></li>
<li><a href="#312-copy-on-write">3.1.2 Copy on write</a></li>
<li><a href="#313-unionfs">3.1.3 UnionFS</a></li>
</ul>
</li>
<li><a href="#32-%E6%96%B9%E6%A1%88">3.2 方案</a>
<ul>
<li><a href="#321-%E5%87%8F%E5%B0%91%E9%95%9C%E5%83%8F%E5%B1%82%E6%95%B0">3.2.1 减少镜像层数</a></li>
<li><a href="#322-%E5%87%8F%E5%B0%91%E6%AF%8F%E5%B1%82%E9%95%9C%E5%83%8F%E5%A4%A7%E5%B0%8F">3.2.2 减少每层镜像大小</a>
<ul>
<li><a href="#3221-%E9%80%89%E7%94%A8%E6%9B%B4%E5%B0%8F%E7%9A%84%E5%9F%BA%E7%A1%80%E9%95%9C%E5%83%8F">3.2.2.1 选用更小的基础镜像</a></li>
<li><a href="#3322-%E5%A4%9A%E9%98%B6%E6%AE%B5%E6%9E%84%E5%BB%BA">3.3.2.2 多阶段构建</a></li>
<li><a href="#3323-%E5%BF%BD%E7%95%A5%E6%96%87%E4%BB%B6">3.3.2.3 忽略文件</a></li>
<li><a href="#3324-%E8%BF%9C%E7%A8%8B%E4%B8%8B%E8%BD%BD">3.3.2.4 远程下载</a></li>
<li><a href="#3325-%E6%8B%86%E5%88%86copy">3.3.2.5 拆分COPY</a></li>
<li><a href="#3326-%E6%9E%84%E5%BB%BA%E6%97%B6%E6%8C%82%E8%BD%BD">3.3.2.6 构建时挂载</a></li>
<li><a href="#3327-%E6%9E%84%E5%BB%BA%E5%90%8E%E6%B8%85%E7%90%86">3.3.2.7 构建后清理</a></li>
<li><a href="#3328-%E9%95%9C%E5%83%8F%E5%8E%8B%E7%BC%A9">3.3.2.8 镜像压缩</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#33-%E6%A0%B7%E4%BE%8B">3.3 样例</a>
<ul>
<li><a href="#331-go-%E6%A0%B7%E4%BE%8B">3.3.1 go 样例</a></li>
<li><a href="#332-py-%E6%A0%B7%E4%BE%8B">3.3.2 py 样例</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#4-%E9%99%A4%E4%BA%86%E8%BF%99%E4%BA%9B%E4%BC%98%E5%8C%96%E8%BF%98%E5%8F%AF%E4%BB%A5%E5%81%9A%E4%BB%80%E4%B9%88">4、除了这些优化还可以做什么</a>
<ul>
<li><a href="#41-%E8%AE%BE%E7%BD%AE%E5%AD%97%E7%AC%A6%E9%9B%86">4.1 设置字符集</a></li>
<li><a href="#42-%E6%97%B6%E5%8C%BA%E6%A0%A1%E6%AD%A3">4.2 时区校正</a></li>
<li><a href="#43-%E8%BF%9B%E7%A8%8B%E7%AE%A1%E7%90%86">4.3 进程管理</a></li>
<li><a href="#44-%E9%99%8D%E6%9D%83%E5%90%AF%E5%8A%A8">4.4 降权启动</a></li>
<li><a href="#45-%E5%BA%95%E5%B1%82%E5%BA%93%E4%BE%9D%E8%B5%96">4.5 底层库依赖</a></li>
</ul>
</li>
<li><a href="#5-%E5%B0%8F%E7%BB%93">5、小结</a></li>
</ul>
</li>
</ul>
</p>
<figure data-type="image" tabindex="1"><img src="https://image.ssgeek.com/20210421-01.png" alt=""></figure>
<h2 id="1-背景概述">1、背景概述</h2>
<p>容器镜像是容器化落地转型的第一步，总结几点需要做镜像优化的原因</p>
<p>随着应用容器化部署的大规模迁移以及版本迭代的加快，优化基础设施之<code>docker</code>镜像主要有以下目的</p>
<ul>
<li>
<p>缩短部署时的镜像下载时间</p>
</li>
<li>
<p>提升安全性，减少可供攻击的目标</p>
</li>
<li>
<p>减少故障恢复时间</p>
</li>
<li>
<p>节省存储开销</p>
</li>
</ul>
<h2 id="2-为什么镜像会这么大">2、为什么镜像会这么大</h2>
<p>这里简要分析了几个典型的<code>Repo</code>，总结了现有<code>Docker</code>镜像较大的几个原因</p>
<h3 id="21-基础镜像过大">2.1 基础镜像过大</h3>
<p>举例：仓库<code>A</code>，制作出来的镜像大小<code>9.67GB</code></p>
<p>用到的基础镜像： 镜像大小<code>8.72GB</code></p>
<p>逆向分析了一下，为啥基础镜像还这么大？结果就不用多说了0.0</p>
<h3 id="22-基础镜像过大而且找不到了">2.2 基础镜像过大，而且找不到了</h3>
<p>举例：仓库<code>B</code>，制作出来的镜像大小<code>22.7GB</code></p>
<p>用到的基础镜像： <strong>404 not found</strong>，没错，找不到了0.0</p>
<h3 id="23-git目录非必要目录">2.3 .git目录（非必要目录）</h3>
<p>这个问题更多内容可以参考我之前的文章 <a href="https://www.ssgeek.com/post/git-mu-lu-wei-shi-me-zhe-me-da/">Git目录为什么这么大</a></p>
<p>举例：仓库<code>C</code>，代码大小<code>795MB</code></p>
<p>其中<code>.git</code>目录大小<code>225MB</code> ，<code>dockerfile</code>中的指令如下（全部添加到了镜像中）</p>
<pre><code class="language-dockerfile">ADD . /app/startapp/
</code></pre>
<p>其中还包含了<code>d</code>目录大小约<code>300MB</code>，是否需要使用不得而知，但目测不需要使用，仅为测试数据</p>
<pre><code class="language-shell">d
├── [ 503]  test_421.json
├── [ 483]  test_havalB9.json
...
├── [ 484]  test_144.json
├── [ 104]  .gitmodules
├── [ 122]  .idea
├── [   0]  __init__.py
├── [ 11M]  164103.zip
├── [108M]  test_180753.csv
├── [ 68M]  test_180753.txt
...
└── [ 335]  README.md
</code></pre>
<p>以上其实都不需要提交到镜像中制作成镜像</p>
<h3 id="24-dockerfile本身有其他问题">2.4 Dockerfile本身有其他问题</h3>
<p>这个原因不言而喻，不是专业的人写的<code>Dockerfile</code>可能都有一定的优化空间，只是暂时没关注这些细节而已</p>
<p>例如，放任各路<code>repo</code>研发自行写<code>Dockerfile</code>，没有一定的标准，前期可能无所谓，到后期问题就慢慢浮现了</p>
<p>正所谓《能用就行》~</p>
<h2 id="3-dockerfile如何优化">3、Dockerfile如何优化</h2>
<h3 id="31-从哪里入手">3.1 从哪里入手</h3>
<p>优化<code>docker</code>镜像应该从镜像分层概念入手</p>
<h4 id="311-举个栗子">3.1.1 举个栗子</h4>
<p>一个实际的例子</p>
<p>nginx:alpine镜像 23.2MB</p>
<pre><code class="language-shell"># docker history nginx:alpine
IMAGE          CREATED       CREATED BY                                      SIZE      COMMENT
b46db85084b8   9 days ago    /bin/sh -c #(nop)  CMD [&quot;nginx&quot; &quot;-g&quot; &quot;daemon…   0B        
&lt;missing&gt;      9 days ago    /bin/sh -c #(nop)  STOPSIGNAL SIGQUIT           0B        
&lt;missing&gt;      9 days ago    /bin/sh -c #(nop)  EXPOSE 80                    0B        
&lt;missing&gt;      9 days ago    /bin/sh -c #(nop)  ENTRYPOINT [&quot;/docker-entr…   0B        
&lt;missing&gt;      9 days ago    /bin/sh -c #(nop) COPY file:09a214a3e07c919a…   4.61kB    
&lt;missing&gt;      9 days ago    /bin/sh -c #(nop) COPY file:0fd5fca330dcd6a7…   1.04kB    
&lt;missing&gt;      9 days ago    /bin/sh -c #(nop) COPY file:0b866ff3fc1ef5b0…   1.96kB    
&lt;missing&gt;      9 days ago    /bin/sh -c #(nop) COPY file:65504f71f5855ca0…   1.2kB     
&lt;missing&gt;      9 days ago    /bin/sh -c set -x     &amp;&amp; addgroup -g 101 -S …   17.6MB    
&lt;missing&gt;      9 days ago    /bin/sh -c #(nop)  ENV PKG_RELEASE=1            0B        
&lt;missing&gt;      9 days ago    /bin/sh -c #(nop)  ENV NJS_VERSION=0.7.0        0B        
&lt;missing&gt;      9 days ago    /bin/sh -c #(nop)  ENV NGINX_VERSION=1.21.4     0B        
&lt;missing&gt;      9 days ago    /bin/sh -c #(nop)  LABEL maintainer=NGINX Do…   0B        
&lt;missing&gt;      10 days ago   /bin/sh -c #(nop)  CMD [&quot;/bin/sh&quot;]              0B        
&lt;missing&gt;      10 days ago   /bin/sh -c #(nop) ADD file:762c899ec0505d1a3…   5.61MB
</code></pre>
<p>python:alpine镜像 45.5MB</p>
<pre><code class="language-shell"># docker history python:alpine
IMAGE          CREATED       CREATED BY                                      SIZE      COMMENT
382a63bb2f25   10 days ago   /bin/sh -c #(nop)  CMD [&quot;python3&quot;]              0B        
&lt;missing&gt;      10 days ago   /bin/sh -c set -ex;   wget -O get-pip.py &quot;$P…   8.31MB    
&lt;missing&gt;      10 days ago   /bin/sh -c #(nop)  ENV PYTHON_GET_PIP_SHA256…   0B        
&lt;missing&gt;      10 days ago   /bin/sh -c #(nop)  ENV PYTHON_GET_PIP_URL=ht…   0B        
&lt;missing&gt;      10 days ago   /bin/sh -c #(nop)  ENV PYTHON_SETUPTOOLS_VER…   0B        
&lt;missing&gt;      10 days ago   /bin/sh -c #(nop)  ENV PYTHON_PIP_VERSION=21…   0B        
&lt;missing&gt;      10 days ago   /bin/sh -c cd /usr/local/bin  &amp;&amp; ln -s idle3…   32B       
&lt;missing&gt;      10 days ago   /bin/sh -c set -ex  &amp;&amp; apk add --no-cache --…   29.8MB    
&lt;missing&gt;      10 days ago   /bin/sh -c #(nop)  ENV PYTHON_VERSION=3.10.0    0B        
&lt;missing&gt;      10 days ago   /bin/sh -c #(nop)  ENV GPG_KEY=A035C8C19219B…   0B        
&lt;missing&gt;      10 days ago   /bin/sh -c set -eux;  apk add --no-cache   c…   1.82MB    
&lt;missing&gt;      10 days ago   /bin/sh -c #(nop)  ENV LANG=C.UTF-8             0B        
&lt;missing&gt;      10 days ago   /bin/sh -c #(nop)  ENV PATH=/usr/local/bin:/…   0B        
&lt;missing&gt;      10 days ago   /bin/sh -c #(nop)  CMD [&quot;/bin/sh&quot;]              0B        
&lt;missing&gt;      10 days ago   /bin/sh -c #(nop) ADD file:762c899ec0505d1a3…   5.61MB
</code></pre>
<p>实际存储</p>
<pre><code class="language-json"># docker inspect nginx:alpine| jq '.[0]|{GraphDriver}'             
{
  &quot;GraphDriver&quot;: {
    &quot;Data&quot;: {
      &quot;LowerDir&quot;: &quot;/data/docker-overlay2/overlay2/3d.../diff:/data/docker-overlay2/overlay2/ae.../diff:/data/docker-overlay2/overlay2/ea.../diff:/data/docker-overlay2/overlay2/29.../diff:/data/docker-overlay2/overlay2/5e.../diff&quot;,
      &quot;MergedDir&quot;: &quot;/data/docker-overlay2/overlay2/b7.../merged&quot;,
      &quot;UpperDir&quot;: &quot;/data/docker-overlay2/overlay2/b7.../diff&quot;,
      &quot;WorkDir&quot;: &quot;/data/docker-overlay2/overlay2/b7.../work&quot;
    },
    &quot;Name&quot;: &quot;overlay2&quot;
  }
}
</code></pre>
<p>分层概念的描述</p>
<p>镜像解决了应用运行及环境的打包问题，实际应用中应用都是基于同一个<code>rootfs</code>来打包和迭代的，但并不是每个<code>rootfs</code>都会多份，实际上<code>docker</code>利用了存储驱动<code>AUFS</code>，<code>devicemapper</code>，<code>overlay</code>，<code>overlay2</code>的存储技术实现了分层</p>
<p>例如上面查看一个<code>docker</code>镜像会发现这些层</p>
<ul>
<li>
<p>LowerDir：镜像层</p>
</li>
<li>
<p>MergedDir：整合了lower层和upper读写层显示出来的视图</p>
</li>
<li>
<p>UpperDir：读写层</p>
</li>
<li>
<p>WorkDir：中间层，对Upper层的写入，先写入WorkDir，再移入UpperDir</p>
</li>
</ul>
<h4 id="312-copy-on-write">3.1.2 Copy on write</h4>
<p>当<code>Docker</code>第一次启动一个容器时，初始的读写层是空的，当文件系统发生变化时，这些变化都会应用到这一层之上。比如，如果想修改一个文件，这个文件首先会从该读写层下面的只读层复制到该读写层。由此，该文件的只读版本依然存在于只读层，只是被读写层的该文件副本所隐藏，该机制则被称之为<strong>写时复制</strong></p>
<h4 id="313-unionfs">3.1.3 UnionFS</h4>
<p>把多个目录(也叫分支)内容联合挂载到同一个目录下，而目录的物理位置是分开的</p>
<p>一个直观的效果，第一次拉取一个<code>nginx:1.15</code>版本镜像，再次拉取<code>nginx:1.16</code>镜像，速度要快很多</p>
<h3 id="32-方案">3.2 方案</h3>
<p>了解了镜像大小的主要构成之后，就很容易知道从哪些方向入手减少镜像大小了</p>
<h4 id="321-减少镜像层数">3.2.1 减少镜像层数</h4>
<p>镜像层数的增加，对<code>Dockerfile</code>来说主要在于<code>RUN</code>指令出现的次数，因此，合并<code>RUN</code>指令可以大大减少镜像层数</p>
<p>举个栗子：</p>
<p>合并前，三层</p>
<pre><code class="language-dockerfile">RUN apk add tzdata
RUN cp /usr/share/zoneinfo/Asia/Shanghai /etc/localtime
RUN echo &quot;Asia/Shanghai&quot; &gt; /etc/timezone
</code></pre>
<p>合并后，一层</p>
<pre><code class="language-dockerfile">RUN apk add tzdata \
    &amp;&amp; cp /usr/share/zoneinfo/Asia/Shanghai /etc/localtime \
    &amp;&amp; echo &quot;Asia/Shanghai&quot; &gt; /etc/timezone
</code></pre>
<h4 id="322-减少每层镜像大小">3.2.2 减少每层镜像大小</h4>
<h5 id="3221-选用更小的基础镜像">3.2.2.1 选用更小的基础镜像</h5>
<ul>
<li>scratch：空镜像，又叫镜像之父！任何镜像都需要有一个基础镜像，那么问题来了，就好比是先有鸡还是先有蛋的问题，基础镜像的“祖宗”是什么呢？能不能在构建时不以任何镜像为基础呢？答案是肯定的，可以选用<code>scratch</code>，具体就不展开了，可以参考：<a href="https://docs.docker.com/develop/develop-images/baseimages/">baseimages</a>，使用<code>scratch</code>镜像的例子<code>pause</code></li>
<li>busybox：对比<code>scratch</code>，多了常用的<code>linux</code>工具等</li>
<li>alpine：多了包管理工具<code>apk</code>等</li>
</ul>
<h5 id="3322-多阶段构建">3.3.2.2 多阶段构建</h5>
<p>多阶段构建非常适用于编译性语言，简单来说就是允许一个<code>Dockerfile</code>中出现多条<code>FROM</code>指令，只有最后一条<code>FROM</code>指令中指定的基础镜像作为本次构建镜像的基础镜像，其它的阶段都可以认为是只为中间步骤</p>
<p><code>FROM … AS …</code>和<code>COPY --from</code>组合使用</p>
<p>例如<code>java</code>镜像，镜像大小<code>812MB</code></p>
<pre><code class="language-dockerfile">FROM centos AS jdk
COPY jdk-8u231-linux-x64.tar.gz /usr/local/src
RUN cd /usr/local/src &amp;&amp; \
    tar -xzvf jdk-8u231-linux-x64.tar.gz -C /usr/local
</code></pre>
<p>使用多阶段构建，镜像大小<code>618MB</code></p>
<pre><code class="language-dockerfile">FROM centos AS jdk
COPY jdk-8u231-linux-x64.tar.gz /usr/local/src
RUN cd /usr/local/src &amp;&amp; \
    tar -xzvf jdk-8u231-linux-x64.tar.gz -C /usr/local

FROM centos
COPY --from=jdk /usr/local/jdk1.8.0_231 /usr/local
</code></pre>
<h5 id="3323-忽略文件">3.3.2.3 忽略文件</h5>
<p>构建上下文<code>build context</code>，“上下文” 意为和现在这个工作相关的周围环境</p>
<p><code>docker build</code>时当前的工作目录，不管构建时有没有用到当前目录下的某些文件及目录，默认情况下这个上下文中的文件及目录都会作为构建上下文内容发送给<code>Docker Daemon</code></p>
<p>当<code>docker build</code>开始执行时，控制台会输出<code>Sending build context to Docker daemon xxxMB</code>，这就表示将当前工作目录下的文件及目录都作为了构建上下文</p>
<p>前面提到可以在<code>RUN</code>指令中添加<code>--no-cache</code>不使用缓存，同样也可以在执行<code>docker build</code>命令时添加该指令以在镜像构建时不使用缓存</p>
<p>构建上下文中，使用<code>.dockerignore</code> 文件在构建时就可以避免将本地模块以及调试日志被拷贝进入到<code>Docker</code>镜像中，这和<code>git</code>版本控制的<code>.gitignore</code>很类似</p>
<h5 id="3324-远程下载">3.3.2.4 远程下载</h5>
<p>使用远程下载代替<code>ADD</code>可以减少镜像大小</p>
<pre><code class="language-dockerfile">RUN curl -s http://192.168.1.1/repository/tools/jdk-8u241-linux-x64.tar.gz | tar -xC /opt/
</code></pre>
<h5 id="3325-拆分copy">3.3.2.5 拆分COPY</h5>
<p>例如一个<code>COPY</code>指令的目录下<code>A</code>有<code>4</code>个子目录<code>AA/BB/CC/DD</code>被<code>COPY</code>，但常变化的只有一个BB</p>
<p>这个时候拆分<code>COPY</code>会更快</p>
<pre><code class="language-dockerfile">COPY A/AA /app/A/AA
COPY A/BB /app/A/BB
COPY A/CC /app/A/CC
COPY A/DD /app/A/DD
</code></pre>
<h5 id="3326-构建时挂载">3.3.2.6 构建时挂载</h5>
<p>构建时挂载（<a href="https://docs.docker.com/engine/reference/commandline/dockerd/#description">扩展功能</a>）</p>
<p>配置</p>
<ul>
<li>修改docker启动参数，添加<code>--experimental</code></li>
<li>dockerfile头部添加<code># syntax=docker/dockerfile:1.1.1-experimental</code></li>
</ul>
<p>使用</p>
<ul>
<li>挂载本地golang缓存</li>
</ul>
<pre><code class="language-dockerfile"># syntax = docker/dockerfile:experimental
FROM golang
...
RUN --mount=type=cache,target=/root/.cache/go-build go build ...
</code></pre>
<ul>
<li>挂载cache目录</li>
</ul>
<pre><code class="language-dockerfile"># syntax = docker/dockerfile:experimental
FROM ubuntu
RUN rm -f /etc/apt/apt.conf.d/docker-clean; echo 'Binary::apt::APT::Keep-Downloaded-Packages &quot;true&quot;;' &gt; /etc/apt/apt.conf.d/keep-cache
RUN --mount=type=cache,target=/var/cache/apt --mount=type=cache,target=/var/lib/apt \
  apt update &amp;&amp; apt install -y gcc
</code></pre>
<ul>
<li>挂载某些凭据</li>
</ul>
<pre><code class="language-dockerfile"># syntax = docker/dockerfile:experimental
FROM python:3
RUN pip install awscli
RUN --mount=type=secret,id=aws,target=/root/.aws/credentials aws s3 cp s3://... ...
</code></pre>
<p>等等</p>
<h5 id="3327-构建后清理">3.3.2.7 构建后清理</h5>
<ul>
<li>删除压缩包</li>
<li>清理安装缓存
<ul>
<li>--no-cache</li>
<li>rm -rf /var/lib/apt/lists/*</li>
<li>rm -rf /var/cache/yum/*</li>
</ul>
</li>
</ul>
<h5 id="3328-镜像压缩">3.3.2.8 镜像压缩</h5>
<p><code>export</code>和<code>import</code>组合进行压缩镜像（压缩效果不是很明显）</p>
<p>这种方法不好的就是会丢失一部分镜像信息</p>
<pre><code class="language-shell"># docker run -d --name nginx nginx:alpine
# docker export nginx |docker import - nginx:alpine2
sha256:dd6a3cf822ac3c3ad3e7f7b31675cd8cd99a6f80e360996e04da6fc2f3b98cb5
# docker history nginx:alpine
IMAGE          CREATED       CREATED BY                                      SIZE      COMMENT
b46db85084b8   10 days ago   /bin/sh -c #(nop)  CMD [&quot;nginx&quot; &quot;-g&quot; &quot;daemon…   0B        
&lt;missing&gt;      10 days ago   /bin/sh -c #(nop)  STOPSIGNAL SIGQUIT           0B        
&lt;missing&gt;      10 days ago   /bin/sh -c #(nop)  EXPOSE 80                    0B        
&lt;missing&gt;      10 days ago   /bin/sh -c #(nop)  ENTRYPOINT [&quot;/docker-entr…   0B        
&lt;missing&gt;      10 days ago   /bin/sh -c #(nop) COPY file:09a214a3e07c919a…   4.61kB    
&lt;missing&gt;      10 days ago   /bin/sh -c #(nop) COPY file:0fd5fca330dcd6a7…   1.04kB    
&lt;missing&gt;      10 days ago   /bin/sh -c #(nop) COPY file:0b866ff3fc1ef5b0…   1.96kB    
&lt;missing&gt;      10 days ago   /bin/sh -c #(nop) COPY file:65504f71f5855ca0…   1.2kB     
&lt;missing&gt;      10 days ago   /bin/sh -c set -x     &amp;&amp; addgroup -g 101 -S …   17.6MB    
&lt;missing&gt;      10 days ago   /bin/sh -c #(nop)  ENV PKG_RELEASE=1            0B        
&lt;missing&gt;      10 days ago   /bin/sh -c #(nop)  ENV NJS_VERSION=0.7.0        0B        
&lt;missing&gt;      10 days ago   /bin/sh -c #(nop)  ENV NGINX_VERSION=1.21.4     0B        
&lt;missing&gt;      10 days ago   /bin/sh -c #(nop)  LABEL maintainer=NGINX Do…   0B        
&lt;missing&gt;      10 days ago   /bin/sh -c #(nop)  CMD [&quot;/bin/sh&quot;]              0B        
&lt;missing&gt;      10 days ago   /bin/sh -c #(nop) ADD file:762c899ec0505d1a3…   5.61MB    
# docker history nginx:alpine2
IMAGE          CREATED          CREATED BY   SIZE      COMMENT
dd6a3cf822ac   40 seconds ago                23MB      Imported from -
# docker images|grep nginx
nginx                                                                                                               alpine2                     dd6a3cf822ac   54 seconds ago   23MB
nginx                                                                                                               alpine                      b46db85084b8   10 days ago      23.2MB
</code></pre>
<h3 id="33-样例">3.3 样例</h3>
<h4 id="331-go-样例">3.3.1 go 样例</h4>
<p>样例一</p>
<p><code>kubeadm</code>安装的<code>k8s</code>集群，<code>kube-apiserver</code>镜像的<code>Dockerfile</code>是利用<code>bazel</code>编译工具编译的</p>
<pre><code class="language-dockerfile">bazel build ...
LABEL maintainers=Kubernetes Authors
LABEL description=go based runner for distroless scenarios
WORKDIR /
COPY /workspace/go-runner . # buildkit
ENTRYPOINT [&quot;/go-runner&quot;]
COPY file:2e904ea733ba0ded2a99947847de31414a19d83f8495dd8c1fbed3c70bf67a22 in /usr/local/bin/kube-apiserver
</code></pre>
<p>代码目录28M（包含.git目录20.5M）</p>
<p>镜像大小122MB</p>
<p>样例二</p>
<p>开源编排引擎<code>Cadence</code>的<code>Dockerfile</code></p>
<pre><code class="language-dockerfile">ARG TARGET=server

# Can be used in case a proxy is necessary
ARG GOPROXY

# Build tcheck binary
FROM golang:1.17-alpine3.13 AS tcheck

WORKDIR /go/src/github.com/uber/tcheck

COPY go.* ./
RUN go build -mod=readonly -o /go/bin/tcheck github.com/uber/tcheck

# Build Cadence binaries
FROM golang:1.17-alpine3.13 AS builder

ARG RELEASE_VERSION

RUN apk add --update --no-cache ca-certificates make git curl mercurial unzip

WORKDIR /cadence

# Making sure that dependency is not touched
ENV GOFLAGS=&quot;-mod=readonly&quot;

# Copy go mod dependencies and build cache
COPY go.* ./
RUN go mod download

COPY . .
RUN rm -fr .bin .build

ENV CADENCE_RELEASE_VERSION=$RELEASE_VERSION

# bypass codegen, use committed files.  must be run separately, before building things.
RUN make .fake-codegen
RUN CGO_ENABLED=0 make copyright cadence-cassandra-tool cadence-sql-tool cadence cadence-server cadence-bench cadence-canary


# Download dockerize
FROM alpine:3.11 AS dockerize

RUN apk add --no-cache openssl

ENV DOCKERIZE_VERSION v0.6.1
RUN wget https://github.com/jwilder/dockerize/releases/download/$DOCKERIZE_VERSION/dockerize-alpine-linux-amd64-$DOCKERIZE_VERSION.tar.gz \
    &amp;&amp; tar -C /usr/local/bin -xzvf dockerize-alpine-linux-amd64-$DOCKERIZE_VERSION.tar.gz \
    &amp;&amp; rm dockerize-alpine-linux-amd64-$DOCKERIZE_VERSION.tar.gz \
    &amp;&amp; echo &quot;**** fix for host id mapping error ****&quot; \
    &amp;&amp; chown root:root /usr/local/bin/dockerize


# Alpine base image
FROM alpine:3.11 AS alpine

RUN apk add --update --no-cache ca-certificates tzdata bash curl

# set up nsswitch.conf for Go's &quot;netgo&quot; implementation
# https://github.com/gliderlabs/docker-alpine/issues/367#issuecomment-424546457
RUN test ! -e /etc/nsswitch.conf &amp;&amp; echo 'hosts: files dns' &gt; /etc/nsswitch.conf

SHELL [&quot;/bin/bash&quot;, &quot;-c&quot;]


# Cadence server
FROM alpine AS cadence-server

ENV CADENCE_HOME /etc/cadence
RUN mkdir -p /etc/cadence

COPY --from=tcheck /go/bin/tcheck /usr/local/bin
COPY --from=dockerize /usr/local/bin/dockerize /usr/local/bin
COPY --from=builder /cadence/cadence-cassandra-tool /usr/local/bin
COPY --from=builder /cadence/cadence-sql-tool /usr/local/bin
COPY --from=builder /cadence/cadence /usr/local/bin
COPY --from=builder /cadence/cadence-server /usr/local/bin
COPY --from=builder /cadence/schema /etc/cadence/schema

COPY docker/entrypoint.sh /docker-entrypoint.sh
COPY config/dynamicconfig /etc/cadence/config/dynamicconfig
COPY config/credentials /etc/cadence/config/credentials
COPY docker/config_template.yaml /etc/cadence/config
COPY docker/start-cadence.sh /start-cadence.sh

WORKDIR /etc/cadence

ENV SERVICES=&quot;history,matching,frontend,worker&quot;

EXPOSE 7933 7934 7935 7939
ENTRYPOINT [&quot;/docker-entrypoint.sh&quot;]
CMD /start-cadence.sh


# All-in-one Cadence server
FROM cadence-server AS cadence-auto-setup

RUN apk add --update --no-cache ca-certificates py-pip mysql-client
RUN pip install cqlsh

COPY docker/start.sh /start.sh

CMD /start.sh


# Cadence CLI
FROM alpine AS cadence-cli

COPY --from=tcheck /go/bin/tcheck /usr/local/bin
COPY --from=builder /cadence/cadence /usr/local/bin

ENTRYPOINT [&quot;cadence&quot;]

# Cadence Canary
FROM alpine AS cadence-canary

COPY --from=builder /cadence/cadence-canary /usr/local/bin
COPY --from=builder /cadence/cadence /usr/local/bin

CMD [&quot;/usr/local/bin/cadence-canary&quot;, &quot;--root&quot;, &quot;/etc/cadence-canary&quot;, &quot;start&quot;]

# Cadence Bench
FROM alpine AS cadence-bench

COPY --from=builder /cadence/cadence-bench /usr/local/bin
COPY --from=builder /cadence/cadence /usr/local/bin

CMD [&quot;/usr/local/bin/cadence-bench&quot;, &quot;--root&quot;, &quot;/etc/cadence-bench&quot;, &quot;start&quot;]

# Final image
FROM cadence-${TARGET}
</code></pre>
<p>代码目录85.4M（包含.git目录57.7M）</p>
<p>镜像大小135.69MB</p>
<h4 id="332-py-样例">3.3.2 py 样例</h4>
<pre><code class="language-dockerfile">FROM python:3.4

RUN apt-get update \
    &amp;&amp; apt-get install -y --no-install-recommends \
        postgresql-client \
    &amp;&amp; rm -rf /var/lib/apt/lists/*

WORKDIR /usr/src/app
COPY requirements.txt ./
RUN pip install -r requirements.txt
COPY . .

EXPOSE 8000
CMD [&quot;python&quot;, &quot;manage.py&quot;, &quot;runserver&quot;, &quot;0.0.0.0:8000&quot;]
</code></pre>
<p>代码目录275M（包含.git目录222M）</p>
<p>镜像大小436MB</p>
<h2 id="4-除了这些优化还可以做什么">4、除了这些优化还可以做什么</h2>
<h3 id="41-设置字符集">4.1 设置字符集</h3>
<p>在<code>Dockerfile</code>中设置通用的字符集</p>
<pre><code class="language-dockerfile"># Set lang
ENV LANG &quot;en_US.UTF-8&quot;
</code></pre>
<h3 id="42-时区校正">4.2 时区校正</h3>
<p>这个问题更多内容可以参考我之前的文章 <a href="https://www.ssgeek.com/post/k8s-huan-jing-xia-chu-li-rong-qi-shi-jian-wen-ti-de-duo-chong-zi-shi/">k8s环境下处理容器时间问题的多种姿势</a></p>
<p>在<code>Dockerfile</code>中设置通用的时区</p>
<pre><code class="language-dockerfile"># Set timezone
RUN ln -sf /usr/share/zoneinfo/Asia/Shanghai /etc/localtime \
		 &amp;&amp; echo &quot;Asia/Shanghai&quot; &gt; /etc/timezone
</code></pre>
<h3 id="43-进程管理">4.3 进程管理</h3>
<p><code>docker</code>容器运行时，默认会以<code>Dockerfile</code>中的<code>ENTRYPOINT</code>或<code>CMD</code>作为<code>PID</code>为<code>1</code>的主进程，这个进程存在的目的，通俗来说需要做的就是将容器&quot;夯住&quot;，一旦这个进程不存在了，那么容器就会退出</p>
<p>除此之外，这个主进程还有一个重要的作用就是管理“僵尸进程”</p>
<p>一个比较官方的定义，“僵尸进程”是指完成执行（通过<code>exit</code>系统调用，或运行时发生致命错误或收到终止信号所致），但在操作系统的进程表中仍然存在其进程控制块，处于&quot;终止状态&quot;的进程。</p>
<p>清理“僵尸进程”的思路主要有</p>
<ul>
<li>将父进程中对<code>SIGCHLD</code>信号的处理函数设为<code>SIG_IGN</code>（忽略信号）；</li>
<li><code>fork</code>两次并杀死一级子进程，令二级子进程成为孤儿进程而被<code>init</code>所“收养”、清理</li>
</ul>
<p>目前可以实现的开源方案</p>
<ul>
<li>
<p>Tini<br>
<code>tini</code>容器<code>init</code>是一个最小化的<code>init</code>系统，运行在容器内部，用于启动一个子进程，并等待进程退出时清理僵尸和执行信号转发</p>
<p>优点</p>
<ul>
<li>
<p><code>tini</code>可以避免应用程序生成僵尸进程</p>
</li>
<li>
<p><code>tini</code>可以处理<code>Docker</code>进程中运行的程序的信号，通过<code>Tini</code>， <code>SIGTERM</code> 可以终止进程，不需要你明确安装一个信号处理器</p>
</li>
</ul>
<p>示例</p>
</li>
</ul>
<pre><code class="language-dockerfile"># Add Tini
ENV TINI_VERSION v0.19.0
ADD https://github.com/krallin/tini/releases/download/${TINI_VERSION}/tini /tini
RUN chmod +x /tini
ENTRYPOINT [&quot;/tini&quot;, &quot;--&quot;]

# Run your program under Tini
CMD [&quot;/your/program&quot;, &quot;-and&quot;, &quot;-its&quot;, &quot;arguments&quot;]
# or docker run your-image /your/program ...
</code></pre>
<ul>
<li>
<p>dumb-init</p>
<p><code>dumb-init</code>会向子进程的进程组发送其收到的信号。例如 bash 接收到信号之后，不会向子进程发送信号</p>
<p><code>dumb-init</code>也可以通过设置环境变量<code>DUMB_INIT_SETSID=0</code>来控制只向它的直接子进程发送信号</p>
<p>另外<code>dumb-init</code>也会接管失去父进程的进程，确保其能正常退出</p>
<p>示例</p>
</li>
</ul>
<pre><code class="language-dockerfile">FROM alpine:3.11.5
RUN sed -i &quot;s/dl-cdn.alpinelinux.org/mirrors.aliyun.com/g&quot; /etc/apk/repositories \
    &amp;&amp; apk add --no-cache dumb-init

# Runs &quot;/usr/bin/dumb-init -- /my/script --with --args&quot;
ENTRYPOINT [&quot;dumb-init&quot;, &quot;--&quot;]

# or if you use --rewrite or other cli flags
# ENTRYPOINT [&quot;dumb-init&quot;, &quot;--rewrite&quot;, &quot;2:3&quot;, &quot;--&quot;]

CMD [&quot;/my/script&quot;, &quot;--with&quot;, &quot;--args&quot;]
</code></pre>
<h3 id="44-降权启动">4.4 降权启动</h3>
<p>很多情况下，容器中的进程需要降权启动以保证安全性，这就和我们在<code>vm</code>上运行一个<code>nginx</code>服务一样，最好通过特定的降权用户去运行</p>
<p>举例，<code>tomcat</code>镜像</p>
<pre><code class="language-dockerfile">...
USER tomcat
WORKDIR /usr/local/tomcat
EXPOSE 8080
ENTRYPOINT [&quot;catalina.sh&quot;,&quot;run&quot;]
</code></pre>
<p>如果在某些情况下需要使用<code>sudo</code>权限，在<code>docker</code>官方避免安装或使用<code>sudo</code>，<code>sudo</code>因为它具有不可预测的<code>TTY</code>和可能导致问题的信号转发行为。如果必须，例如将守护进程初始化为 <code>root</code>但将其作为非运行<code>root</code>，推荐使用<code>gosu</code></p>
<p>例如，<a href="https://hub.docker.com/_/postgres/">Postgres 官方镜像</a> 使用以下脚本作为其<code>ENTRYPOINT</code></p>
<pre><code class="language-shell">#!/bin/bash
set -e

if [ &quot;$1&quot; = 'postgres' ]; then
    chown -R postgres &quot;$PGDATA&quot;

    if [ -z &quot;$(ls -A &quot;$PGDATA&quot;)&quot; ]; then
        gosu postgres initdb
    fi

    exec gosu postgres &quot;$@&quot;
fi

exec &quot;$@&quot;
</code></pre>
<h3 id="45-底层库依赖">4.5 底层库依赖</h3>
<p>很多时候，服务依赖一些底层库的支持，这里以基于<code>alpine</code>基础镜像构建<code>java</code>镜像举个栗子</p>
<p><code>alpine</code>为了精简本身并没有安装太多的常用软件，所以如果要使用<code>jdk/jre</code>的话就需要<code>glibc</code>，而<code>glibc</code>需要先得到<code>ca-certificates</code>证书服务（安装<code>glibc</code>前置依赖）才能安装</p>
<p>用<code>alpine</code>跑了<code>jdk8</code>的镜像结果发现<code>jdk</code>无法执行。究其原因，<code>java</code>是基于<code>GUN Standard C library(glibc)</code>，<code>alpine</code>是基于<code>MUSL libc(mini libc)</code>，所以<code>alpine</code>需要安装<code>glibc</code>的库</p>
<h2 id="5-小结">5、小结</h2>
<p>本文简要分析了<code>Dockerfile</code>为什么这么大的几个主要原因，并且根据生产经验罗列了一些优化镜像大小的措施以及其他方面常用的处理办法，很多技巧性的内容，比较杂乱，就不一一提及了 ~</p>
<p>See you ~</p>
<blockquote>
<p>参考<br>
https://github.com/docker-library/official-images#init<br>
https://wiki.alpinelinux.org/wiki/Running_glibc_programs</p>
</blockquote>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Golang反射-下篇]]></title>
        <id>https://www.ssgeek.com/post/golang-fan-she-xia-pian</id>
        <link href="https://www.ssgeek.com/post/golang-fan-she-xia-pian">
        </link>
        <updated>2021-11-24T15:06:58.000Z</updated>
        <content type="html"><![CDATA[<p><ul class="markdownIt-TOC">
<li>
<ul>
<li><a href="#1-%E5%88%A4%E6%96%AD%E7%B1%BB%E5%9E%8Binterfacetype">1、判断类型interface.Type</a></li>
<li><a href="#2-%E8%87%AA%E5%AE%9A%E4%B9%89struct%E7%9A%84%E5%8F%8D%E5%B0%84">2、自定义struct的反射</a></li>
<li><a href="#3-%E7%BB%93%E6%9E%84%E4%BD%93%E6%A0%87%E7%AD%BE%E5%92%8C%E5%8F%8D%E5%B0%84">3、结构体标签和反射</a></li>
<li><a href="#4-%E5%8F%8D%E5%B0%84%E8%B0%83%E7%94%A8%E5%87%BD%E6%95%B0">4、反射调用函数</a></li>
<li><a href="#5-%E5%8F%8D%E5%B0%84%E8%B0%83%E7%94%A8%E6%96%B9%E6%B3%95">5、反射调用方法</a></li>
<li><a href="#6-%E5%8F%8D%E5%B0%84%E5%88%9B%E5%BB%BA%E5%80%BC">6、反射创建值</a>
<ul>
<li><a href="#61-%E5%8F%8D%E5%B0%84%E5%88%9B%E5%BB%BAstruct">6.1 反射创建struct</a></li>
<li><a href="#62-%E5%8F%8D%E5%B0%84%E5%88%9B%E5%BB%BAslice">6.2 反射创建slice</a></li>
<li><a href="#63-%E5%8F%8D%E5%B0%84%E5%88%9B%E5%BB%BAmap">6.3 反射创建map</a></li>
</ul>
</li>
<li><a href="#7-%E5%8F%8D%E5%B0%84%E4%BF%AE%E6%94%B9%E5%80%BC">7、反射修改值</a>
<ul>
<li><a href="#71-%E5%8F%8D%E5%B0%84%E4%BF%AE%E6%94%B9struct">7.1 反射修改struct</a></li>
<li><a href="#72-%E5%8F%8D%E5%B0%84%E4%BF%AE%E6%94%B9slice">7.2 反射修改slice</a></li>
<li><a href="#73-%E5%8F%8D%E5%B0%84%E4%BF%AE%E6%94%B9map">7.3 反射修改map</a></li>
</ul>
</li>
</ul>
</li>
</ul>
</p>
<figure data-type="image" tabindex="1"><img src="https://image.ssgeek.com/golang.png" alt=""></figure>
<p>本文是<a href="https://www.ssgeek.com/post/golang-fan-she-shang-pian/">Golang反射-上篇</a>的续篇内容，主要介绍反射实际的一些使用</p>
<h2 id="1-判断类型interfacetype">1、判断类型interface.Type</h2>
<p>利用类型断言来判断数据类型的用法如下</p>
<pre><code class="language-go">package main

import &quot;fmt&quot;

func main()  {
	var s interface{} = &quot;abc&quot;
	switch s.(type) {
	case string:
		fmt.Println(&quot;s.type=string&quot;)
	case int:
		fmt.Println(&quot;s.type=int&quot;)
	case bool:
		fmt.Println(&quot;s.type=bool&quot;)
	default:
		fmt.Println(&quot;未知的类型&quot;)
	}
}
</code></pre>
<p>上述类型判断的问题</p>
<ul>
<li>类型判断会写很多，代码很长</li>
<li>类型还会增删，不灵活</li>
</ul>
<p>如果使用反射获取变量内部的信息</p>
<ul>
<li>reflect包提供ValueOf和TypeOf</li>
<li>reflect.ValueOf：获取输入接口中数据的值，如果为空返回0</li>
<li>reflect.TypeOf：获取输入接口中值的类型，如果为空返回nil</li>
<li>TypeOf能传入所有类型，是因为所有的类型都实现了空接口</li>
</ul>
<pre><code class="language-go">package main

import (
	&quot;fmt&quot;
	&quot;reflect&quot;
)

func main()  {
	var s interface{} = &quot;abc&quot;
	//TypeOf会返回目标的对象
	reflectType:=reflect.TypeOf(s)
	reflectValue:=reflect.ValueOf(s)
	fmt.Printf(&quot;[typeof:%v]\n&quot;, reflectType)  // string
	fmt.Printf(&quot;[valueof:%v]\n&quot;, reflectValue)  // abc
}
</code></pre>
<h2 id="2-自定义struct的反射">2、自定义struct的反射</h2>
<p>自定义struct的相关操作</p>
<ul>
<li>
<p>对于成员变量</p>
<ul>
<li>先获取interface的reflect.Type，然后遍历NumField</li>
<li>再通过reflect.Type的Field获取字段名及类型</li>
<li>最后通过Field的interface获取对应的value</li>
</ul>
</li>
<li>
<p>对于方法</p>
<ul>
<li>先获取interface的reflect.Type，然后遍历NumMethod</li>
<li>再通过reflect.Type的t.Method获取真实的方法名</li>
<li>最后通过Name和Type获取方法的类型和值</li>
</ul>
</li>
</ul>
<p>注意点</p>
<ul>
<li>用于对未知类型进行遍历探测其Field，抽象成一个函数</li>
<li>go语言里面struct成员变量小写，在反射的时候直接panic()</li>
<li>结构体方法名小写是不会panic的，反射值也不会被查看到</li>
<li>指针方法是不能被反射查看到的</li>
</ul>
<pre><code class="language-go">package main

import (
	&quot;fmt&quot;
	&quot;reflect&quot;
)

type Person struct {
	Name string
	Age  int
}

type Student struct {
	Person     // 匿名结构体嵌套
	StudentId  int
	SchoolName string
	Graduated  bool
	Hobbies    []string
	//panic: reflect.Value.Interface: cannot return value obtained from unexported field or method
	//hobbies    []string
	Label      map[string]string
}

func (s *Student) GoHome() {
	fmt.Printf(&quot;回家了,sid:%d\n&quot;, s.StudentId)
}

//func (s Student) GoHome() {
//	fmt.Printf(&quot;回家了,sid:%d\n&quot;, s.StudentId)
//}

func (s Student) GotoSchool() {
	fmt.Printf(&quot;上学了,sid:%d\n&quot;, s.StudentId)
}

func (s *Student) graduated() {
	fmt.Printf(&quot;毕业了,sid:%d\n&quot;, s.StudentId)
}

//func (s Student) Ggraduated() {
//	fmt.Printf(&quot;毕业了,sid:%d\n&quot;, s.StudentId)
//}

func reflectProbeStruct(s interface{}) {
	// 获取目标对象
	t := reflect.TypeOf(s)
	fmt.Printf(&quot;对象的类型名称 %s\n&quot;, t.Name())
	// 获取目标对象的值类型
	v := reflect.ValueOf(s)
	// 遍历获取成员变量
	for i := 0; i &lt; t.NumField(); i++ {
		// Field 代表对象的字段名
		key := t.Field(i)
		value := v.Field(i).Interface()
		// 字段
		if key.Anonymous {
			fmt.Printf(&quot;匿名字段 第 %d 个字段，字段名 %s, 字段类型 %v, 字段的值 %v\n&quot;, i+1, key.Name, key.Type, value)
		} else {
			fmt.Printf(&quot;命名字段 第 %d 个字段，字段名 %s, 字段类型 %v, 字段的值 %v\n&quot;, i+1, key.Name, key.Type, value)
		}
	}
	// 打印方法
	for i := 0; i &lt; t.NumMethod(); i++ {
		m := t.Method(i)
		fmt.Printf(&quot;第 %d 个方法，方法名 %s, 方法类型 %v\n&quot;, i+1, m.Name, m.Type)
	}
}

func main() {
	s := Student{
		Person: Person{
			&quot;geek&quot;,
			24,
		},
		StudentId:  123,
		SchoolName: &quot;Beijing University&quot;,
		Graduated:  true,
		Hobbies:    []string{&quot;唱&quot;, &quot;跳&quot;, &quot;Rap&quot;},
		//hobbies:    []string{&quot;唱&quot;, &quot;跳&quot;, &quot;Rap&quot;},
		Label:      map[string]string{&quot;k1&quot;: &quot;v1&quot;, &quot;k2&quot;: &quot;v2&quot;},
	}
	p := Person{
		Name: &quot;张三&quot;,
		Age:  100,
	}
	reflectProbeStruct(s)
	reflectProbeStruct(p)
	/*
	对象的类型名称 Student
	匿名字段 第 1 个字段，字段名 Person, 字段类型 main.Person, 字段的值 {geek 24}
	命名字段 第 2 个字段，字段名 StudentId, 字段类型 int, 字段的值 123
	命名字段 第 3 个字段，字段名 SchoolName, 字段类型 string, 字段的值 Beijing University
	命名字段 第 4 个字段，字段名 Graduated, 字段类型 bool, 字段的值 true
	命名字段 第 5 个字段，字段名 Hobbies, 字段类型 []string, 字段的值 [唱 跳 Rap]
	命名字段 第 6 个字段，字段名 Label, 字段类型 map[string]string, 字段的值 map[k1:v1 k2:v2]
	第 1 个方法，方法名 GotoSchool, 方法类型 func(main.Student)
	对象的类型名称 Person
	命名字段 第 1 个字段，字段名 Name, 字段类型 string, 字段的值 张三
	命名字段 第 2 个字段，字段名 Age, 字段类型 int, 字段的值 100
	 */
}
</code></pre>
<h2 id="3-结构体标签和反射">3、结构体标签和反射</h2>
<ul>
<li>json的标签解析出json</li>
<li>yaml的标签解析出yaml</li>
<li>xorm、gorm的标签标识数据库db字段</li>
<li>自定义标签</li>
<li>原理是t.Field.Tag.Lookup(&quot;标签名&quot;)</li>
</ul>
<p>示例</p>
<pre><code class="language-go">package main

import (
	&quot;encoding/json&quot;
	&quot;fmt&quot;
	&quot;gopkg.in/yaml.v2&quot;
	&quot;io/ioutil&quot;
)

type Person struct {
	Name string `json:&quot;name&quot; yaml:&quot;yaml_name&quot;`
	Age  int    `json:&quot;age&quot; yaml:&quot;yaml_age&quot;`
	City string `json:&quot;city&quot; yaml:&quot;yaml_city&quot;`
	//City string `json:&quot;-&quot; yaml:&quot;yaml_city&quot;` // 忽略json:&quot;-&quot;
}

// json解析
func jsonWork() {
	// 对象Marshal成字符串
	p := Person{
		Name: &quot;geek&quot;,
		Age:  24,
		City: &quot;Beijing&quot;,
	}
	data, err := json.Marshal(p)
	if err != nil {
		fmt.Printf(&quot;json.marshal.err: %v\n&quot;, err)
	}
	fmt.Printf(&quot;person.marshal.res: %v\n&quot;, string(data))

	// 从字符串解析成结构体
	p2str := `{
	&quot;name&quot;: &quot;张三&quot;,
	&quot;age&quot;: 38,
	&quot;city&quot;: &quot;山东&quot;
	}`
	var p2 Person
	err = json.Unmarshal([]byte(p2str), &amp;p2)
	if err != nil {
		fmt.Printf(&quot;json.unmarshal.err: %v\n&quot;, err)
		return
	}
	fmt.Printf(&quot;person.unmarshal.res: %v\n&quot;, p2)
}

// yaml解析
func yamlWork() {
	filename := &quot;a.yaml&quot;
	content, err := ioutil.ReadFile(filename)
	if err != nil {
		fmt.Printf(&quot;ioutil.ReadFile.err: %v\n&quot;, err)
		return
	}
	p := &amp;Person{}
	//err = yaml.Unmarshal([]byte(content), p)
	err = yaml.UnmarshalStrict([]byte(content), p)  // 解析严格，考虑多余字段，忽略字段等
	if err != nil {
		fmt.Printf(&quot;yaml.UnmarshalStrict.err: %v\n&quot;, err)
		return
	}
	fmt.Printf(&quot;yaml.UnmarshalStrict.res: %v\n&quot;, p)
}

func main() {
	jsonWork()
	/*
		person.marshal.res: {&quot;name&quot;:&quot;geek&quot;,&quot;age&quot;:24,&quot;city&quot;:&quot;Beijing&quot;}
		person.unmarshal.res: {张三 38 山东}
	*/
	yamlWork()
	/*
		yaml.UnmarshalStrict.res: &amp;{李四 18 Shanghai}
	 */
}
</code></pre>
<p>解析的yaml内容</p>
<pre><code class="language-yaml">yaml_name: 李四
yaml_age: 18
yaml_city: Shanghai
</code></pre>
<ul>
<li>自定义标签格式解析</li>
</ul>
<pre><code class="language-go">package main

import (
	&quot;fmt&quot;
	&quot;reflect&quot;
)

type Person struct {
	Name string `aa:&quot;name&quot;`
	Age  int    `aa:&quot;age&quot;`
	City string `aa:&quot;city&quot;`
}

// CustomParse 自定义解析
func CustomParse(s interface{}) {
	// TypeOf type类型
	r:=reflect.TypeOf(s)
	value := reflect.ValueOf(s)
	for i:=0;i&lt;r.NumField();i++{
		field:=r.Field(i)
		key:=field.Name
		if tag, ok:=field.Tag.Lookup(&quot;aa&quot;);ok{
			if tag == &quot;-&quot;{
				continue
			}
			fmt.Printf(&quot;找到了aa标签, key: %v, value: %v, tag: %s\n&quot;, key, value.Field(i), tag)
		}
	}
}

func main() {
	p := Person{
		Name: &quot;geek&quot;,
		Age:  24,
		City: &quot;Beijing&quot;,
	}
	CustomParse(p)
	/*
	找到了aa标签, key: Name, value: geek, tag: name
	找到了aa标签, key: Age, value: 24, tag: age
	找到了aa标签, key: City, value: Beijing, tag: city
	 */
}
</code></pre>
<h2 id="4-反射调用函数">4、反射调用函数</h2>
<pre><code class="language-go">valueFunc := reflect.ValueOf(Add) //函数也是一种数据类型
typeFunc := reflect.TypeOf(Add)
argNum := typeFunc.NumIn()            //函数输入参数的个数
args := make([]reflect.Value, argNum) //准备函数的输入参数
for i := 0; i &lt; argNum; i++ {
	if typeFunc.In(i).Kind() == reflect.Int {
		args[i] = reflect.ValueOf(3) //给每一个参数都赋3
	}
}
sumValue := valueFunc.Call(args) //返回[]reflect.Value，因为go语言的函数返回可能是一个列表
if typeFunc.Out(0).Kind() == reflect.Int {
	sum := sumValue[0].Interface().(int) //从Value转为原始数据类型
	fmt.Printf(&quot;sum=%d\n&quot;, sum)
}
</code></pre>
<h2 id="5-反射调用方法">5、反射调用方法</h2>
<p>示例</p>
<pre><code class="language-go">user := User{
	Id:     7,
	Name:   &quot;杰克逊&quot;,
	Weight: 65.5,
	Height: 1.68,
}
valueUser := reflect.ValueOf(&amp;user)              //必须传指针，因为BMI()在定义的时候它是指针的方法
bmiMethod := valueUser.MethodByName(&quot;BMI&quot;)       //MethodByName()通过Name返回类的成员变量
resultValue := bmiMethod.Call([]reflect.Value{}) //无参数时传一个空的切片
result := resultValue[0].Interface().(float32)
fmt.Printf(&quot;bmi=%.2f\n&quot;, result)

//Think()在定义的时候用的不是指针，valueUser可以用指针也可以不用指针
thinkMethod := valueUser.MethodByName(&quot;Think&quot;)
thinkMethod.Call([]reflect.Value{})

valueUser2 := reflect.ValueOf(user)
thinkMethod = valueUser2.MethodByName(&quot;Think&quot;)
thinkMethod.Call([]reflect.Value{})
</code></pre>
<p>过程</p>
<ul>
<li>首先通过reflect.ValueOf(p1) 获取得到反射类型对象</li>
<li>reflect.ValueOf(p1).MethodByName需 要传入准确的方法名称（名称不对会panic: reflect: call of reflect.Value.Call on zero Value），MethodByName代表注册</li>
<li>[]reflect.Value 这是最终需要调用方法的参数，无参数传空切片</li>
<li>call调用</li>
</ul>
<pre><code class="language-go">package main

import (
	&quot;fmt&quot;
	&quot;reflect&quot;
)

type Person struct {
	Name   string
	Age    int
	Gender string
}

func (p Person) ReflectCallFuncWithArgs(name string, age int) {
	fmt.Printf(&quot;调用的是带参数的方法, args.name: %s, args.age: %d, p.name: %s, p.age: %d\n&quot;,
		name,
		age,
		p.Name,
		p.Age,
	)
}

func (p Person) ReflectCallFuncWithNoArgs() {
	fmt.Printf(&quot;调用的是不带参数的方法\n&quot;)
}

func main() {
	p1 := Person{
		Name:   &quot;geek&quot;,
		Age:    24,
		Gender: &quot;男&quot;,
	}
	// 1.首先通过reflect.ValueOf(p1)获取得到反射值类型
	getValue := reflect.ValueOf(p1)
	// 2.带参数的方法调用
	methodValue1 := getValue.MethodByName(&quot;ReflectCallFuncWithArgs&quot;)
	// 参数是reflect.Value的切片
	args1 := []reflect.Value{reflect.ValueOf(&quot;张三&quot;), reflect.ValueOf(30)}
	methodValue1.Call(args1)
	// 3.不带参数的方法调用
	methodValue2 := getValue.MethodByName(&quot;ReflectCallFuncWithNoArgs&quot;)
	// 参数是reflect.Value的切片
	args2 := make([]reflect.Value, 0)
	methodValue2.Call(args2)
	/*
	调用的是带参数的方法, args.name: 张三, args.age: 30, p.name: geek, p.age: 24
	调用的是不带参数的方法
	 */
}
</code></pre>
<h2 id="6-反射创建值">6、反射创建值</h2>
<h3 id="61-反射创建struct">6.1 反射创建struct</h3>
<pre><code class="language-go">t := reflect.TypeOf(User{})
value := reflect.New(t) //根据reflect.Type创建一个对象，得到该对象的指针，再根据指针提到reflect.Value
value.Elem().FieldByName(&quot;Id&quot;).SetInt(10)
value.Elem().FieldByName(&quot;Name&quot;).SetString(&quot;宋江&quot;)
value.Elem().FieldByName(&quot;Weight&quot;).SetFloat(78.)
value.Elem().FieldByName(&quot;Height&quot;).SetFloat(168.4)
user := value.Interface().(*User) //把反射类型转成go原始数据类型
fmt.Printf(&quot;id=%d name=%s weight=%.1f height=%.1f\n&quot;, user.Id, user.Name, user.Weight, user.Height)
</code></pre>
<h3 id="62-反射创建slice">6.2 反射创建slice</h3>
<pre><code class="language-go">var slice []User
sliceType := reflect.TypeOf(slice)
sliceValue := reflect.MakeSlice(sliceType, 1, 3) //reflect.MakeMap、reflect.MakeSlice、reflect.MakeChan、reflect.MakeFunc
sliceValue.Index(0).Set(reflect.ValueOf(User{
	Id:     8,
	Name:   &quot;李达&quot;,
	Weight: 80,
	Height: 180,
}))
users := sliceValue.Interface().([]User)
fmt.Printf(&quot;1st user name %s\n&quot;, users[0].Name)
</code></pre>
<h3 id="63-反射创建map">6.3 反射创建map</h3>
<pre><code class="language-go">var userMap map[int]*User
mapType := reflect.TypeOf(userMap)
// mapValue:=reflect.MakeMap(mapType)
mapValue := reflect.MakeMapWithSize(mapType, 10) //reflect.MakeMap、reflect.MakeSlice、reflect.MakeChan、reflect.MakeFunc

user := &amp;common.User{
	Id:     7,
	Name:   &quot;杰克逊&quot;,
	Weight: 65.5,
	Height: 1.68,
}
key := reflect.ValueOf(user.Id)
mapValue.SetMapIndex(key, reflect.ValueOf(user))                    //SetMapIndex 往map里添加一个key-value对
mapValue.MapIndex(key).Elem().FieldByName(&quot;Name&quot;).SetString(&quot;令狐一刀&quot;) //MapIndex 根据Key取出对应的map
userMap = mapValue.Interface().(map[int]*User)
fmt.Printf(&quot;user name %s %s\n&quot;, userMap[7].Name, user.Name)
</code></pre>
<h2 id="7-反射修改值">7、反射修改值</h2>
<p>反射修改值要求必须是指针类型</p>
<p>修改值的操作：pointer.Elem().Setxxx()</p>
<pre><code class="language-go">package main

import (
	&quot;fmt&quot;
	&quot;reflect&quot;
)

func main() {
	var num float64 = 3.14
	fmt.Printf(&quot;原始值 %f\n&quot;, num)
	// 通过reflect.ValueOf获取num中的value，必须是指针才可以修改值
	//pointer := reflect.ValueOf(num)  // 直接传值会panic
	pointer := reflect.ValueOf(&amp;num)
	newValue := pointer.Elem()
	// 赋新的值
	newValue.SetFloat(5.66)
	fmt.Printf(&quot;新的值 %f\n&quot;, num)
}
</code></pre>
<h3 id="71-反射修改struct">7.1 反射修改struct</h3>
<pre><code class="language-go">user := User{
	Id:     7,
	Name:   &quot;杰克逊&quot;,
	Weight: 65.5,
	Height: 1.68,
}
valueUser := reflect.ValueOf(&amp;user)
// valueS.Elem().SetInt(8)//会panic
valueUser.Elem().FieldByName(&quot;Weight&quot;).SetFloat(68.0) //FieldByName()通过Name返回类的成员变量。不能在指针Value上调用FieldByName
addrValue := valueUser.Elem().FieldByName(&quot;addr&quot;)
if addrValue.CanSet() {
	addrValue.SetString(&quot;北京&quot;)
} else {
	fmt.Println(&quot;addr是未导出成员，不可Set&quot;) //以小写字母开头的成员相当于是私有成员
}
</code></pre>
<h3 id="72-反射修改slice">7.2 反射修改slice</h3>
<p>下面示例，间接的实现了append功能</p>
<pre><code class="language-go">users := make([]*User, 1, 5) //len=1，cap=5

sliceValue := reflect.ValueOf(&amp;users) //准备通过Value修改users，所以传users的地址
if sliceValue.Elem().Len() &gt; 0 {      //取得slice的长度
	sliceValue.Elem().Index(0).Elem().FieldByName(&quot;Name&quot;).SetString(&quot;哈哈哈&quot;)
	// u0 := users[0]
	fmt.Printf(&quot;1st user name change to %s\n&quot;, users[0].Name)
}

sliceValue.Elem().SetCap(3) //新的cap必须位于原始的len到cap之间
sliceValue.Elem().SetLen(2)
//调用reflect.Value的Set()函数修改其底层指向的原始数据
sliceValue.Elem().Index(1).Set(reflect.ValueOf(&amp;User{
	Id:     8,
	Name:   &quot;geek&quot;,
	Weight: 80,
	Height: 180,
}))
fmt.Printf(&quot;2nd user name %s\n&quot;, users[1].Name)
</code></pre>
<h3 id="73-反射修改map">7.3 反射修改map</h3>
<pre><code class="language-go">u1 := &amp;User{
	Id:     7,
	Name:   &quot;杰克逊&quot;,
	Weight: 65.5,
	Height: 1.68,
}
u2 := &amp;User{
	Id:     8,
	Name:   &quot;杰克逊&quot;,
	Weight: 65.5,
	Height: 1.68,
}
userMap := make(map[int]*User, 5)
userMap[u1.Id] = u1

mapValue := reflect.ValueOf(&amp;userMap)                                                         //准备通过Value修改userMap，所以传userMap的地址
mapValue.Elem().SetMapIndex(reflect.ValueOf(u2.Id), reflect.ValueOf(u2))                      //SetMapIndex 往map里添加一个key-value对
mapValue.Elem().MapIndex(reflect.ValueOf(u1.Id)).Elem().FieldByName(&quot;Name&quot;).SetString(&quot;令狐一刀&quot;) //MapIndex 根据Key取出对应的map
for k, user := range userMap {
	fmt.Printf(&quot;key %d name %s\n&quot;, k, user.Name)
}
</code></pre>
<p>See you ~</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Golang反射-上篇]]></title>
        <id>https://www.ssgeek.com/post/golang-fan-she-shang-pian</id>
        <link href="https://www.ssgeek.com/post/golang-fan-she-shang-pian">
        </link>
        <updated>2021-11-11T17:01:31.000Z</updated>
        <content type="html"><![CDATA[<p><ul class="markdownIt-TOC">
<li>
<ul>
<li><a href="#1-%E5%8F%8D%E5%B0%84%E7%9A%84%E5%AE%9A%E4%B9%89">1、反射的定义</a></li>
<li><a href="#2-%E5%8F%8D%E5%B0%84%E7%9A%84%E5%9F%BA%E7%A1%80%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B">2、反射的基础数据类型</a></li>
<li><a href="#3-type">3、Type</a></li>
<li><a href="#4-value">4、Value</a></li>
<li><a href="#5-%E5%8F%8D%E5%B0%84%E4%B8%89%E5%A4%A7%E5%AE%9A%E5%BE%8B">5、反射三大定律</a>
<ul>
<li><a href="#51-%E5%8F%8D%E5%B0%84%E7%AC%AC%E4%B8%80%E5%AE%9A%E5%BE%8B">5.1 反射第一定律</a></li>
<li><a href="#52-%E5%8F%8D%E5%B0%84%E7%AC%AC%E4%BA%8C%E5%AE%9A%E5%BE%8B">5.2 反射第二定律</a></li>
<li><a href="#53-%E5%8F%8D%E5%B0%84%E7%AC%AC%E4%B8%89%E5%AE%9A%E5%BE%8B">5.3 反射第三定律</a></li>
</ul>
</li>
<li><a href="#6-%E5%8F%8D%E5%B0%84%E5%B8%B8%E7%94%A8%E7%9A%84api">6、反射常用的API</a>
<ul>
<li><a href="#61-%E8%8E%B7%E5%8F%96type%E7%B1%BB%E5%9E%8B">6.1 获取type类型</a></li>
<li><a href="#62-%E8%8E%B7%E5%8F%96field%E4%BF%A1%E6%81%AF">6.2 获取Field信息</a></li>
<li><a href="#63-%E8%8E%B7%E5%8F%96method%E4%BF%A1%E6%81%AF">6.3 获取method信息</a></li>
<li><a href="#64-%E8%8E%B7%E5%8F%96%E5%87%BD%E6%95%B0%E4%BF%A1%E6%81%AF">6.4 获取函数信息</a></li>
<li><a href="#65-%E8%B5%8B%E5%80%BC%E5%92%8C%E8%BD%AC%E6%8D%A2%E5%85%B3%E7%B3%BB">6.5 赋值和转换关系</a></li>
<li><a href="#66-%E6%98%AF%E5%90%A6%E5%AE%9E%E7%8E%B0%E6%8E%A5%E5%8F%A3">6.6 是否实现接口</a></li>
<li><a href="#67-value%E5%92%8C%E5%85%B6%E4%BB%96%E7%B1%BB%E5%9E%8B%E7%9A%84%E4%BA%92%E6%8D%A2">6.7 value和其他类型的互换</a></li>
<li><a href="#68-value%E5%88%A4%E6%96%AD%E7%A9%BA%E5%80%BC%E7%9A%84%E4%B8%89%E7%A7%8D%E6%83%85%E5%86%B5">6.8 value判断空值的三种情况</a></li>
</ul>
</li>
</ul>
</li>
</ul>
</p>
<figure data-type="image" tabindex="1"><img src="https://image.ssgeek.com/golang.png" alt=""></figure>
<h2 id="1-反射的定义">1、反射的定义</h2>
<blockquote>
<p>It’s a great source of confusion ~ （引用自官方博客）</p>
</blockquote>
<p>反射是指在运行时动态的访问和修改任意类型对象的结构和成员，在<code>go</code>语言中提供<code>reflect</code>包提供反射的功能，每一个变量都有两个属性：类型<code>Type</code>和值<code>Value</code></p>
<p>反射能够自描述自控制<br>
例如<code>python</code>的反射：根据字符串执行函数，根据字符串导入包</p>
<p><code>go</code>是静态语言，反射就是<code>go</code>提供的一种机制，在编译时不知道类型的情况下可以做如下的事情</p>
<ul>
<li>更新变量</li>
<li>运行时查看值</li>
<li>调用方法</li>
<li>对他们的布局进行操作</li>
</ul>
<p>使用反射的两个经典场景</p>
<ul>
<li>
<p>你编写的这个函数，还不知道传给你的类型具体是什么，可能是还没约定好，也可能是传入的类型很多</p>
</li>
<li>
<p>希望通过用户的输入来决定调用哪个函数（根据字符串调用方法），动态执行函数</p>
</li>
</ul>
<h2 id="2-反射的基础数据类型">2、反射的基础数据类型</h2>
<figure data-type="image" tabindex="2"><img src="https://image.ssgeek.com/20211112-01.png" alt=""></figure>
<h2 id="3-type">3、Type</h2>
<p><code>reflect.Type</code>是一个接口类型，用于获取变量类型相关的信息，可通过<code>reflect.TypeOf</code>函数获取某个变量的类型信息</p>
<p>源码<code>go/src/reflect/type.go</code></p>
<pre><code class="language-go">type Type interface {
	Align() int
	FieldAlign() int
	Method(int) Method  // 第 i 个方法
	MethodByName(string) (Method, bool)  // 根据名称获取方法
	NumMethod() int  // 方法的个数
	Name() string  // 获取结构体名称
	PkgPath() string  // 包路径
	Size() uintptr  // 占用内存的大小
	String() string  // 获取字符串表述
	Kind() Kind // 数据类型
	Implements(u Type) bool  // 判断是否实现了某接口
	AssignableTo(u Type) bool  // 能否赋给另外一种类型
	ConvertibleTo(u Type) bool  // 能否转换为另外一种类型
	Comparable() bool
	Bits() int
	ChanDir() ChanDir
	IsVariadic() bool
	Elem() Type  // 解析指针（指针类型转为普通类型）
	Field(i int) StructField  // 第i个成员
	FieldByIndex(index []int) StructField  // 根据index路径获取嵌套成员
	FieldByName(name string) (StructField, bool)  // 根据名称获取成员
	FieldByNameFunc(match func(string) bool) (StructField, bool)
	In(i int) Type
	Key() Type
	Len() int  // 容器的长度
	NumField() int
	NumIn() int  // 输出参数的个数
	NumOut() int  // 返回参数的个数
	Out(i int) Type

	common() *rtype
	uncommon() *uncommonType
}
</code></pre>
<h2 id="4-value">4、Value</h2>
<p><code>reflect.Value</code>是一个结构体类型，用于获取变量值的信息，可通过<code>reflect.ValueOf</code>函数获取修改原始数据类型(某个变量)的值信息</p>
<p>源码<code>go/src/reflect/value.go</code></p>
<pre><code class="language-go">type Value struct {
   // 代表的数据类型
	typ *rtype
	// 指向原始数据的指针
	ptr unsafe.Pointer
}
</code></pre>
<h2 id="5-反射三大定律">5、反射三大定律</h2>
<p><code>interface</code>类型有个<code>value</code>，<code>type</code>对，而反射就是检查<code>interface</code>的这个<code>value</code>, <code>type</code>对的<br>
具体一点说就是<code>Go</code>提供一组方法提取<code>interface</code>的<code>value</code>，提供另一组方法提取<code>interface</code>的<code>type</code></p>
<ul>
<li><code>reflect.Type</code>提供一组接口处理<code>interface</code>的类型，即<code>value</code>, <code>type</code>中的<code>type</code></li>
<li><code>reflect.Value</code>提供一组接口处理<code>interface</code>的值,即<code>value</code>, <code>type</code>中的<code>value</code></li>
</ul>
<h3 id="51-反射第一定律">5.1 反射第一定律</h3>
<p>反射第一定律：反射可以将<code>interface</code>类型变量转换成反射对象</p>
<p>如何通过反射获取一个变量的值和类型</p>
<pre><code class="language-go">package main
import (
    &quot;fmt&quot;
    &quot;reflect&quot;
)
func main() {
    var x float64 = 3.4
    t := reflect.TypeOf(x)  //t is reflext.Type
    fmt.Println(&quot;type:&quot;, t)
    fmt.Println(&quot;kind is float64:&quot;, v.Kind() == reflect.Float64)
    v := reflect.ValueOf(x) //v is reflext.Value
    fmt.Println(&quot;value:&quot;, v)
}
</code></pre>
<p>程序输出</p>
<pre><code class="language-go">type: float64
kind is float64: true
value: 3.4
</code></pre>
<p>反射是针对<code>interface</code>类型变量的，其中<code>TypeOf()</code>和<code>ValueOf()</code>接受的参数都是<code>interface{}</code>类型的，也即<code>x</code>值是被转成了<code>interface</code>传入的</p>
<h3 id="52-反射第二定律">5.2 反射第二定律</h3>
<p>反射第二定律：反射可以将反射对象还原成<code>interface</code>对象</p>
<p>之所以叫’反射’，反射对象与<code>interface</code>对象是可以互相转化的</p>
<pre><code class="language-go">package main
import (
    &quot;fmt&quot;
    &quot;reflect&quot;
)
func main() {
    var x float64 = 3.4
    v := reflect.ValueOf(x) //v is reflext.Value
    var y float64 = v.Interface().(float64)
    fmt.Println(&quot;value:&quot;, y)
}
</code></pre>
<p>对象<code>x</code>转换成反射对象<code>v</code>，<code>v</code>又通过<code>Interface()</code>接口转换成<code>interface</code>对象，<code>interface</code>对象通过<code>.(float64)</code>类型断言获取<code>float64</code>类型的值</p>
<h3 id="53-反射第三定律">5.3 反射第三定律</h3>
<p>反射第三定律：反射对象可修改，<code>value</code>值必须是可设置的</p>
<p>通过反射可以将<code>interface</code>类型变量转换成反射对象，可以使用该反射对象设置其持有的值</p>
<pre><code class="language-go">package main
import (
    &quot;reflect&quot;
)
func main() {
    var x float64 = 3.4
    v := reflect.ValueOf(x)
    v.SetFloat(7.1) // Error: will panic.
}
</code></pre>
<p>通过反射对象v设置新值，会出现<code>panic</code></p>
<pre><code>panic: reflect: reflect.Value.SetFloat using unaddressable value
</code></pre>
<p>错误原因即是<code>v</code>是不可修改的。</p>
<p>反射对象是否可修改取决于其所存储的值，回想一下函数传参时是传值还是传址就不难理解上例中为何失败了。</p>
<p>上面例子传入<code>reflect.ValueOf()</code>函数的其实是<code>x</code>的值，而非<code>x</code>本身。即通过<code>v</code>修改其值是无法影响<code>x</code>的，也即是无效的修改，所以<code>golang</code>会报错</p>
<p>想到此处，即可明白，如果构建<code>v</code>时使用<code>x</code>的地址就可实现修改了，但此时<code>v</code>代表的是指针地址，我们要设置的是指针所指向的内容，也即我们想要修改的是<code>*v</code>。 通过<code>v</code>修改<code>x</code>的值?</p>
<p><code>reflect.Value</code>提供了<code>Elem()</code>方法，可以获得指针向指向的<code>value</code></p>
<pre><code class="language-go">package main
import (
&quot;reflect&quot;
    &quot;fmt&quot;
)
func main() {
    var x float64 = 3.4
    v := reflect.ValueOf(&amp;x)
    v.Elem().SetFloat(7.1)
    fmt.Println(&quot;x :&quot;, v.Elem().Interface())
}
</code></pre>
<p>输出为：</p>
<pre><code>x : 7.1
</code></pre>
<h2 id="6-反射常用的api">6、反射常用的API</h2>
<h3 id="61-获取type类型">6.1 获取type类型</h3>
<pre><code class="language-go">typeUser := reflect.TypeOf(&amp;User{}) //通过TypeOf()得到Type类型
fmt.Println(typeUser)                      //*User
fmt.Println(typeUser.Elem())               //User
fmt.Println(typeUser.Name())               //空字符串
fmt.Println(typeUser.Elem().Name())        //User，不带包名的类名称
fmt.Println(typeUser.Kind())               //ptr
fmt.Println(typeUser.Elem().Kind())        //struct
fmt.Println(typeUser.Kind() == reflect.Ptr)
fmt.Println(typeUser.Elem().Kind() == reflect.Struct)
</code></pre>
<h3 id="62-获取field信息">6.2 获取Field信息</h3>
<pre><code class="language-go">typeUser := reflect.TypeOf(User{}) //需要用struct的Type，不能用指针的Type
fieldNum := typeUser.NumField()           //成员变量的个数
for i := 0; i &lt; fieldNum; i++ {
	field := typeUser.Field(i)
	fmt.Printf(&quot;%d %s offset %d anonymous %t type %s exported %t json tag %s\n&quot;, i,
		field.Name,            //变量名称
		field.Offset,          //相对于结构体首地址的内存偏移量，string类型会占据16个字节
		field.Anonymous,       //是否为匿名成员
		field.Type,            //数据类型，reflect.Type类型
		field.IsExported(),    //包外是否可见（即是否以大写字母开头）
		field.Tag.Get(&quot;json&quot;)) //获取成员变量后面``里面定义的tag
//可以通过FieldByName获取Field
if nameField, ok := typeUser.FieldByName(&quot;Name&quot;); ok {
	fmt.Printf(&quot;Name is exported %t\n&quot;, nameField.IsExported())
}
//也可以根据FieldByIndex获取Field
thirdField := typeUser.FieldByIndex([]int{2}) //参数是个slice，因为有struct嵌套的情况
fmt.Printf(&quot;third field name %s\n&quot;, thirdField.Name)
}
</code></pre>
<h3 id="63-获取method信息">6.3 获取method信息</h3>
<pre><code class="language-go">typeUser := reflect.TypeOf(common.User{})
methodNum := typeUser.NumMethod() //成员方法的个数。接收者为指针的方法【不】包含在内
for i := 0; i &lt; methodNum; i++ {
	method := typeUser.Method(i)
	fmt.Println(method.Type)  // 会输出函数完整的签名，其中输入参数会将结构体本身也作为输入参数，因此参数个数多一个
	fmt.Printf(&quot;method name:%s ,type:%s, exported:%t\n&quot;, method.Name, method.Type, method.IsExported())
}
fmt.Println()
if method, ok := typeUser.MethodByName(&quot;Examine2&quot;); ok {  // 根据方法名获取
	fmt.Printf(&quot;method name:%s ,type:%s, exported:%t\n&quot;, method.Name, method.Type, method.IsExported())
}
typeUser2 := reflect.TypeOf(&amp;common.User{})
methodNum = typeUser2.NumMethod() //成员方法的个数。接收者为指针或值的方法都包含在内，也就是说值实现的方法指针也实现了（反之不成立）
for i := 0; i &lt; methodNum; i++ {
	method := typeUser2.Method(i)
	fmt.Printf(&quot;method name:%s ,type:%s, exported:%t\n&quot;, method.Name, method.Type, method.IsExported())
}
</code></pre>
<h3 id="64-获取函数信息">6.4 获取函数信息</h3>
<pre><code class="language-go">typeFunc := reflect.TypeOf(Add) //获取函数类型
fmt.Printf(&quot;is function type %t\n&quot;, typeFunc.Kind() == reflect.Func)
argInNum := typeFunc.NumIn()   //输入参数的个数
argOutNum := typeFunc.NumOut() //输出参数的个数
for i := 0; i &lt; argInNum; i++ {
	argTyp := typeFunc.In(i)
	fmt.Printf(&quot;第%d个输入参数的类型%s\n&quot;, i, argTyp)
}
for i := 0; i &lt; argOutNum; i++ {
	argTyp := typeFunc.Out(i)
	fmt.Printf(&quot;第%d个输出参数的类型%s\n&quot;, i, argTyp)
}
</code></pre>
<h3 id="65-赋值和转换关系">6.5 赋值和转换关系</h3>
<ul>
<li>type1.AssignableTo(type2)  // type1代表的类型是否可以赋值给type2代表的类型</li>
<li>type1.ConvertibleTo(type2)) // type1代表的类型是否可以转换成type2代表的类型</li>
<li>java的反射可以获取继承关系，而go语言不支持继承，所以必须是相同的类型才能AssignableTo和ConvertibleTo</li>
</ul>
<p>示例</p>
<pre><code class="language-go">u := reflect.TypeOf(User{})
t := reflect.TypeOf(Student{}) //Student内部嵌套了User
u2 := reflect.TypeOf(User{})

//false false
fmt.Println(t.AssignableTo(u))  //t代表的类型是否可以赋值给u代表的类型
fmt.Println(t.ConvertibleTo(u)) //t代表的类型是否可以转换成u代表的类型

//false false
fmt.Println(u.AssignableTo(t))
fmt.Println(u.ConvertibleTo(t))

//true true
fmt.Println(u.AssignableTo(u2))
fmt.Println(u.ConvertibleTo(u2))
</code></pre>
<h3 id="66-是否实现接口">6.6 是否实现接口</h3>
<pre><code class="language-go">//通过reflect.TypeOf((*&lt;interface&gt;)(nil)).Elem()获得接口类型。因为People是个接口不能创建实例，所以把nil强制转为*common.People类型
typeOfPeople := reflect.TypeOf((*common.People)(nil)).Elem()  // 可以将nil理解成People指针的一个实例
fmt.Printf(&quot;typeOfPeople kind is interface %t\n&quot;, typeOfPeople.Kind() == reflect.Interface)
t1 := reflect.TypeOf(common.User{})
t2 := reflect.TypeOf(&amp;common.User{})
//User的值类型实现了接口，则指针类型也实现了接口；但反过来不行(把Think的接收者改为*User试试)
fmt.Printf(&quot;t1 implements People interface %t\n&quot;, t1.Implements(typeOfPeople))  // false
fmt.Printf(&quot;t2 implements People interface %t\n&quot;, t2.Implements(typeOfPeople))  // true
</code></pre>
<h3 id="67-value和其他类型的互换">6.7 value和其他类型的互换</h3>
<pre><code class="language-go">//原始类型转为Value
iValue := reflect.ValueOf(1)
sValue := reflect.ValueOf(&quot;hello&quot;)
userPtrValue := reflect.ValueOf(&amp;common.User{
	Id:     7,
	Name:   &quot;杰克逊&quot;,
	Weight: 65,
	Height: 1.68,
})
fmt.Println(iValue)       //1
fmt.Println(sValue)       //hello
fmt.Println(userPtrValue) //&amp;{7 杰克逊  65 1.68}
//Value转为Type
iType := iValue.Type()
sType := sValue.Type()
userType := userPtrValue.Type()
//在Type和相应Value上调用Kind()结果一样的
fmt.Println(iType.Kind() == reflect.Int, iValue.Kind() == reflect.Int, iType.Kind() == iValue.Kind())                   //true true
fmt.Println(sType.Kind() == reflect.String, sValue.Kind() == reflect.String, sType.Kind() == sValue.Kind())             //true true
fmt.Println(userType.Kind() == reflect.Ptr, userPtrValue.Kind() == reflect.Ptr, userType.Kind() == userPtrValue.Kind()) //true true true

//指针Value和非指针Value互相转换
userValue := userPtrValue.Elem()                    //Elem() 指针Value转为非指针Value
fmt.Println(userValue.Kind(), userPtrValue.Kind())  //struct ptr
userPtrValue3 := userValue.Addr()                   //Addr() 非指针Value转为指针Value
fmt.Println(userValue.Kind(), userPtrValue3.Kind()) //struct ptr

//转为原始类型
//通过Interface()函数把Value转为interface{}，再从interface{}强制类型转换，转为原始数据类型
//或者在Value上直接调用Int()、String()等一步到位
fmt.Printf(&quot;origin value iValue is %d %d\n&quot;, iValue.Interface().(int), iValue.Int())
fmt.Printf(&quot;origin value sValue is %s %s\n&quot;, sValue.Interface().(string), sValue.String())
user := userValue.Interface().(common.User)
fmt.Printf(&quot;id=%d name=%s weight=%.2f height=%.2f\n&quot;, user.Id, user.Name, user.Weight, user.Height)
user2 := userPtrValue.Interface().(*common.User)
fmt.Printf(&quot;id=%d name=%s weight=%.2f height=%.2f\n&quot;, user2.Id, user2.Name, user2.Weight, user2.Height)
</code></pre>
<h3 id="68-value判断空值的三种情况">6.8 value判断空值的三种情况</h3>
<p><code>pointer</code>、<code>channel</code>、<code>func</code>、<code>interface</code>、<code>map</code>、<code>slice</code>的预先声明都是<code>nil</code></p>
<pre><code class="language-go">var i interface{} //接口没有指向具体的值
v := reflect.ValueOf(i)
fmt.Printf(&quot;v持有值 %t, type of v is Invalid %t\n&quot;, v.IsValid(), v.Kind() == reflect.Invalid)  // false

var user *common.User = nil
v = reflect.ValueOf(user) //Value指向一个nil
if v.IsValid() {
	fmt.Printf(&quot;v持有的值是nil %t\n&quot;, v.IsNil()) //调用IsNil()前先确保IsValid()，否则会panic  // true
}

var u common.User //只声明，里面的值都是0值
v = reflect.ValueOf(u)
if v.IsValid() {
	fmt.Printf(&quot;v持有的值是对应类型的0值 %t\n&quot;, v.IsZero()) //调用IsZero()前先确保IsValid()，否则会panic  // true
}
</code></pre>
<blockquote>
<p>参考： https://go.dev/blog/laws-of-reflection</p>
</blockquote>
<p>See you ~</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Helm Chart语法概要]]></title>
        <id>https://www.ssgeek.com/post/helm-chart-yu-fa-gai-yao</id>
        <link href="https://www.ssgeek.com/post/helm-chart-yu-fa-gai-yao">
        </link>
        <updated>2021-11-04T16:42:24.000Z</updated>
        <content type="html"><![CDATA[<p><ul class="markdownIt-TOC">
<li>
<ul>
<li><a href="#1-%E6%A6%82%E8%BF%B0">1、概述</a></li>
<li><a href="#2-%E8%B0%83%E8%AF%95">2、调试</a></li>
<li><a href="#3-%E5%86%85%E7%BD%AE%E5%AF%B9%E8%B1%A1">3、内置对象</a></li>
<li><a href="#4-values">4、Values</a></li>
<li><a href="#5-%E7%AE%A1%E9%81%93%E4%B8%8E%E5%87%BD%E6%95%B0">5、管道与函数</a></li>
<li><a href="#6-%E6%B5%81%E7%A8%8B%E6%8E%A7%E5%88%B6">6、流程控制</a>
<ul>
<li><a href="#61-if">6.1 if</a></li>
<li><a href="#62-with">6.2 with</a></li>
<li><a href="#63-range">6.3 range</a></li>
</ul>
</li>
<li><a href="#7-%E5%8F%98%E9%87%8F">7、变量</a></li>
<li><a href="#8-%E5%91%BD%E5%90%8D%E6%A8%A1%E6%9D%BF">8、命名模板</a></li>
<li><a href="#9-%E5%BC%80%E5%8F%91chart%E7%9A%84%E6%B5%81%E7%A8%8B">9、开发Chart的流程</a></li>
</ul>
</li>
</ul>
</p>
<figure data-type="image" tabindex="1"><img src="https://image.ssgeek.com/20211105-01.png" alt=""></figure>
<blockquote>
<p>由于博客编译问题暂未修复，文中的{}实际上都是{{}}</p>
</blockquote>
<h2 id="1-概述">1、概述</h2>
<p>前面分别写到了 <a href="https://www.ssgeek.com/post/jenkinspipeline-yu-fa-gai-yao">JenkinsPipeline语法概要</a> 和 <a href="https://www.ssgeek.com/post/dockerfile-yu-fa-gai-yao">Dockerfile语法概要</a>，最近又重新拾起了<code>Helm Chart</code>，刚好回忆一下其语法 ~</p>
<p><code>Helm</code>是<code>k8s</code>中的一个包管理工具，可以用来部署<code>k8s</code>资源。在<code>Helm</code>中最核心的就是模板，即模板化的<code>k8s manifests</code>文件</p>
<p>它本质上就是一个<code>Go</code>的<code>template</code>模板。<code>Helm</code>在<code>Go template</code>模板的基础上，还会增加很多东西。如一些自定义的元数据信息、扩展的库以及一些类似于编程形式的工作流，例如条件语句、管道等等。这些东西都会使得模板变得更加丰富</p>
<p>有了模板，怎么把配置融入进去，用的就是<code>values.yaml</code>文件</p>
<h2 id="2-调试">2、调试</h2>
<p><code>Helm</code>也提供了<code>--dry-run --debug</code>调试参数，帮助验证模板正确性。在执行<code>helm install</code>时候带上这两个参数就可以把对应的<code>values</code>值和渲染的资源清单打印出来，而不会真正的去部署一个<code>release</code></p>
<p>比如来调试创建的一个<code>chart</code>包：</p>
<pre><code># helm install web --dry-run /root/mychart
</code></pre>
<h2 id="3-内置对象">3、内置对象</h2>
<p>使用 <code>{.Release.Name}</code>将<code>release</code>的名称插入到模板中。这里的<code>Release</code>就是<code>Helm</code>的内置对象，下面是一些常用的内置对象</p>
<table>
<thead>
<tr>
<th>Release.Name</th>
<th>release 名称</th>
</tr>
</thead>
<tbody>
<tr>
<td>Release.Name</td>
<td>release 名字</td>
</tr>
<tr>
<td>Release.Namespace</td>
<td>release 命名空间</td>
</tr>
<tr>
<td>Release.Service</td>
<td>release 服务的名称</td>
</tr>
<tr>
<td>Release.Revision</td>
<td>release 修订版本号，从1开始累加</td>
</tr>
</tbody>
</table>
<h2 id="4-values">4、Values</h2>
<p><code>Values</code>对象是为<code>Chart</code>模板提供值，这个对象的值有<code>4</code>个来源</p>
<ul>
<li>
<p><code>chart</code>包中的<code>values.yaml</code>文件</p>
</li>
<li>
<p>父<code>chart</code>包的<code>values.yaml</code>文件</p>
</li>
<li>
<p>通过<code>helm install</code>或者<code>helm upgrade</code>的 <code>-f</code>或者 <code>--values</code>参数传入的自定义的<code>yaml</code>文件</p>
</li>
<li>
<p>通过 <code>--set</code> 参数传入的值</p>
</li>
</ul>
<p><code>chart</code>的<code>values.yaml</code>提供的值可以被用户提供的<code>values</code>文件覆盖，而该文件同样可以被 <code>--set</code>提供的参数所覆盖</p>
<p>编辑<code>mychart/values.yaml</code>文件，将默认的值全部清空，然后添加一个副本数</p>
<pre><code class="language-yaml"># cat values.yaml 
replicas: 3
image: &quot;nginx&quot;
imageTag: &quot;1.17&quot;

# cat templates/deployment.yaml 
apiVersion: apps/v1
kind: Deployment
metadata:
  name: { .Release.Name }-deployment
spec:
  replicas: { .Values.replicas }
  selector:
    matchLabels:
      app: nginx
  template:
    metadata:
      labels:
        app: nginx
    spec:
      containers:
      - image: { .Values.image }:{ .Values.imageTag }
        name: nginx
</code></pre>
<p>查看渲染结果：</p>
<pre><code class="language-shell"># helm install --dry-run web ../mychart/
</code></pre>
<p><code>values</code>文件也可以包含结构化内容，例如</p>
<pre><code class="language-yaml"># cat values.yaml 
...
label:
  project: ms
  app: nginx

# cat templates/deployment.yaml 
apiVersion: apps/v1
kind: Deployment
metadata:
  name: { .Release.Name }-deployment 
spec:
  replicas: { .Values.replicas } 
  selector:
    matchLabels:
      project: { .Values.label.project }
      app: { .Values.label.app }
  template:
    metadata:
      labels:
        project: { .Values.label.project }
        app: { .Values.label.app }
    spec:
      containers:
      - image: { .Values.image }:{ .Values.imageTag } 
        name: nginx
</code></pre>
<p>查看渲染结果：</p>
<pre><code># helm install --dry-run web ../mychart/
</code></pre>
<h2 id="5-管道与函数">5、管道与函数</h2>
<p>前面讲的相关模块，其实就是将值传给模板引擎进行渲染，模板引擎还支持对拿到数据进行二次处理</p>
<p>例如从<code>.Values</code>中读取的值变成字符串，可以使用<code>quote</code>函数实现</p>
<pre><code class="language-yaml"># vi templates/deployment.yaml
app: { quote .Values.label.app }
# helm install --dry-run web ../mychart/ 
        project: ms
        app: &quot;nginx&quot;
</code></pre>
<p><code>quote .Values.label.app</code>将后面的值作为参数传递给<code>quote</code>函数</p>
<p>模板函数调用语法为：<code>functionName arg1 arg2...</code></p>
<p>另外还会经常使用一个<code>default</code>函数，该函数允许在模板中指定默认值，以防止该值被忽略掉</p>
<p>例如忘记定义，执行<code>helm install</code>会因为缺少字段无法创建资源，这时就可以定义一个默认值</p>
<pre><code class="language-yaml"># cat values.yaml 
replicas: 2
# cat templates/deployment.yaml 
apiVersion: apps/v1
kind: Deployment
metadata:
- name: { .Values.name | default &quot;nginx&quot; }
</code></pre>
<p>其他常用函数</p>
<ul>
<li>
<p>缩进：<code>{ .Values.resources | indent 12 }</code></p>
</li>
<li>
<p>大写：<code>{ upper .Values.resources }</code></p>
</li>
<li>
<p>首字母大写：<code>{ title .Values.resources }</code></p>
</li>
</ul>
<h2 id="6-流程控制">6、流程控制</h2>
<p>流程控制是为模板提供了一种能力，满足更复杂的数据逻辑处理</p>
<p><code>Helm</code>模板语言提供以下流程控制语句</p>
<ul>
<li><code>if/else</code> 条件块</li>
<li><code>with</code> 指定范围</li>
<li><code>range</code> 循环块</li>
</ul>
<h3 id="61-if">6.1 if</h3>
<p><code>if/else</code>块是用于在模板中有条件地包含文本块的方法，条件块的基本结构如下</p>
<pre><code class="language-yaml">{ if PIPELINE }
  # Do something
{ else if OTHER PIPELINE }
  # Do something else
{ else }
  # Default case
{ end }
</code></pre>
<p>示例</p>
<pre><code class="language-yaml"># cat values.yaml 
devops: k8

# cat templates/deployment.yaml 
...
  template:
    metadata:
      labels:
        app: nginx
        { if eq .Values.devops &quot;k8s&quot; }
        devops: 123
        { else }
        devops: 456
        { end }
</code></pre>
<p>在上面条件语句使用了<code>eq</code>运算符判断是否相等，除此之外，还支持<code>ne</code>、 <code>lt</code>、 <code>gt</code>、 <code>and</code>、 <code>or</code>等运算符</p>
<p>通过模板引擎来渲染一下，会得到如下结果</p>
<pre><code class="language-yaml"># helm install --dry-run web ../mychart/ 
...
      labels:
        app: nginx

        devops: 456
       
</code></pre>
<p>可以看到渲染出来会有多余的空行，这是因为当模板引擎运行时，会将控制指令删除，所有之前占的位置也就空白了，需要使用<code>{- if ...}</code>的方式消除此空行</p>
<pre><code class="language-yaml"># cat templates/deploymemt.yaml
...
        env:
        {- if eq .Values.env.hello &quot;world&quot; }
          - name: hello
            value: 123
        {- end }
</code></pre>
<p>现在就没有多余的空格了，如果使用<code>-}</code>需谨慎，比如上面模板文件中</p>
<pre><code class="language-yaml"># cat templates/deploymemt.yaml
...
       env:
        {- if eq .Values.env.hello &quot;world&quot; -}
           - hello: true
        {- end }
</code></pre>
<p>这会渲染成：</p>
<pre><code class="language-yaml">        env:- hello: true
</code></pre>
<p>因为<code>-}</code>它删除了双方的换行符</p>
<p>条件判断就是判断条件是否为真，如果值为以下几种情况则为<code>false</code></p>
<ul>
<li>
<p>一个布尔类型的 <code>假</code></p>
</li>
<li>
<p>一个数字 <code>零</code></p>
</li>
<li>
<p>一个 <code>空</code>的字符串</p>
</li>
<li>
<p>一个 <code>nil</code>（空或 <code>null</code>）</p>
</li>
<li>
<p>一个空的集合（ <code>map</code>、 <code>slice</code>、 <code>tuple</code>、 <code>dict</code>、 <code>array</code>）</p>
</li>
</ul>
<p>除了上面的这些情况外，其他所有条件都为 <code>真</code></p>
<p>例如，判断一个空的数组</p>
<pre><code class="language-yaml"># cat values.yaml 
resources: {}
  # limits:
  #   cpu: 100m
  #   memory: 128Mi
  # requests:
  #   cpu: 100m
  #   memory: 128Mi

# cat templates/deploymemt.yaml
...
    spec:
      containers:
      - image: nginx:1.16
        name: nginx
        {- if .Values.resources }
        resources:
{ toYaml .Values.resources | indent 10 }
        {- end }
</code></pre>
<p>例如，判断一个布尔值</p>
<pre><code class="language-yaml"># cat values.yaml 
service:
  type: ClusterIP
  port: 80

ingress:
  enabled: true 
  host: example.ssgeek.com

# cat templates/ingress.yaml 
{- if .Values.ingress.enabled -}
apiVersion: networking.k8s.io/v1beta1
kind: Ingress
metadata:
  name: { .Release.Name }-ingress
spec:
  rules:
  - host: { .Values.ingress.host }
    http:
      paths:
      - path: /
        backend:
          serviceName: { .Release.Name }
          servicePort: { .Values.service.port }
{ end }
</code></pre>
<h3 id="62-with">6.2 with</h3>
<p><code>with</code> ：控制变量作用域</p>
<p>之前的 <code>{.Release.xxx}</code>或者 <code>{.Values.xxx}</code>，其中的 <code>.</code>就是表示对当前范围的引用， <code>.Values</code>就是告诉模板在当前范围中查找 <code>Values</code>对象的值。而 <code>with</code>语句就可以来控制变量的作用域范围，其语法和一个简单的 <code>if</code>语句比较类似</p>
<pre><code class="language-yaml">{ with PIPELINE }
  #  restricted scope
{ end }
</code></pre>
<p><code>with</code>语句可以允许将当前范围 <code>.</code>设置为特定的对象，比如前面一直使用的 <code>.Values.label</code>，可以使用 <code>with</code>来将 <code>.</code>范围指向 <code>.Values.label</code></p>
<pre><code class="language-yaml"># cat values.yaml 
...
replicas: 3
label:
  project: ms
  app: nginx

# cat templates/deployment.yaml 
apiVersion: apps/v1
kind: Deployment
metadata:
  name: { .Release.Name }-deployment
spec:
  replicas: 1
  selector:
    matchLabels:
      app: nginx
  template:
    metadata:
      labels:
        app: nginx
    spec:
      {- with .Values.nodeSelector }
      nodeSelector:
        team: { .team }
        gpu: { .gpu }
      {- end }
      containers:
      - image: nginx:1.16
        name: nginx
</code></pre>
<p>优化后</p>
<pre><code class="language-yaml">
      {- with .Values.nodeSelector }
      nodeSelector:
        {- toYaml . | nindent 8 }
      {- end }
</code></pre>
<p>上面增加了一个<code>{- with .Values.label } xxx {- end }</code>的一个块，这样的话就可以在当前的块里面直接引用 <code>.team</code>和 <code>.gpu</code>了</p>
<p><code>with</code>是一个循环构造。使用<code>Values.nodeSelector</code>中的值：将其转换为<code>Yaml</code></p>
<p><code>toYaml</code>之后的点是循环中<code>.Values.nodeSelector</code>的当前值</p>
<h3 id="63-range">6.3 range</h3>
<p>在<code>Helm</code>模板语言中，使用 <code>range</code>关键字来进行循环操作</p>
<p>在 <code>values.yaml</code>文件中添加上一个变量列表</p>
<pre><code class="language-yaml"># cat values.yaml 
test:
  - 1
  - 2
  - 3
</code></pre>
<p>循环打印该列表</p>
<pre><code class="language-yaml">apiVersion: v1
kind: ConfigMap
metadata:
  name: { .Release.Name }
data:
  test: |
  {- range .Values.test }
    { . }
  {- end }
</code></pre>
<p>循环内部使用的是一个 <code>.</code>，这是因为当前的作用域就在当前循环内，这个 <code>.</code>引用的当前读取的元素</p>
<h2 id="7-变量">7、变量</h2>
<p>这是语言中基本的概念：<strong>变量</strong>，在模板中，使用变量的场合不多，但可以看到如何使用它来简化代码，并更好地利用<code>with</code>和<code>range</code>，举例如下</p>
<p><strong>例子1：获取列表键值</strong></p>
<pre><code class="language-yaml"># cat ../values.yaml
env:
  NAME: &quot;gateway&quot;
  JAVA_OPTS: &quot;-Xmx1G&quot;
  
# cat deployment.yaml 
...
		env:
		{- range $k, $v := .Values.env }
           - name: { $k }
             value: { $v | quote }
        {- end }
</code></pre>
<p>结果如下</p>
<pre><code class="language-yaml">    env:
       - name: JAVA_OPTS
         value: &quot;-Xmx1G&quot;
       - name: NAME
         value: &quot;gateway&quot;
</code></pre>
<p>上面在 <code>range</code>循环中使用 <code>$key</code>和 <code>$value</code>两个变量来接收后面列表循环的键和值</p>
<p><strong>例子2：with中不能使用内置对象</strong></p>
<p><code>with</code>语句块内不能再 <code>.Release.Name</code>对象，否则报错</p>
<p>可以将该对象赋值给一个变量可以来解决这个问题</p>
<pre><code class="language-yaml">apiVersion: apps/v1
kind: Deployment
metadata:
  name: { .Release.Name }-deployment
spec:
  replicas: { .Values.replicas }
  template:
    metadata:
      labels:
        project: { .Values.label.project }
        app: { quote .Values.label.app }
      {- with .Values.label }
        project: { .project }
        app: { .app }
        release: { .Release.Name }
      {- end }
</code></pre>
<p>上面会出错</p>
<pre><code class="language-yaml">      {- $releaseName := .Release.Name -}
      {- with .Values.label }
        project: { .project }
        app: { .app }
        release: { $releaseName }
        # 或者可以使用$符号,引入全局命名空间
        release: { $.Release.Name }
      {- end }
</code></pre>
<p>可以看到在 <code>with</code>语句上面增加了一句 <code>{-$releaseName:=.Release.Name-}</code>，其中 <code>$releaseName</code>就是后面的对象的一个引用变量，它的形式就是 <code>$name</code>，赋值操作使用 <code>:=</code>，这样 <code>with</code>语句块内部的 <code>$releaseName</code>变量仍然指向的是 <code>.Release.Name</code></p>
<h2 id="8-命名模板">8、命名模板</h2>
<p>命名模板：使用<code>define</code>定义，<code>template</code>引入，在<code>templates</code>目录中默认下划线_开头的文件为<code>公共模板(_helpers.tpl)</code></p>
<pre><code class="language-yaml"># cat _helpers.tpl
{- define &quot;demo.fullname&quot; -}
{- .Chart.Name -}-{ .Release.Name }
{- end -}

# cat deployment.yaml 
apiVersion: apps/v1
kind: Deployment
metadata:
  name: { template &quot;demo.fullname&quot; . }
...
</code></pre>
<p><code>template</code>指令是将一个模板包含在另一个模板中的方法。但是，<code>template</code>函数不能用于<code>Go</code>模板管道。为了解决该问题，增加<code>include</code>功能</p>
<pre><code class="language-yaml"># cat _helpers.tpl
{- define &quot;demo.labels&quot; -}
app: { template &quot;demo.fullname&quot; . }
chart: &quot;{ .Chart.Name }-{ .Chart.Version }&quot;
release: &quot;{ .Release.Name }&quot;
{- end -}

# cat deployment.yaml 
apiVersion: apps/v1
kind: Deployment
metadata:
  name: { include &quot;demo.fullname&quot; . }
  labels:
    {- include &quot;demo.labels&quot; . | nindent 4 }
...
</code></pre>
<p>上面包含一个名为 <code>demo.labels</code> 的模板，然后将值 <code>.</code> 传递给模板，最后将该模板的输出传递给 <code>nindent</code> 函数</p>
<h2 id="9-开发chart的流程">9、开发Chart的流程</h2>
<p>先创建模板</p>
<pre><code>helm create demo
</code></pre>
<p>修改<code>Chart.yaml</code>，<code>Values.yaml</code>，添加常用的变量</p>
<p>在<code>templates</code>目录下创建部署镜像所需要的<code>yaml</code>文件，并变量引用<code>yaml</code>里经常变动的字段</p>
<p>更多内容可以参考<a href="https://helm.sh/zh/docs/topics/charts/">官方文档</a></p>
<p>See you ~</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Azure DevOps的使用入门]]></title>
        <id>https://www.ssgeek.com/post/azure-devops-de-shi-yong-ru-men</id>
        <link href="https://www.ssgeek.com/post/azure-devops-de-shi-yong-ru-men">
        </link>
        <updated>2021-11-03T16:54:27.000Z</updated>
        <content type="html"><![CDATA[<p><ul class="markdownIt-TOC">
<li>
<ul>
<li><a href="#1-%E4%BB%8B%E7%BB%8D">1、介绍</a></li>
<li><a href="#2-%E6%9C%8D%E5%8A%A1%E5%BC%80%E9%80%9A">2、服务开通</a></li>
<li><a href="#3-%E6%B7%BB%E5%8A%A0ssh-key">3、添加ssh key</a></li>
<li><a href="#4-%E6%B5%8B%E8%AF%95%E9%A1%B9%E7%9B%AE">4、测试项目</a>
<ul>
<li><a href="#41-%E6%8F%90%E4%BA%A4%E4%BB%A3%E7%A0%81">4.1 提交代码</a></li>
<li><a href="#42-%E5%88%9B%E5%BB%BApipeline">4.2 创建pipeline</a></li>
</ul>
</li>
<li><a href="#4-%E6%9C%8D%E5%8A%A1%E7%9A%84%E9%83%A8%E7%BD%B2">4、服务的部署</a></li>
<li><a href="#5-%E5%B0%8F%E7%BB%93">5、小结</a></li>
</ul>
</li>
</ul>
</p>
<figure data-type="image" tabindex="1"><img src="https://image.ssgeek.com/20211104-01.png" alt=""></figure>
<h2 id="1-介绍">1、介绍</h2>
<p><code>Azure DevOps</code>是由微软开发的服务平台，它提供了多种工具，可用于更好地进行团队协作。它还具有用于自动构建过程，测试，版本控制和程序包管理的工具</p>
<p><code>Azure DevOps</code>提供了<code>5</code>个主要模块</p>
<ul>
<li>Azure Boards：敏捷工具</li>
<li>Azure Repos：无限的、云托管的私人和公共<code>Git</code> 库</li>
<li>Azure Pipelines：构建流水线</li>
<li>Azure Test Plans：测试工具</li>
<li>Azure Artifacts： 制品包存档</li>
</ul>
<p>除此之外，在扩展市场还有超过<code>1,000</code>个应用和工具可供选择，这点和自家产品<code>VS Code</code>一样，有着非常强大的插件生态</p>
<h2 id="2-服务开通">2、服务开通</h2>
<p>主要步骤如下</p>
<ul>
<li>访问<code>dev.azure.com</code></li>
<li>点击“免费开始使用”</li>
<li>使用<code>Microsoft</code>帐户或<code>Github</code>帐户登录(从<code>2018</code>年的某一天起，<code>Github</code>也是微软自家的了)</li>
<li>创建一个<code>organization</code>（组织）</li>
<li>创建一个<code>project</code>（项目）</li>
</ul>
<figure data-type="image" tabindex="2"><img src="https://image.ssgeek.com/20211104-02.png" alt=""></figure>
<h2 id="3-添加ssh-key">3、添加ssh key</h2>
<p>依次点击<code>User settings</code> —&gt; <code>Security</code> —&gt; <code>SSH Public Keys</code> —&gt; <code>New key</code>，输入本地的<code>git ssh</code>公钥</p>
<figure data-type="image" tabindex="3"><img src="https://image.ssgeek.com/20211104-03.png" alt=""></figure>
<h2 id="4-测试项目">4、测试项目</h2>
<h3 id="41-提交代码">4.1 提交代码</h3>
<p>提交测试代码，从<code>github</code>克隆并手动推送到到<code>azure devops repo</code>上</p>
<p>当然，也可以直接导入<code>github</code>项目到<code>azure devops</code>界面，这里记录的是提交代码过程</p>
<pre><code class="language-shell">➜  git clone https://github.com/MicrosoftDocs/pipelines-java &amp;&amp; cd pipelines-java
Cloning into 'pipelines-java'...
remote: Enumerating objects: 107, done.
remote: Total 107 (delta 0), reused 0 (delta 0), pack-reused 107
Receiving objects: 100% (107/107), 73.86 KiB | 134.00 KiB/s, done.
Resolving deltas: 100% (38/38), done.
➜  git:(master) git remote add azure git@ssh.dev.azure.com:v3/ssgeek/test-project/test-project
➜  git:(master) git push -u azure --all
</code></pre>
<figure data-type="image" tabindex="4"><img src="https://image.ssgeek.com/20211104-04.png" alt=""></figure>
<h3 id="42-创建pipeline">4.2 创建pipeline</h3>
<p>创建第一个<code>pipeline</code>管道</p>
<ul>
<li>
<p>登录到<code>Azure DevOps</code>组织，并导航到项目</p>
</li>
<li>
<p>转到<code>pipeline</code>，然后选择&quot;新建<code>Create Pipeline</code></p>
</li>
<li>
<p>选择<code>Azure Repos Git</code>作为源代码位置，进一步选择刚才创建的<code>test-project</code>这个仓库</p>
</li>
</ul>
<p>配置项目流水线类型<code>Configure your pipeline</code>，这里识别出了是<code>java</code>库，可选择的类型有四种</p>
<ul>
<li>Maven类型</li>
<li>Maven类型并部署到azure cloud上</li>
<li>自定义最小化pipeline</li>
<li>选择现有的 Azure Pipelines YAML 文件</li>
</ul>
<p>由于仓库中没有<code>pipeline</code>文件，这里选择自动生成一个<code>pipeline</code>文件</p>
<p>自动生成的<code>pipeline</code>文件内容如下</p>
<pre><code class="language-yaml"># Maven
# Build your Java project and run tests with Apache Maven.
# Add steps that analyze code, save build artifacts, deploy, and more:
# https://docs.microsoft.com/azure/devops/pipelines/languages/java

trigger:
- master

pool:
  vmImage: ubuntu-latest

steps:
- task: Maven@3
  inputs:
    mavenPomFile: 'pom.xml'
    mavenOptions: '-Xmx3072m'
    javaHomeOption: 'JDKVersion'
    jdkVersionOption: '1.8'
    jdkArchitectureOption: 'x64'
    publishJUnitResults: true
    testResultsFiles: '**/surefire-reports/TEST-*.xml'
    goals: 'package'
</code></pre>
<p>点击<code>Save and run</code></p>
<figure data-type="image" tabindex="5"><img src="https://image.ssgeek.com/20211104-05.png" alt=""></figure>
<p>查看构建日志</p>
<figure data-type="image" tabindex="6"><img src="../../../../temp/20211104-06.png" alt=""></figure>
<p>此时是构建失败的，也可以到控制台中查看构建错误提示</p>
<figure data-type="image" tabindex="7"><img src="https://image.ssgeek.com/20211104-07.png" alt=""></figure>
<p>从提示可以看出构建失败，在于使用<code>Azure Pipelines</code>生成代码或部署，需要至少一个代理<code>agent</code>，真正运行构建任务的是代理<code>agent</code>，这里并没有购买或授予任何托管用于运行<code>pipeline</code>任务的<code>agent</code>，可以按照提示的链接<a href="https://aka.ms/azpipelines-parallelism-request">申请免费的Agent</a></p>
<p>此代理可以绑定微软云代理，也可以绑定自托管的代理（<code>Linux</code>、<code>Windows</code>、<code>macOS</code>）</p>
<p>申请后过几个小时就可以了，再去修改代码触发运行或者手动运行<code>pipeline</code>，成功运行</p>
<figure data-type="image" tabindex="8"><img src="https://image.ssgeek.com/20211104-08.png" alt=""></figure>
<h2 id="4-服务的部署">4、服务的部署</h2>
<p>构建流程运行完成后，就涉及到服务的部署了</p>
<p>在<code>azure devops</code>中，服务部署支持部署到<code>VM</code>和<code>kubernetes</code>环境</p>
<p>配置目标环境的方法，选择<code>Pipelines</code> —&gt; <code>Environments</code> —&gt; <code>Create environments</code></p>
<figure data-type="image" tabindex="9"><img src="https://image.ssgeek.com/20211104-09.png" alt=""></figure>
<p>以<code>k8s</code>资源为例，直接配置连接<code>azure cloud</code>的<code>k8s</code>，或者用<code>service account</code>进行配置通用的<code>k8s</code>集群</p>
<img src="https://image.ssgeek.com/20211104-10.png" style="zoom: 33%;" />
<p>具体的部署模式可以选择<code>yaml</code>部署、<code>helm</code>部署、以及<code>azure devops</code>支持的<code>Canary</code>灰度部署等等</p>
<h2 id="5-小结">5、小结</h2>
<p><code>azure devops</code>的模式和<code>gitlab ci</code>一样，自身集成了代码库管理和<code>devops</code>流水线功能，其运行任务的节点类似<code>gitlab runner</code>，是商业化<code>devops</code>产品的一大选择</p>
<p>最重要的是，<code>azure devops Pipelines</code>一个月有<code>1800</code>分钟的免费额度，这个免费并不是付费才能“解锁更多姿势”的那种，足够良心</p>
<p>从个人使用来看，界面足够简约好用</p>
<p>所以综上，如果是想白嫖使用商业的<code>devops</code>产品，<code>azure devops</code>可以首选</p>
<p><code>azure pipeline</code>的语法和<code>gitlab ci</code>语法也非常类似，后面再提及了</p>
<p>See you ~</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Mac + VMware Fusion + Windows 11尝鲜]]></title>
        <id>https://www.ssgeek.com/post/macvmwarefusionwindows11-chang-xian</id>
        <link href="https://www.ssgeek.com/post/macvmwarefusionwindows11-chang-xian">
        </link>
        <updated>2021-10-29T07:05:42.000Z</updated>
        <content type="html"><![CDATA[<p><ul class="markdownIt-TOC">
<li>
<ul>
<li><a href="#1-%E9%97%B2%E8%81%8A%E7%AF%87">1、闲聊篇</a></li>
<li><a href="#2-%E8%BD%AF%E4%BB%B6%E7%89%88%E6%9C%AC%E8%AF%B4%E6%98%8E">2、软件版本说明</a></li>
<li><a href="#3-%E5%AE%89%E8%A3%85vmware-fusion">3、安装VMware Fusion</a></li>
<li><a href="#4-%E5%AE%89%E8%A3%85windows-11">4、安装Windows 11</a>
<ul>
<li><a href="#41-%E6%96%B0%E5%BB%BA%E8%99%9A%E6%8B%9F%E6%9C%BA">4.1 新建虚拟机</a></li>
<li><a href="#42-%E8%99%9A%E6%8B%9F%E6%9C%BA%E8%AE%BE%E7%BD%AE">4.2 虚拟机设置</a></li>
<li><a href="#43-%E5%AE%89%E8%A3%85%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F">4.3 安装操作系统</a></li>
</ul>
</li>
</ul>
</li>
</ul>
</p>
<figure data-type="image" tabindex="1"><img src="https://image.ssgeek.com/20211029-01.png" alt=""></figure>
<h2 id="1-闲聊篇">1、闲聊篇</h2>
<p>从有印象接触所谓 “<strong>操作系统</strong>” 的概念开始，大一就将属于我的第一台电脑（联想<code>G510</code>）换成了<code>Windows 10</code>操作系统，如今<code>Windows 10</code>已经和<code>Windows 7</code>一样，都已成为或将成为过去式了</p>
<p><code>Windows 11</code>于<code>10</code>月<code>5</code>日正式推出，因此即使在成为果粉之后，仍旧怀着好奇的心情，当然也是要安装来玩一玩的</p>
<p><code>VMware Fusion</code>和<code>Parallel Desktop</code>都是<code>macOS</code>下成熟的虚拟化方案。出于对<code>VMware</code>系列产品<code>Workstation</code>、<code>Fusion</code>、<code>Hypervisor(ESXi)</code>、<code>vSphere</code>、<code>VCSA</code>、<code>vCenter</code>、<code>Tanzu</code>等多个产品的使用，我选择的是更熟悉的<code>VMware Fusion</code>。相比之下，前者面向个人用户可以免费使用</p>
<h2 id="2-软件版本说明">2、软件版本说明</h2>
<p>我采用的硬件及软件说明如下</p>
<ul>
<li>
<p>硬件及操作系统：Mac mini (2018)</p>
<ul>
<li>CPU：Intel i7-8700B 6 cores (12 threads)</li>
<li>Memory：32GB DDR4</li>
<li>mac操作系统：macOS Monterey 12.0.1 正式版（目前最新）</li>
</ul>
</li>
<li>
<p>虚拟化软件：VMware Fusion 12.2.0专业版（目前最新）</p>
</li>
<li>
<p>Windows操作系统：Win11官网的纯净版Win11_Chinese(Simplified)_x64（目前最新）</p>
<p>下载地址：<a href="https://www.microsoft.com/zh-cn/software-download/windows11">https://www.microsoft.com/zh-cn/software-download/windows11</a></p>
</li>
</ul>
<h2 id="3-安装vmware-fusion">3、安装VMware Fusion</h2>
<p>首先需要安装虚拟化软件<code>VMware Fusion</code>，安装过程这里就省略了</p>
<img src="https://image.ssgeek.com/20211029-02.png" style="zoom: 33%;" />
<p>安装完成后配置一块用来设置静态网卡的虚拟网卡，用于给虚拟机设置静态<code>ip</code>，当然也可以选择默认的动态<code>dhcp</code>模式</p>
<img src="https://image.ssgeek.com/20211029-03.png" style="zoom: 33%;" />
<h2 id="4-安装windows-11">4、安装Windows 11</h2>
<h3 id="41-新建虚拟机">4.1 新建虚拟机</h3>
<p>打开<code>VMware Fusion</code>，选择新建虚拟机并选择下载好的<code>Win 11</code>的镜像<code>ISO</code>文件</p>
<img src="https://image.ssgeek.com/20211029-04.png" style="zoom: 33%;" />
<p>选择操作系统，选择<code>Windows 10</code>及更高版本<code>64</code>位</p>
<p>指定引导固件，选择传统<code>UEFI</code></p>
<h3 id="42-虚拟机设置">4.2 虚拟机设置</h3>
<p>接着自定义虚拟机设置，这里为虚拟机设置<code>4</code>核<code>CPU</code>和<code>8GB</code>内存，虚拟磁盘大小设置为默认的<code>60GB</code></p>
<img src="https://image.ssgeek.com/20211029-05.png" style="zoom: 33%;" />
<p>关于硬件要求，在官网有相应的<a href="https://www.microsoft.com/zh-cn/windows/windows-11-specifications">Windows 11系统要求说明</a></p>
<img src="https://image.ssgeek.com/20211029-06.png" style="zoom: 50%;" />
<p>这里要提到的是，除了常规的要求说明之外，这里要求<strong>受信任的平台模块TPM</strong>为<code>2.0</code>版本，可以参考<a href="https://docs.microsoft.com/zh-cn/windows/security/information-protection/tpm/trusted-platform-module-overview">受信任的平台模块技术</a></p>
<p>简单来说，受信任的平台模块 (<code>TPM</code>) 技术设计用于提供基于硬件的安全性相关的功能。 <code>TPM</code>芯片是一个安全的加密处理器，有助于执行生成、存储和限制加密密钥的使用等操作。 它包含多个物理安全机制来使其无法篡改，恶意软件无法篡改 TPM 的安全功能。而这也是<code>Windows</code>系列操作系统的必须要求</p>
<p>启用加密，对加密虚拟机硬盘做<code>TPM 2.0</code>支持。点击启用加密，输入密码即可</p>
<img src="https://image.ssgeek.com/20211029-07.png" style="zoom: 33%;" />
<p>添加可信平台模块，以便<code>Win11</code>将<code>Mac</code>视为可接受的硬件，在设置界面的右上角点击添加设备，点击添加可信平台模块</p>
<p>可信平台模块只能添加到使用<code>UEFI</code>固件的虚拟机中，因此如果在开始新建虚拟机设置引导时就不能选择传统<code>BIOS</code></p>
<img src="https://image.ssgeek.com/20211029-08.png" style="zoom: 33%;" />
<h3 id="43-安装操作系统">4.3 安装操作系统</h3>
<p>上述准备工作完成后，开始正式安装操作系统，如果不满足要求，在引导安装时会进行硬件检查，提示环境不足以支持<code>Windows 11</code>的安装，这也是有文章写到 “<strong>Win11面世，你的电脑准备好了吗？</strong>”表示对硬件要求是较高的，很多设备可能都不支持安装了</p>
<ul>
<li>安装系统</li>
</ul>
<p>开启虚拟机电源，开机安装操作系统，和常规安装<code>Windows</code>操作系统一样，就没什么特别之处了</p>
<p>在选择要安装的操作系统上，选择<code>Windows 11</code>专业版本即可</p>
<ul>
<li>安装VMware Tools</li>
</ul>
<p>安装完操作系统之后，安装<code>VMware Tools</code>增强工具，使用户通过虚拟机操作系统进行无缝交互</p>
<ul>
<li>激活</li>
</ul>
<p>利用<code>kms server</code>方式激活操作系统</p>
<pre><code class="language-shell">slmgr /upk
slmgr /ipk W269N-WFGWX-YVC9B-4J6C9-T83GX
slmgr /skms 172.16.0.100
slmgr /ato
</code></pre>
<ul>
<li>关机重启，并卸载掉镜像盘</li>
</ul>
<p>最后，大功告成，来张主页图吧~</p>
<figure data-type="image" tabindex="2"><img src="https://image.ssgeek.com/20211029-09.png" alt=""></figure>
<p>See you ~</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Golang接口类型-下篇]]></title>
        <id>https://www.ssgeek.com/post/golang-jie-kou-lei-xing-xia-pian</id>
        <link href="https://www.ssgeek.com/post/golang-jie-kou-lei-xing-xia-pian">
        </link>
        <updated>2021-10-28T09:24:40.000Z</updated>
        <content type="html"><![CDATA[<p><ul class="markdownIt-TOC">
<li>
<ul>
<li><a href="#1-%E6%8E%A5%E5%8F%A3%E5%B5%8C%E5%85%A5">1、接口嵌入</a>
<ul>
<li><a href="#11-%E5%AE%9A%E4%B9%89">1.1 定义</a></li>
<li><a href="#12-%E5%AE%9E%E7%8E%B0">1.2 实现</a></li>
<li><a href="#13-%E4%BD%BF%E7%94%A8">1.3 使用</a></li>
</ul>
</li>
<li><a href="#2-%E5%8C%BF%E5%90%8D%E6%8E%A5%E5%8F%A3%E5%92%8C%E7%A9%BA%E6%8E%A5%E5%8F%A3">2、匿名接口和空接口</a>
<ul>
<li><a href="#21-%E5%8C%BF%E5%90%8D%E6%8E%A5%E5%8F%A3">2.1 匿名接口</a></li>
<li><a href="#22-%E7%A9%BA%E6%8E%A5%E5%8F%A3">2.2 空接口</a></li>
<li><a href="#23-%E4%BD%BF%E7%94%A8%E5%9C%BA%E6%99%AF">2.3 使用场景</a></li>
</ul>
</li>
<li><a href="#3-%E6%8E%A5%E5%8F%A3%E6%96%AD%E8%A8%80%E5%92%8C%E6%9F%A5%E8%AF%A2">3、接口断言和查询</a>
<ul>
<li><a href="#31-%E6%96%AD%E8%A8%80">3.1 断言</a></li>
<li><a href="#32-%E6%9F%A5%E8%AF%A2">3.2 查询</a></li>
</ul>
</li>
</ul>
</li>
</ul>
</p>
<figure data-type="image" tabindex="1"><img src="https://image.ssgeek.com/golang.png" alt=""></figure>
<p>本文是<a href="https://www.ssgeek.com/post/golang-jie-kou-lei-xing-shang-pian/">Golang接口类型-上篇</a>的续篇内容</p>
<h2 id="1-接口嵌入">1、接口嵌入</h2>
<p>和结构体<code>struct</code>一样，接口之中也可以嵌入已存在的接口，从而实现接口的扩展</p>
<h3 id="11-定义">1.1 定义</h3>
<pre><code class="language-go">// Sender 定义Sender接口
type Sender interface {
	Send(msg string) error
}

// Receiver 定义Receiver接口
type Receiver interface {
	Receive() (string, error)
}

// Client Client，由Sender和Receiver组合
type Client interface {
	Sender  // 匿名嵌入
	Receiver  // 匿名嵌入
	Open() error
	Close() error
}
</code></pre>
<h3 id="12-实现">1.2 实现</h3>
<pre><code class="language-go">// MSNClient 定义MSNClient结构体，并实现Client接口中Open/Send/Receive/Close方法
type MSNClient struct{
}

func (c MSNClient) Open() error {
	fmt.Println(&quot;Open&quot;)
	return nil
}

func (c MSNClient) Close() error {
	fmt.Println(&quot;Close&quot;)
	return nil
}

func (c MSNClient) Send(msg string) error {
	fmt.Println(&quot;send:&quot;, msg)
	return nil
}

func (c MSNClient) Receive() (string, error) {
	fmt.Println(&quot;Receive&quot;)
	return &quot;&quot;, nil
}
</code></pre>
<h3 id="13-使用">1.3 使用</h3>
<pre><code class="language-go">func main() {
	//msn := MSNClient{}
	//var s Sender = msn
	//var r Receiver = msn
	//var c Client = msn
	//s.Send(&quot;1&quot;)
	//r.Receive()
	//c.Open()
	//defer c.Close()
	//c.Send(&quot;2&quot;)
	//c.Receive()
	var client Client = MSNClient{}
	client.Open()
	client.Send(&quot;Hi&quot;)
	msg,_ := client.Receive()
	fmt.Printf(&quot;%q\n&quot;, msg)
	client.Close()
}
</code></pre>
<h2 id="2-匿名接口和空接口">2、匿名接口和空接口</h2>
<h3 id="21-匿名接口">2.1 匿名接口</h3>
<p>在定义变量时将类型指定为接口的函数签名的接口，此时叫匿名接口，匿名接口常用于初始化一次接口变量的场景</p>
<pre><code class="language-go">//通过匿名接口声明接口变量
var closer interface {
	Close() error
}
closer = msn
closer.Close()
</code></pre>
<h3 id="22-空接口">2.2 空接口</h3>
<p>不包含任何函数签名的接口叫做空接口，空接口声明的变量可以赋值为任何类型的变量（任意接口）</p>
<ul>
<li>空接口类型用<code>interface{}</code>表示，注意有<code>{}</code></li>
<li>空接口没有定义任何方法，因此任意类型都实现了空接口</li>
<li><code>func square(x interface{}){}</code>该函数可以接收任意数据类型</li>
<li><code>slice</code>的元素、<code>map</code>的<code>key</code>和<code>value</code>都可以是空接口类型</li>
</ul>
<p>定义语法：<code>interface{}</code></p>
<pre><code class="language-go">package main

import &quot;fmt&quot;

type EStruct struct {
}

type Empty interface {
}

func main() {
	es := EStruct{}
	var e interface{} = 1
	fmt.Println(es, e)  // {} 1
	e = &quot;test&quot;
	fmt.Println(e)  // test
	e = true
	fmt.Println(e)  // true
	e = es
	fmt.Println(e)  // {}
}
</code></pre>
<h3 id="23-使用场景">2.3 使用场景</h3>
<p>声明函数参数类型为<code>interface{}</code>，用于接收任意类型的变量</p>
<pre><code class="language-go">package main

import &quot;fmt&quot;

type EStruct struct{
}

func printType(args ...interface{}) {
	fmt.Println(&quot;------------------------&quot;)
	for _, arg := range args {
		//fmt.Println(arg)
		switch v := arg.(type) {
		case int:
			fmt.Printf(&quot;Int: %T %v\n&quot;, v, v)
		case string:
			fmt.Printf(&quot;String: %T %v\n&quot;, v, v)
		default:
			fmt.Printf(&quot;Other: %T %v\n&quot;, v, v)
		}
	}
}

func main() {
	es := EStruct{}
	printType(1, &quot;test&quot;, true, es)
	/*
	Int: int 1
	String: string test
	Other: bool true
	Other: main.EStruct {}
	 */
}
</code></pre>
<h2 id="3-接口断言和查询">3、接口断言和查询</h2>
<p>类型赋值成了接口类型，能否通过某种方式转换成当时赋值的类型呢？</p>
<p>当父集接口或者类型对象赋值给接口变量后，需要将接口变量重新转换为原来的类型，需要使用类型断言/查询</p>
<h3 id="31-断言">3.1 断言</h3>
<p>语法：<code>接口变量.(Type)</code><br>
判断一个接口能否转换成具体类型</p>
<pre><code class="language-go">// 使用类型断言信息转换
sender01, ok := ssender.(Sender)
fmt.Printf(&quot;%T, %#v, %v\n&quot;, sender01, sender01, ok)  // *main.WechatSender, &amp;main.WechatSender{ID:&quot;&quot;}, true
sender01.SendAll([]string{&quot;张三&quot;, &quot;李四&quot;},&quot;你好&quot;)
if sender02, ok := ssender.(*WechatSender); ok {
	fmt.Printf(&quot;%T, %#v, %v\n&quot;, sender02, sender02, ok)  // *main.WechatSender, &amp;main.WechatSender{ID:&quot;&quot;}, true
	fmt.Println(sender02.ID)
}
if sender03, ok := ssender.(*EmailSender); !ok {
	fmt.Printf(&quot;%T, %#v, %v\n&quot;, sender03, sender03, false)  // *main.EmailSender, (*main.EmailSender)(nil), false
}
</code></pre>
<h3 id="32-查询">3.2 查询</h3>
<p>可以通过<code>switch-case</code>+<code>接口变量.(type)</code>查询变量类型，并选择对应的分支块</p>
<pre><code class="language-go">// 使用类型查询
sender = &amp;EmailSender{&quot;test&quot;}
switch v := sender.(type) {
case EmailSender:
	fmt.Println(&quot;EmailSender&quot;, v.SmtpAddr)
case *EmailSender:
	fmt.Println(&quot;*EmailSender&quot;, v.SmtpAddr)  // *EmailSender test
case *SmsSender:
	fmt.Println(&quot;*SmsSender&quot;, v.SmsAPI)
case *WechatSender:
	fmt.Println(&quot;*WechatSender&quot;, v.ID)
default:
	fmt.Printf(&quot;error, %#v\n&quot;, v)
}
</code></pre>
<p>利用断言判断数据类型</p>
<pre><code class="language-go">package main

import &quot;fmt&quot;

func assert(i interface{})  {
	switch v := i.(type) {
	case int:  // v已被转为int类型
		//v := i.(int)
		fmt.Printf(&quot;%d\n&quot;, v)
		// 在 Type Switch语句的case子句中不能使用fallthrough
	case float64:  // v已被转为float64类型
		fmt.Printf(&quot;%f\n&quot;, v)
	case byte, uint16, string:  // 如果case后面跟多种type，则v还是interface{}类型
		fmt.Printf(&quot;%T %v\n&quot;, i, i)
	}
}

func main()  {
	var i interface{}
	var a int
	var b float64
	var c byte
	i = a
	assert(i)  // 0
	i = b
	assert(i)  // 0.000000
	i = c
	assert(i)  // uint8 0
}
</code></pre>
<p>See you ~</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Golang接口类型-上篇]]></title>
        <id>https://www.ssgeek.com/post/golang-jie-kou-lei-xing-shang-pian</id>
        <link href="https://www.ssgeek.com/post/golang-jie-kou-lei-xing-shang-pian">
        </link>
        <updated>2021-10-21T16:10:39.000Z</updated>
        <content type="html"><![CDATA[<p><ul class="markdownIt-TOC">
<li>
<ul>
<li><a href="#1-%E6%A6%82%E8%BF%B0">1、概述</a></li>
<li><a href="#2-%E6%8E%A5%E5%8F%A3%E7%9A%84%E9%9A%90%E5%BC%8F%E5%AE%9E%E7%8E%B0">2、接口的隐式实现</a></li>
<li><a href="#3-%E6%8E%A5%E5%8F%A3%E5%AE%9A%E4%B9%89%E5%92%8C%E5%A3%B0%E6%98%8E">3、接口定义和声明</a></li>
<li><a href="#4-%E6%8E%A5%E5%8F%A3%E7%B1%BB%E5%9E%8B%E8%B5%8B%E5%80%BC">4、接口类型赋值</a></li>
<li><a href="#5-%E6%8E%A5%E5%8F%A3%E7%B1%BB%E5%9E%8B%E5%AF%B9%E8%B1%A1">5、接口类型对象</a></li>
<li><a href="#6-%E6%8E%A5%E5%8F%A3%E5%BA%94%E7%94%A8%E4%B8%BE%E4%BE%8B">6、接口应用举例</a></li>
</ul>
</li>
</ul>
</p>
<figure data-type="image" tabindex="1"><img src="https://image.ssgeek.com/golang.png" alt=""></figure>
<h2 id="1-概述">1、概述</h2>
<p>接口是计算机系统中多个组件共享的边界，不同的组件能够在边界上交换信息。接口的本质是引入一个新的中间层，调用方可以通过接口与具体实现分离，解除上下游的耦合，上层的模块不再需要依赖下层的具体模块，只需要依赖一个约定好的接口</p>
<p>简单来说，<code>Go</code>语言中的接口就是一组方法的签名。接口是<code>Go</code>语言整个类型系统的基石，其他语言的接口是不同组件之间的契约的存在，对契约的实现是强制性的，必须显式声明实现了该接口，这类接口称之为“侵入式接口”。而<code>Go</code>语言的接口是隐式存在，只要实现了该接口的所有函数则代表已经实现了该接口，并不需要显式的接口声明</p>
<p><strong>接口的比喻</strong><br>
​一个常见的例子，电脑上只有一个<code>USB</code>接口。这个<code>USB</code>接口可以接<code>MP3</code>、数码相机、摄像头、鼠标、键盘等。所有的上述硬件都可以公用这个接口，有很好的扩展性，该<code>USB</code>接口定义了一种规范，只要实现了该规范，就可以将不同的设备接入电脑，而设备的改变并不会对电脑本身有什么影响（低耦合）</p>
<p>接口表示调用者和设计者的一种约定，在多人合作开发同一个项目时，事先定义好相互调用的接口可以大大提高开发的效率。接口是用类来实现的，实现接口的类必须严格按照接口的声明来实现接口提供的所有功能。有了接口，就可以在不影响现有接口声明的情况下，修改接口的内部实现，从而使兼容性问题最小化</p>
<h2 id="2-接口的隐式实现">2、接口的隐式实现</h2>
<p>在<code>Java</code>中实现接口需要显式地声明接口并实现所有方法，而在<code>Go</code>中实现接口的所有方法就隐式地实现了接口<br>
定义接口需要使用<code>interface</code>关键字，在接口中只能定义方法签名，不能包含成员变量，例如</p>
<pre><code class="language-go">type error interface {
	Error() string
}
</code></pre>
<p>如果一个类型需要实现<code>error</code>接口，那么它只需要实现<code>Error() string</code>方法，下面的<code>RPCError</code>结构体就是 <code>error</code>接口的一个实现</p>
<pre><code class="language-go">type RPCError struct {
	Code    int64
	Message string
}

func (e *RPCError) Error() string {
	return fmt.Sprintf(&quot;%s, code=%d&quot;, e.Message, e.Code)
}
</code></pre>
<p>会发现上述代码根本就没有<code>error</code>接口的影子，这正是因为<code>Go</code>语言中接口的实现都是隐式的</p>
<h2 id="3-接口定义和声明">3、接口定义和声明</h2>
<p>接口是自定义类型，是对其他类型行为的抽象（定义一个接口类型，把其他类型的值赋值给自定义的接口）</p>
<p>接口定义使用<code>interface</code>标识，声明了一系列的函数签名（函数名、函数参数、函数返回值）在定义接口时可以指定接口名称，在后续声明接口变量时使用</p>
<p>声明接口变量只需要定义变量类型为接口名，此时变量被初始化为<code>nil</code></p>
<pre><code class="language-go">package main

import &quot;fmt&quot;

type Sender interface {
	Send(to string, msg string) error
	SendAll(tos []string, msg string) error
}

func main()  {
	var sender Sender
	fmt.Printf(&quot;%T %v\n&quot;, sender, sender)  // &lt;nil&gt; &lt;nil&gt;
}
</code></pre>
<h2 id="4-接口类型赋值">4、接口类型赋值</h2>
<p>为接口类型方法赋值，一般是定义一个结构体，需要保证结构体方法（方法名、参数）均与接口中定义相同</p>
<pre><code class="language-go">package main

import &quot;fmt&quot;

type Sender interface {
	Send(to string, msg string) error
	SendAll(tos []string, msg string) error
}

type EmailSender struct {
}

func (s EmailSender) Send(to, msg string) error {
	fmt.Println(&quot;发送邮件给:&quot;, to, &quot;,消息内容是:&quot;, msg)
	return nil
}

func (s EmailSender) SendAll(tos []string, msg string) error {
	for _, to := range tos {
		s.Send(to, msg)
	}
	return nil
}

func main() {
	var sender Sender = EmailSender{}
	fmt.Printf(&quot;%T %v\n&quot;, sender, sender) // &lt;nil&gt; &lt;nil&gt;
	sender.Send(&quot;geek&quot;, &quot;早上好&quot;)
	sender.SendAll([]string{&quot;aa&quot;,&quot;bb&quot;}, &quot;中午好&quot;)
}
</code></pre>
<p>使用接口的好处，概念上可能不好理解，来一个实际例子</p>
<pre><code class="language-go">package main

import &quot;fmt&quot;

type Sender interface {
	Send(to string, msg string) error
	SendAll(tos []string, msg string) error
}

type EmailSender struct {
}

func (s EmailSender) Send(to, msg string) error {
	fmt.Println(&quot;发送邮件给:&quot;, to, &quot;,消息内容是:&quot;, msg)
	return nil
}

func (s EmailSender) SendAll(tos []string, msg string) error {
	for _, to := range tos {
		s.Send(to, msg)
	}
	return nil
}

type SmsSender struct {
}

func (s SmsSender) Send(to, msg string) error {
	fmt.Println(&quot;发送短信给:&quot;, to, &quot;, 消息内容是:&quot;, msg)
	return nil
}

func (s SmsSender) SendAll(tos []string, msg string) error {
	for _, to := range tos {
		s.Send(to, msg)
	}
	return nil
}

//func do(sender EmailSender) {
func do(sender Sender) {
	sender.Send(&quot;领导&quot;, &quot;工作日志&quot;)
}

func main() {
	var sender Sender = EmailSender{}
	fmt.Printf(&quot;%T %v\n&quot;, sender, sender) // &lt;nil&gt; &lt;nil&gt;
	sender.Send(&quot;geek&quot;, &quot;早上好&quot;)
	sender.SendAll([]string{&quot;aa&quot;,&quot;bb&quot;}, &quot;中午好&quot;)
	do(sender)
	sender = SmsSender{}
	do(sender)
}
</code></pre>
<p>按照上面的示例，最后定义变量<code>sender</code>为接口类型<code>Sender</code>，调用接口方法时，只需要指定接口类型对应的结构体是什么，因为在定义接口时，已经声明了此接口实现了<code>Send</code>、<code>SendAll</code>两个方法</p>
<pre><code class="language-go">var sender Sender = EmailSender{}
// 或
var sender Sender = SmsSender{}
// 单独定义go函数调用
func do(sender Sender) {
	sender.Send(&quot;领导&quot;, &quot;工作日志&quot;)
}
</code></pre>
<p>如果没有接口，那么最终调用时，还需要对应上其具体的结构体类型，写法为</p>
<pre><code class="language-go">var sender EmailSender = EmailSender{}
// 或
var sender SmsSender = SmsSender{}
// 单独定义go函数调用
func do(sender EmailSender) {
// func do(sender SmsSender) {
	sender.Send(&quot;领导&quot;, &quot;工作日志&quot;)
}
</code></pre>
<p>很明显，前者使用接口定义变量，在传参时也使用接口类型定义，在使用上更为简单，仅仅只需要调整初始化的结构体类型即可</p>
<h2 id="5-接口类型对象">5、接口类型对象</h2>
<p>当自定义类型实现了接口类型中声明的所有函数时，则该类型的对象可以赋值给接口变量，并使用接口变量调用实现的接口</p>
<ul>
<li>
<p>方法接收者全为值类型<br>
如上面的例子</p>
</li>
<li>
<p>方法接收者全为指针类型</p>
</li>
</ul>
<pre><code class="language-go">package main

import &quot;fmt&quot;

type Sender interface {
	Send(to string, msg string) error
	SendAll(tos []string, msg string) error
}

type SmsSender struct {
}

func (s *SmsSender) Send(to, msg string) error {
	fmt.Println(&quot;发送短信给:&quot;, to, &quot;, 消息内容是:&quot;, msg)
	return nil
}

func (s *SmsSender) SendAll(tos []string, msg string) error {
	for _, to := range tos {
		s.Send(to, msg)
	}
	return nil
}

func do(sender Sender) {
	sender.Send(&quot;领导&quot;, &quot;工作日志&quot;)
}

func main() {
	var sender Sender = &amp;SmsSender{}  // 指针类型
	do(sender)
}
</code></pre>
<ul>
<li>方法接收者既有值类型又有指针类型</li>
</ul>
<p><code>WechatSender</code>的<code>send</code>和<code>sendAll</code>，<code>send</code>有指针和值，<code>sendAll</code>只有指针，因此初始化的时候只能用指针，不能用值</p>
<pre><code class="language-go">package main

import &quot;fmt&quot;

type Sender interface {
	Send(to string, msg string) error
	SendAll(tos []string, msg string) error
}

type WechatSender struct {
}

// Send 接收者为值对象
func (s WechatSender) Send(to, msg string) error {
	fmt.Println(&quot;发送微信给:&quot;, to, &quot;, 消息内容是:&quot;, msg)
	return nil
}

// SendAll 接收者为指针对象
func (s *WechatSender) SendAll(tos []string, msg string) error {
	for _, to := range tos {
		s.Send(to, msg)
	}
	return nil
}

//func do(sender EmailSender) {
func do(sender Sender) {
	sender.Send(&quot;领导&quot;, &quot;工作日志&quot;)
}

func main() {
	var sender Sender = &amp;WechatSender{}
	do(sender)
}
</code></pre>
<p>当接口(A)包含另外一个接口(B)中声明的所有函数时(A接口函数是B接口函数的父集，B是A的子集)，接口(A)的对象也可以赋值给其子集的接口(B)变量</p>
<pre><code class="language-go">package main

import &quot;fmt&quot;

type SignalSender interface {
	Send(to, msg string) error
}

type Sender interface {
	Send(to string, msg string) error
	SendAll(tos []string, msg string) error
}

...

func main() {
	var ssender SignalSender = sender  // 以接口的变量初始化另外一个接口
	ssender.Send(&quot;aa&quot;, &quot;你好&quot;)
}
</code></pre>
<p>若两个接口声明同样的函数签名，则这两个接口完全等价<br>
当类型和父集接口赋值给接口变量时，只能调用接口变量定义接口中声明的函数（方法）</p>
<h2 id="6-接口应用举例">6、接口应用举例</h2>
<p>实际的生产例子，可以加深对接口的理解。例如多个数据源推送和查询数据</p>
<pre><code class="language-go">package main

import (
	&quot;fmt&quot;
	&quot;log&quot;
)

/*
1、多个数据源
2、query方法查询数据
3、pushdata方法写入数据
 */

type DataSource interface {
	PushData(data string)
	QueryData(name string) string
}

type redis struct {
	Name string
	Addr string
}

func (r *redis) PushData (data string) {
	log.Printf(&quot;pushdata,name:%s,data:%s\n&quot;, r.Name,data)
}
func (r *redis) QueryData (name string) string {
	log.Printf(&quot;querydata,name:%s,data:%s\n&quot;, r.Name,name)
	return name + &quot;redis&quot;
}

type kafka struct {
	Name string
	Addr string
}

func (k *kafka) PushData (data string) {
	log.Printf(&quot;pushdata,name:%s,data:%s\n&quot;, k.Name,data)
}
func (k *kafka) QueryData (name string) string {
	log.Printf(&quot;querydata,name:%s,data:%s\n&quot;, k.Name,name)
	return name + &quot;kafka&quot;
}

var Dm = make(map[string]DataSource)

func main()  {
	r:=redis{
		Name: &quot;redis&quot;,
		Addr: &quot;127.0.0.1&quot;,
	}
	k:=kafka{
		Name:&quot;kafka&quot;,
		Addr:&quot;192.169.0.1&quot;,
	}
	// 注册数据源到承载的容器中
	Dm[&quot;redis&quot;] = &amp;r
	Dm[&quot;kafka&quot;] = &amp;k
	// 推送数据
	for i:=0;i&lt;5;i++{
		key:=fmt.Sprintf(&quot;key_%d&quot;, i)
		for _,ds:=range Dm{
			ds.PushData(key)
		}
	}
	// 查询数据
	for i:=0;i&lt;5;i++{
		key:=fmt.Sprintf(&quot;key_%d&quot;, i)
		//r:=Dm[&quot;redis&quot;]
		//r.QueryData(key)
		for _,ds:=range Dm{
			res:=ds.QueryData(key)
			log.Printf(&quot;query_from_ds,res:%s&quot;, res)
		}
	}
}
</code></pre>
<p>See you ~</p>
<blockquote>
<p>参考：https://draveness.me/golang/docs/part2-foundation/ch04-basic/golang-interface/</p>
</blockquote>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[基于Python实现原生的登录验证码]]></title>
        <id>https://www.ssgeek.com/post/ji-yu-python-shi-xian-yuan-sheng-de-deng-lu-yan-zheng-ma</id>
        <link href="https://www.ssgeek.com/post/ji-yu-python-shi-xian-yuan-sheng-de-deng-lu-yan-zheng-ma">
        </link>
        <updated>2021-10-13T16:11:09.000Z</updated>
        <content type="html"><![CDATA[<p><ul class="markdownIt-TOC">
<li>
<ul>
<li><a href="#1-%E6%A6%82%E8%BF%B0">1、概述</a></li>
<li><a href="#2-%E9%AA%8C%E8%AF%81%E7%A0%81%E5%AE%9E%E7%8E%B0%E7%9A%84%E6%BC%94%E8%BF%9B%E8%BF%87%E7%A8%8B">2、验证码实现的演进过程</a>
<ul>
<li><a href="#21-%E8%B7%AF%E7%94%B1%E5%8F%8A%E9%A1%B5%E9%9D%A2">2.1 路由及页面</a></li>
<li><a href="#22-%E8%A7%86%E5%9B%BE%E5%87%BD%E6%95%B0%E4%B8%AD%E9%AA%8C%E8%AF%81%E7%A0%81%E7%9A%84%E6%8E%A8%E5%AF%BC">2.2 视图函数中验证码的推导</a>
<ul>
<li><a href="#221-%E5%9B%BE%E7%89%87%E5%8F%91%E9%80%81%E5%88%B0%E5%89%8D%E7%AB%AF">2.2.1 图片发送到前端</a></li>
<li><a href="#222-%E5%BC%95%E5%85%A5%E5%8A%A8%E6%80%81%E5%9B%BE%E7%89%87">2.2.2 引入动态图片</a></li>
<li><a href="#223-%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86%E6%A8%A1%E5%9D%97%E5%9B%BE%E7%89%87">2.2.3 内存管理模块图片</a></li>
<li><a href="#224-%E5%AE%8C%E6%95%B4%E5%9B%BE%E7%89%87%E9%AA%8C%E8%AF%81%E7%A0%81">2.2.4 完整图片验证码</a></li>
</ul>
</li>
<li><a href="#23-%E7%99%BB%E5%BD%95%E9%AA%8C%E8%AF%81%E4%B8%AD%E4%BD%BF%E7%94%A8%E9%AA%8C%E8%AF%81%E7%A0%81">2.3 登录验证中使用验证码</a></li>
<li><a href="#24-%E5%89%8D%E7%AB%AF%E9%A1%B5%E9%9D%A2%E7%82%B9%E5%87%BB%E8%87%AA%E5%8A%A8%E5%88%B7%E6%96%B0">2.4 前端页面点击自动刷新</a></li>
</ul>
</li>
<li><a href="#3-%E6%95%88%E6%9E%9C%E5%B1%95%E7%A4%BA">3、效果展示</a></li>
<li><a href="#4-%E5%B0%8F%E7%BB%93">4、小结</a></li>
</ul>
</li>
</ul>
</p>
<figure data-type="image" tabindex="1"><img src="https://image.ssgeek.com/20211014-03.png" alt=""></figure>
<h2 id="1-概述">1、概述</h2>
<p>在前面的文章中，我有分享到<a href="https://www.ssgeek.com/post/vuedrfdi-san-fang-hua-dong-yan-zheng-ma-de-jie-ru-shi-xian/">vue+drf+第三方滑动验证码的接入实现</a>（文中也留了坑分享图片验证码功能的实现），即本文将要分享的是基于<code>python</code>实现原生的登录验证码</p>
<p>通常的验证码，人眼看上去更像是一张小图片</p>
<p>在<code>html</code>语法中，嵌入一张图片一般用<code>img</code>标签实现，而<code>img</code>标签对应的<code>src</code>一般有以下几种写法</p>
<ul>
<li>图片的本地路径</li>
<li>图片的url</li>
<li>图片的二进制数据（base64编码）</li>
</ul>
<p>其中前两种方法都需要外部具有实际存在的图片，第三种方法则是将图片进行编码后填充到<code>img</code>标签的<code>src</code>下</p>
<h2 id="2-验证码实现的演进过程">2、验证码实现的演进过程</h2>
<h3 id="21-路由及页面">2.1 路由及页面</h3>
<p>为了实现验证码的功能，需要开设一个<code>url</code>单独处理验证码功能，修改全局路由</p>
<pre><code class="language-python">urlpatterns = [
    ......
    url(r'^login/', views.login, name='login'),
    # 图片验证码
    url(r'^get_code/', views.get_code, name='gc'),
    ...
]
</code></pre>
<p>然后修改前端登录页面<code>login.html</code>的验证码部分</p>
<pre><code class="language-html">...
&lt;div class=&quot;form-group&quot;&gt;
    &lt;label for=&quot;&quot;&gt;验证码&lt;/label&gt;
    &lt;div class=&quot;row&quot;&gt;
        &lt;div class=&quot;col-md-6&quot;&gt;
            &lt;input type=&quot;text&quot; name=&quot;code&quot; id=&quot;id_code&quot; class=&quot;form-control&quot;&gt;
        &lt;/div&gt;
        &lt;div class=&quot;col-md-6&quot;&gt;
            &lt;img src=&quot;/get_code/&quot; alt=&quot;&quot; width=&quot;430&quot; height=&quot;35&quot; id=&quot;id_img&quot;&gt;
        &lt;/div&gt;
    &lt;/div&gt;

&lt;/div&gt;
&lt;input type=&quot;button&quot; class=&quot;btn btn-success&quot; value=&quot;登陆&quot; id=&quot;id_commit&quot;&gt;
...
</code></pre>
<h3 id="22-视图函数中验证码的推导">2.2 视图函数中验证码的推导</h3>
<h4 id="221-图片发送到前端">2.2.1 图片发送到前端</h4>
<p>前端界面实现了一个简单的包含验证码的登录框，首先定义一个视图函数将后端的测试图片以二进制的形式发送到前端进行测试</p>
<pre><code class="language-python">def get_code(request):
    # 直接获取后端现成的图片二进制数据发送给前端
    with open(r'static/img/test.jpg','rb') as f:
        data = f.read()
    return HttpResponse(data)
</code></pre>
<h4 id="222-引入动态图片">2.2.2 引入动态图片</h4>
<p>为了操作图片，主要利用的是<code>pillow</code>模块</p>
<pre><code class="language-shell">pip3 install pillow
</code></pre>
<p>主要用到了<code>Image</code>、<code>ImageDraw</code>、<code>ImageFont</code></p>
<ul>
<li>Image：生成图片</li>
<li>ImageDraw：在图片上定义内容</li>
<li>ImageFont：控制字体样式</li>
</ul>
<p>因此，利用<code>pillow</code>模块动态产生图片的方法为</p>
<pre><code class="language-python">import random
from PIL import Image, ImageDraw, ImageFont

def get_random():
    return random.randint(0, 255), random.randint(0, 255), random.randint(0, 255)


def get_code(request):
    # 利用pillow模块动态产生图片
    # img_obj = Image.new('RGB',(430,35),'green')  # RGB组合、图片尺寸、颜色
    img_obj = Image.new('RGB',(430,35),get_random())  # 通过色值指定颜色
    # 先将图片对象保存起来
    with open('xxx.png','wb') as f:
        img_obj.save(f,'png')
    # 再将图片对象读取出来
    with open('xxx.png','rb') as f:
        data = f.read()
    return HttpResponse(data)
</code></pre>
<h4 id="223-内存管理模块图片">2.2.3 内存管理模块图片</h4>
<p>上面将图片对象保存在读取有些麻烦，文件存储繁琐<code>IO</code>操作效率低 ，可以借助于内存管理器模块实现</p>
<p>其中又分为<code>BytesIO</code>和<code>StringIO</code>两种</p>
<ul>
<li>BytesIO:临时存储数据，返回的时候数据是二进制</li>
<li>StringIO:临时存储数据，返回的时候数据是字符串</li>
</ul>
<p>内存管理对象就相当于上面的文件句柄</p>
<pre><code class="language-python">import random
from PIL import Image, ImageDraw, ImageFont

def get_random():
    return random.randint(0, 255), random.randint(0, 255), random.randint(0, 255)


def get_code(request):
    img_obj = Image.new('RGB', (430, 35), get_random())
    io_obj = BytesIO()  # 生成一个内存管理器对象  你可以看成是文件句柄
    img_obj.save(io_obj,'png')
    return HttpResponse(io_obj.getvalue())  # 从内存管理器中读取二进制的图片数据返回给前端
</code></pre>
<p>这样一来，图片的生成以及返回就比较友好了</p>
<h4 id="224-完整图片验证码">2.2.4 完整图片验证码</h4>
<p>上面解决了图片如何传递到前端页面的问题，剩下的就是如何生成对应的随机验证码了</p>
<p>例如随机验证码为五位数的随机验证码，包含数字、小写字母、大写字母</p>
<pre><code class="language-python">import random
from PIL import Image, ImageDraw, ImageFont

def get_random():
    return random.randint(0, 255), random.randint(0, 255), random.randint(0, 255)


def get_code(request):
    # 写图片验证码
    img_obj = Image.new('RGB', (430, 35), get_random())
    img_draw = ImageDraw.Draw(img_obj)  # 产生一个画笔对象
    # 引入本地的字体文件，指定字体样式及字体大小
    img_font = ImageFont.truetype('static/font/222.ttf', 30) 
    # 随机验证码 五位数的随机验证码  数字 小写字母 大写字母
    code = ''
    for i in range(5):
        random_upper = chr(random.randint(65, 90))  # 随机大写字母
        random_lower = chr(random.randint(97, 122))  # 随机小写字母
        random_int = str(random.randint(0, 9))  # 随机数字
        # 每次从上面三个里面随机选择一个
        tmp = random.choice([random_lower, random_upper, random_int])
        # 将产生的随机字符串写入到图片上，需要调整每个字体所在的坐标变换
        img_draw.text((i * 60 + 60, -2), tmp, get_random(), img_font)
        # 拼接随机字符串
        code += tmp
    print(code)
    # 随机验证码在登陆的视图函数里面需要要比对,所以要找地方存起来并且其他视图函数也能拿到
    request.session['code'] = code
    io_obj = BytesIO()
    img_obj.save(io_obj, 'png')
    return HttpResponse(io_obj.getvalue())
</code></pre>
<p>这里有一点，在写入随机文字的时候一个个写而不是生成好了之后再写，是因为一个个写能够控制每个字体的间隙。而生成好之后再写的话，间隙就没法控制了</p>
<h3 id="23-登录验证中使用验证码">2.3 登录验证中使用验证码</h3>
<p>上面将每次生成的验证码存储到了<code>session</code>中，这样在前端传过来的验证码，登录校验时就可以进行比对了</p>
<pre><code class="language-python">......
def login(request):
    if request.method == 'POST':
        back_dic = {'code': 1000, 'msg': ''}
        username = request.POST.get('username')
        password = request.POST.get('password')
        code = request.POST.get('code')
        # 1 先校验验证码是否正确  自己决定是否忽略大小写 统一转大写或小写再比较
        if request.session.get('code').upper() == code.upper():
            # 校验用户名和密码是否正确
            user_obj = auth.authenticate(request,username=username,password=password)
            if user_obj:
                # 保存用户状态
                auth.login(request,user_obj)
                back_dic['url'] = '/home/'
            else:
                back_dic['code'] = 2000
                back_dic['msg'] = '用户名或密码错误'
        else:
            back_dic['code'] = 3000
            back_dic['msg'] = '验证码错误'
        return JsonResponse(back_dic)
    return render(request, 'login.html')
</code></pre>
<h3 id="24-前端页面点击自动刷新">2.4 前端页面点击自动刷新</h3>
<p>最后，还留下一点小问题，前端在输入验证码错误后不会自动刷新，如果点击验证码也不会进行刷新，只能通过刷新登录页面才能刷新验证码，因此需要想办法让用户在点击验证码时自动刷新（单独触发验证码的视图函数）</p>
<p>每次在点击时，修改对应<code>src</code>的值即可，可以通过一小段<code>js</code>实现</p>
<pre><code class="language-html">...
       &lt;div class=&quot;form-group&quot;&gt;
            &lt;label for=&quot;&quot;&gt;验证码&lt;/label&gt;

            &lt;div class=&quot;row&quot;&gt;
                &lt;div class=&quot;col-md-6&quot;&gt;
                    &lt;input type=&quot;text&quot; name=&quot;code&quot; id=&quot;id_code&quot; class=&quot;form-control&quot;&gt;
                &lt;/div&gt;
                &lt;div class=&quot;col-md-6&quot;&gt;
                    &lt;img src=&quot;/get_code/&quot; alt=&quot;&quot; width=&quot;430&quot; height=&quot;35&quot; id=&quot;id_img&quot;&gt;
                &lt;/div&gt;
            &lt;/div&gt;

        &lt;/div&gt;
        &lt;input type=&quot;button&quot; class=&quot;btn btn-success&quot; value=&quot;登陆&quot; id=&quot;id_commit&quot;&gt;
...
&lt;script&gt;
    $(&quot;#id_img&quot;).click(function () {
        // 获取标签之前的src
        let oldVal = $(this).attr('src');
        $(this).attr('src',oldVal += '?')
    })
&lt;/script&gt;
</code></pre>
<h2 id="3-效果展示">3、效果展示</h2>
<p>最终前端的验证码效果如图</p>
<figure data-type="image" tabindex="2"><img src="https://image.ssgeek.com/20211014-01.png" alt=""></figure>
<h2 id="4-小结">4、小结</h2>
<p>本文基于<code>python</code>以及相关的库原生实现了登录验证码逻辑~</p>
<p>其实写本文也是因为之前有过想法但是一段时间就忘了，最近通过某银行手机银行<code>app</code>重置登录密码的时候，发现其验证码显示效果和本文效果竟然神似~，于是捡起来写了此文</p>
<p>其手机<code>app</code>验证码效果如下</p>
<img src="https://image.ssgeek.com/20211014-02.png" alt="20211014-02" style="zoom: 50%;" />
<p>See you ~</p>
]]></content>
    </entry>
</feed>